/*@license Copyright 2015-2022 Ably Real-time Ltd (ably.com)

Ably JavaScript Library v1.2.48
https://github.com/ably/ably-js

Released under the Apache Licence v2.0*/
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/common/platform.ts
var Platform = class {
};

// src/common/lib/util/logger.ts
var globalObject = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : self;
function pad(timeSegment, three) {
  return `${timeSegment}`.padStart(three ? 3 : 2, "0");
}
function getHandler(logger) {
  return Platform.Config.logTimestamps ? function(msg) {
    const time = /* @__PURE__ */ new Date();
    logger(
      pad(time.getHours()) + ":" + pad(time.getMinutes()) + ":" + pad(time.getSeconds()) + "." + pad(time.getMilliseconds(), 1) + " " + msg
    );
  } : logger;
}
var getDefaultLoggers = () => {
  var _a2, _b;
  let consoleLogger;
  let errorLogger;
  if (typeof Window === "undefined" && typeof WorkerGlobalScope === "undefined" || typeof ((_b = (_a2 = globalObject == null ? void 0 : globalObject.console) == null ? void 0 : _a2.log) == null ? void 0 : _b.apply) === "function") {
    consoleLogger = function(...args) {
      console.log.apply(console, args);
    };
    errorLogger = console.warn ? function(...args) {
      console.warn.apply(console, args);
    } : consoleLogger;
  } else if (globalObject == null ? void 0 : globalObject.console.log) {
    consoleLogger = errorLogger = function() {
      Function.prototype.apply.call(console.log, console, arguments);
    };
  } else {
    consoleLogger = errorLogger = function() {
    };
  }
  return [consoleLogger, errorLogger].map(getHandler);
};
var _Logger = class _Logger {
  constructor() {
    _Logger.logLevel = _Logger.LOG_DEFAULT;
  }
  static initLogHandlers() {
    const [logHandler, logErrorHandler] = getDefaultLoggers();
    this.logHandler = logHandler;
    this.logErrorHandler = logErrorHandler;
  }
};
_Logger.logLevel = 1 /* Error */;
// public constants
_Logger.LOG_NONE = 0 /* None */;
_Logger.LOG_ERROR = 1 /* Error */;
_Logger.LOG_MAJOR = 2 /* Major */;
_Logger.LOG_MINOR = 3 /* Minor */;
_Logger.LOG_MICRO = 4 /* Micro */;
// aliases
_Logger.LOG_DEFAULT = 1 /* Error */;
_Logger.LOG_DEBUG = 4 /* Micro */;
/* public static functions */
_Logger.logAction = (level, action, message) => {
  if (_Logger.shouldLog(level)) {
    (level === 1 /* Error */ ? _Logger.logErrorHandler : _Logger.logHandler)("Ably: " + action + ": " + message);
  }
};
/* Where a logging operation is expensive, such as serialisation of data, use shouldLog will prevent
  the object being serialised if the log level will not output the message */
_Logger.shouldLog = (level) => {
  return level <= _Logger.logLevel;
};
_Logger.setLog = (level, handler) => {
  if (level !== void 0)
    _Logger.logLevel = level;
  if (handler !== void 0)
    _Logger.logHandler = _Logger.logErrorHandler = handler;
};
var Logger = _Logger;
var logger_default = Logger;

// src/common/lib/types/errorinfo.ts
function toString(err) {
  let result = "[" + err.constructor.name;
  if (err.message)
    result += ": " + err.message;
  if (err.statusCode)
    result += "; statusCode=" + err.statusCode;
  if (err.code)
    result += "; code=" + err.code;
  if (err.cause)
    result += "; cause=" + inspectError(err.cause);
  if (err.href && !(err.message && err.message.indexOf("help.ably.io") > -1))
    result += "; see " + err.href + " ";
  result += "]";
  return result;
}
var ErrorInfo = class _ErrorInfo extends Error {
  constructor(message, code, statusCode, cause) {
    super(message);
    if (typeof Object.setPrototypeOf !== "undefined") {
      Object.setPrototypeOf(this, _ErrorInfo.prototype);
    }
    this.code = code;
    this.statusCode = statusCode;
    this.cause = cause;
  }
  toString() {
    return toString(this);
  }
  static fromValues(values) {
    const { message, code, statusCode } = values;
    if (typeof message !== "string" || typeof code !== "number" || typeof statusCode !== "number") {
      throw new Error("ErrorInfo.fromValues(): invalid values: " + Platform.Config.inspect(values));
    }
    const result = Object.assign(new _ErrorInfo(message, code, statusCode), values);
    if (result.code && !result.href) {
      result.href = "https://help.ably.io/error/" + result.code;
    }
    return result;
  }
};
var PartialErrorInfo = class _PartialErrorInfo extends Error {
  constructor(message, code, statusCode, cause) {
    super(message);
    if (typeof Object.setPrototypeOf !== "undefined") {
      Object.setPrototypeOf(this, _PartialErrorInfo.prototype);
    }
    this.code = code;
    this.statusCode = statusCode;
    this.cause = cause;
  }
  toString() {
    return toString(this);
  }
};

// src/common/lib/util/utils.ts
function randomPosn(arrOrStr) {
  return Math.floor(Math.random() * arrOrStr.length);
}
function mixin(target, ...args) {
  for (let i = 0; i < args.length; i++) {
    const source = args[i];
    if (!source) {
      break;
    }
    const hasOwnProperty = Object.prototype.hasOwnProperty;
    for (const key in source) {
      if (!hasOwnProperty || hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
}
function copy(src) {
  return mixin({}, src);
}
var isArray = Array.isArray || function(value) {
  return Object.prototype.toString.call(value) == "[object Array]";
};
function ensureArray(obj) {
  if (isEmptyArg(obj)) {
    return [];
  }
  if (isArray(obj)) {
    return obj;
  }
  return [obj];
}
function isObject(ob) {
  return Object.prototype.toString.call(ob) == "[object Object]";
}
function isEmpty(ob) {
  for (const prop in ob)
    return false;
  return true;
}
function isEmptyArg(arg) {
  return arg === null || arg === void 0;
}
function intersect(arr, ob) {
  return isArray(ob) ? arrIntersect(arr, ob) : arrIntersectOb(arr, ob);
}
function arrIntersect(arr1, arr2) {
  const result = [];
  for (let i = 0; i < arr1.length; i++) {
    const member = arr1[i];
    if (arrIndexOf(arr2, member) != -1)
      result.push(member);
  }
  return result;
}
function arrIntersectOb(arr, ob) {
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    const member = arr[i];
    if (member in ob)
      result.push(member);
  }
  return result;
}
var arrIndexOf = Array.prototype.indexOf ? function(arr, elem, fromIndex) {
  return arr.indexOf(elem, fromIndex);
} : function(arr, elem, fromIndex) {
  fromIndex = fromIndex || 0;
  const len = arr.length;
  for (; fromIndex < len; fromIndex++) {
    if (arr[fromIndex] === elem) {
      return fromIndex;
    }
  }
  return -1;
};
function arrIn(arr, val) {
  return arrIndexOf(arr, val) !== -1;
}
function arrDeleteValue(arr, val) {
  const idx = arrIndexOf(arr, val);
  const res = idx != -1;
  if (res)
    arr.splice(idx, 1);
  return res;
}
function keysArray(ob, ownOnly) {
  const result = [];
  for (const prop in ob) {
    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop))
      continue;
    result.push(prop);
  }
  return result;
}
function valuesArray(ob, ownOnly) {
  const result = [];
  for (const prop in ob) {
    if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop))
      continue;
    result.push(ob[prop]);
  }
  return result;
}
function forInOwnNonNullProperties(ob, fn) {
  for (const prop in ob) {
    if (Object.prototype.hasOwnProperty.call(ob, prop) && ob[prop]) {
      fn(prop);
    }
  }
}
var arrForEach = Array.prototype.forEach ? function(arr, fn) {
  arr.forEach(fn);
} : function(arr, fn) {
  const len = arr.length;
  for (let i = 0; i < len; i++) {
    fn(arr[i], i, arr);
  }
};
function safeArrForEach(arr, fn) {
  return arrForEach(arr.slice(), fn);
}
var arrMap = Array.prototype.map ? function(arr, fn) {
  return arr.map(fn);
} : function(arr, fn) {
  const result = [];
  const len = arr.length;
  for (let i = 0; i < len; i++) {
    result.push(fn(arr[i], i, arr));
  }
  return result;
};
var arrFilter = Array.prototype.filter ? function(arr, fn) {
  return arr.filter(fn);
} : function(arr, fn) {
  const result = [], len = arr.length;
  for (let i = 0; i < len; i++) {
    if (fn(arr[i])) {
      result.push(arr[i]);
    }
  }
  return result;
};
var arrEvery = Array.prototype.every ? function(arr, fn) {
  return arr.every(fn);
} : function(arr, fn) {
  const len = arr.length;
  for (let i = 0; i < len; i++) {
    if (!fn(arr[i], i, arr)) {
      return false;
    }
  }
  return true;
};
function allSame(arr, prop) {
  if (arr.length === 0) {
    return true;
  }
  const first = arr[0][prop];
  return arrEvery(arr, function(item) {
    return item[prop] === first;
  });
}
function arrPopRandomElement(arr) {
  return arr.splice(randomPosn(arr), 1)[0];
}
function toQueryString(params) {
  const parts = [];
  if (params) {
    for (const key in params)
      parts.push(encodeURIComponent(key) + "=" + encodeURIComponent(params[key]));
  }
  return parts.length ? "?" + parts.join("&") : "";
}
function parseQueryString(query) {
  let match;
  const search = /([^?&=]+)=?([^&]*)/g;
  const result = {};
  while (match = search.exec(query))
    result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);
  return result;
}
var now = Date.now || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function isErrorInfoOrPartialErrorInfo(err) {
  return typeof err == "object" && err !== null && (err instanceof ErrorInfo || err instanceof PartialErrorInfo);
}
function inspectError(err) {
  var _a2, _b;
  if (err instanceof Error || ((_a2 = err == null ? void 0 : err.constructor) == null ? void 0 : _a2.name) === "ErrorInfo" || ((_b = err == null ? void 0 : err.constructor) == null ? void 0 : _b.name) === "PartialErrorInfo")
    return err.toString();
  return Platform.Config.inspect(err);
}
function inspectBody(body) {
  if (Platform.BufferUtils.isBuffer(body)) {
    return body.toString();
  } else if (typeof body === "string") {
    return body;
  } else {
    return Platform.Config.inspect(body);
  }
}
function dataSizeBytes(data) {
  if (Platform.BufferUtils.isBuffer(data)) {
    return Platform.BufferUtils.byteLength(data);
  }
  if (typeof data === "string") {
    return Platform.Config.stringByteSize(data);
  }
  throw new Error("Expected input of Utils.dataSizeBytes to be a buffer or string, but was: " + typeof data);
}
function cheapRandStr() {
  return String(Math.random()).substr(2);
}
var randomString = (numBytes) => {
  if (Platform.Config.getRandomValues && typeof Uint8Array !== "undefined") {
    const uIntArr = new Uint8Array(numBytes);
    Platform.Config.getRandomValues(uIntArr);
    return Platform.BufferUtils.base64Encode(uIntArr);
  }
  const charset = Platform.BufferUtils.base64CharSet;
  const length = Math.round(numBytes * 4 / 3);
  let result = "";
  for (let i = 0; i < length; i++) {
    result += charset[randomPosn(charset)];
  }
  return result;
};
function arrChooseN(arr, n2) {
  const numItems = Math.min(n2, arr.length), mutableArr = arr.slice(), result = [];
  for (let i = 0; i < numItems; i++) {
    result.push(arrPopRandomElement(mutableArr));
  }
  return result;
}
var trim = String.prototype.trim ? function(str) {
  return str.trim();
} : function(str) {
  return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
};
function promisify(ob, fnName, args) {
  return new Promise(function(resolve, reject) {
    ob[fnName](...args, function(err, res) {
      err ? reject(err) : resolve(res);
    });
  });
}
function decodeBody(body, MsgPack, format) {
  if (format == "msgpack") {
    if (!MsgPack) {
      throwMissingModuleError("MsgPack");
    }
    return MsgPack.decode(body);
  }
  return JSON.parse(String(body));
}
function encodeBody(body, MsgPack, format) {
  if (format == "msgpack") {
    if (!MsgPack) {
      throwMissingModuleError("MsgPack");
    }
    return MsgPack.encode(body, true);
  }
  return JSON.stringify(body);
}
function allToLowerCase(arr) {
  return arr.map(function(element) {
    return element && element.toLowerCase();
  });
}
function allToUpperCase(arr) {
  return arr.map(function(element) {
    return element && element.toUpperCase();
  });
}
function getBackoffCoefficient(count) {
  return Math.min((count + 2) / 3, 2);
}
function getJitterCoefficient() {
  return 1 - Math.random() * 0.2;
}
function getRetryTime(initialTimeout, retryAttempt) {
  return initialTimeout * getBackoffCoefficient(retryAttempt) * getJitterCoefficient();
}
function getGlobalObject() {
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  return self;
}
function shallowEquals(source, target) {
  return Object.keys(source).every((key) => source[key] === target[key]) && Object.keys(target).every((key) => target[key] === source[key]);
}
function matchDerivedChannel(name) {
  const regex = /^(\[([^?]*)(?:(.*))\])?(.+)$/;
  const match = name.match(regex);
  if (!match || !match.length || match.length < 5) {
    throw new ErrorInfo("regex match failed", 400, 40010);
  }
  if (match[2]) {
    throw new ErrorInfo(`cannot use a derived option with a ${match[2]} channel`, 400, 40010);
  }
  return {
    qualifierParam: match[3] || "",
    channelName: match[4]
  };
}
function toBase64(str) {
  const bufferUtils = Platform.BufferUtils;
  const textBuffer = bufferUtils.utf8Encode(str);
  return bufferUtils.base64Encode(textBuffer);
}
function arrEquals(a, b) {
  return a.length === b.length && arrEvery(a, function(val, i) {
    return val === b[i];
  });
}
function throwMissingModuleError(moduleName) {
  throw new ErrorInfo(`${moduleName} module not provided`, 40019, 400);
}

// package.json
var version = "1.2.48";

// src/common/lib/util/defaults.ts
var agent = "ably-js/" + version;
var Defaults = {
  ENVIRONMENT: "",
  REST_HOST: "rest.ably.io",
  REALTIME_HOST: "realtime.ably.io",
  FALLBACK_HOSTS: [
    "A.ably-realtime.com",
    "B.ably-realtime.com",
    "C.ably-realtime.com",
    "D.ably-realtime.com",
    "E.ably-realtime.com"
  ],
  PORT: 80,
  TLS_PORT: 443,
  TIMEOUTS: {
    /* Documented as options params: */
    disconnectedRetryTimeout: 15e3,
    suspendedRetryTimeout: 3e4,
    /* Undocumented, but part of the api and can be used by customers: */
    httpRequestTimeout: 15e3,
    channelRetryTimeout: 15e3,
    fallbackRetryTimeout: 6e5,
    /* For internal / test use only: */
    connectionStateTtl: 12e4,
    realtimeRequestTimeout: 1e4,
    recvTimeout: 9e4,
    preferenceConnectTimeout: 6e3,
    parallelUpgradeDelay: 6e3
  },
  httpMaxRetryCount: 3,
  maxMessageSize: 65536,
  version,
  protocolVersion: 3,
  agent,
  getHost,
  getPort,
  getHttpScheme,
  environmentFallbackHosts,
  getFallbackHosts,
  getHosts,
  checkHost,
  objectifyOptions,
  normaliseOptions,
  defaultGetHeaders,
  defaultPostHeaders
};
function getHost(options, host, ws) {
  if (ws)
    host = host == options.restHost && options.realtimeHost || host || options.realtimeHost;
  else
    host = host || options.restHost;
  return host;
}
function getPort(options, tls) {
  return tls || options.tls ? options.tlsPort : options.port;
}
function getHttpScheme(options) {
  return options.tls ? "https://" : "http://";
}
function environmentFallbackHosts(environment) {
  return [
    environment + "-a-fallback.ably-realtime.com",
    environment + "-b-fallback.ably-realtime.com",
    environment + "-c-fallback.ably-realtime.com",
    environment + "-d-fallback.ably-realtime.com",
    environment + "-e-fallback.ably-realtime.com"
  ];
}
function getFallbackHosts(options) {
  const fallbackHosts = options.fallbackHosts, httpMaxRetryCount = typeof options.httpMaxRetryCount !== "undefined" ? options.httpMaxRetryCount : Defaults.httpMaxRetryCount;
  return fallbackHosts ? arrChooseN(fallbackHosts, httpMaxRetryCount) : [];
}
function getHosts(options) {
  return [options.restHost].concat(getFallbackHosts(options));
}
function checkHost(host) {
  if (typeof host !== "string") {
    throw new ErrorInfo("host must be a string; was a " + typeof host, 4e4, 400);
  }
  if (!host.length) {
    throw new ErrorInfo("host must not be zero-length", 4e4, 400);
  }
}
function getRealtimeHost(options, production, environment) {
  if (options.realtimeHost)
    return options.realtimeHost;
  if (options.restHost) {
    logger_default.logAction(
      logger_default.LOG_MINOR,
      "Defaults.normaliseOptions",
      'restHost is set to "' + options.restHost + '" but realtimeHost is not set, so setting realtimeHost to "' + options.restHost + '" too. If this is not what you want, please set realtimeHost explicitly.'
    );
    return options.restHost;
  }
  return production ? Defaults.REALTIME_HOST : environment + "-" + Defaults.REALTIME_HOST;
}
function getTimeouts(options) {
  const timeouts = {};
  for (const prop in Defaults.TIMEOUTS) {
    timeouts[prop] = options[prop] || Defaults.TIMEOUTS[prop];
  }
  return timeouts;
}
function getAgentString(options) {
  let agentStr = Defaults.agent;
  if (options.agents) {
    for (var agent2 in options.agents) {
      agentStr += " " + agent2 + "/" + options.agents[agent2];
    }
  }
  return agentStr;
}
function objectifyOptions(options) {
  if (typeof options == "string") {
    return options.indexOf(":") == -1 ? { token: options } : { key: options };
  }
  return options;
}
function normaliseOptions(options, MsgPack) {
  var _a2;
  if (typeof options.recover === "function" && options.closeOnUnload === true) {
    logger_default.logAction(
      logger_default.LOG_ERROR,
      "Defaults.normaliseOptions",
      "closeOnUnload was true and a session recovery function was set - these are mutually exclusive, so unsetting the latter"
    );
    options.recover = void 0;
  }
  if (!("closeOnUnload" in options)) {
    options.closeOnUnload = !options.recover;
  }
  if (!("queueMessages" in options))
    options.queueMessages = true;
  const environment = options.environment && String(options.environment).toLowerCase() || Defaults.ENVIRONMENT;
  const production = !environment || environment === "production";
  if (!options.fallbackHosts && !options.restHost && !options.realtimeHost && !options.port && !options.tlsPort) {
    options.fallbackHosts = production ? Defaults.FALLBACK_HOSTS : environmentFallbackHosts(environment);
  }
  const restHost = options.restHost || (production ? Defaults.REST_HOST : environment + "-" + Defaults.REST_HOST);
  const realtimeHost = getRealtimeHost(options, production, environment);
  arrForEach((options.fallbackHosts || []).concat(restHost, realtimeHost), checkHost);
  options.port = options.port || Defaults.PORT;
  options.tlsPort = options.tlsPort || Defaults.TLS_PORT;
  if (!("tls" in options))
    options.tls = true;
  const timeouts = getTimeouts(options);
  if (MsgPack) {
    if ("useBinaryProtocol" in options) {
      options.useBinaryProtocol = Platform.Config.supportsBinary && options.useBinaryProtocol;
    } else {
      options.useBinaryProtocol = Platform.Config.preferBinary;
    }
  } else {
    options.useBinaryProtocol = false;
  }
  const headers = {};
  if (options.clientId) {
    headers["X-Ably-ClientId"] = Platform.BufferUtils.base64Encode(Platform.BufferUtils.utf8Encode(options.clientId));
  }
  if (!("idempotentRestPublishing" in options)) {
    options.idempotentRestPublishing = true;
  }
  let connectivityCheckParams = null;
  let connectivityCheckUrl = options.connectivityCheckUrl;
  if (options.connectivityCheckUrl) {
    let [uri, qs] = options.connectivityCheckUrl.split("?");
    connectivityCheckParams = qs ? parseQueryString(qs) : {};
    if (uri.indexOf("://") === -1) {
      uri = "https://" + uri;
    }
    connectivityCheckUrl = uri;
  }
  return __spreadProps(__spreadValues({}, options), {
    realtimeHost,
    restHost,
    maxMessageSize: ((_a2 = options.internal) == null ? void 0 : _a2.maxMessageSize) || Defaults.maxMessageSize,
    timeouts,
    connectivityCheckParams,
    connectivityCheckUrl,
    headers
  });
}
function normaliseChannelOptions(Crypto2, options) {
  const channelOptions = options || {};
  if (channelOptions.cipher) {
    if (!Crypto2)
      throwMissingModuleError("Crypto");
    const cipher = Crypto2.getCipher(channelOptions.cipher);
    channelOptions.cipher = cipher.cipherParams;
    channelOptions.channelCipher = cipher.cipher;
  } else if ("cipher" in channelOptions) {
    channelOptions.cipher = void 0;
    channelOptions.channelCipher = null;
  }
  return channelOptions;
}
var contentTypes = {
  json: "application/json",
  xml: "application/xml",
  html: "text/html",
  msgpack: "application/x-msgpack"
};
var defaultHeadersOptions = {
  format: "json" /* json */,
  protocolVersion: Defaults.protocolVersion
};
function defaultGetHeaders(options, {
  format = defaultHeadersOptions.format,
  protocolVersion = defaultHeadersOptions.protocolVersion
} = {}) {
  const accept = contentTypes[format];
  return {
    accept,
    "X-Ably-Version": protocolVersion.toString(),
    "Ably-Agent": getAgentString(options)
  };
}
function defaultPostHeaders(options, {
  format = defaultHeadersOptions.format,
  protocolVersion = defaultHeadersOptions.protocolVersion
} = {}) {
  let contentType;
  const accept = contentType = contentTypes[format];
  return {
    accept,
    "content-type": contentType,
    "X-Ably-Version": protocolVersion.toString(),
    "Ably-Agent": getAgentString(options)
  };
}
var defaults_default = Defaults;
function getDefaults(platformDefaults) {
  return Object.assign(Defaults, platformDefaults);
}

// src/common/lib/util/multicaster.ts
var Multicaster = class _Multicaster {
  // Private constructor; use static Multicaster.create instead
  constructor(members) {
    this.members = members || [];
  }
  call(...args) {
    for (const member of this.members) {
      if (member) {
        try {
          member(...args);
        } catch (e) {
          logger_default.logAction(
            logger_default.LOG_ERROR,
            "Multicaster multiple callback handler",
            "Unexpected exception: " + e + "; stack = " + e.stack
          );
        }
      }
    }
  }
  push(...args) {
    this.members.push(...args);
  }
  static create(members) {
    const instance = new _Multicaster(members);
    return Object.assign((...args) => instance.call(...args), {
      push: (fn) => instance.push(fn)
    });
  }
};
var multicaster_default = Multicaster;

// src/common/constants/HttpMethods.ts
var HttpMethods = /* @__PURE__ */ ((HttpMethods2) => {
  HttpMethods2["Get"] = "get";
  HttpMethods2["Delete"] = "delete";
  HttpMethods2["Post"] = "post";
  HttpMethods2["Put"] = "put";
  HttpMethods2["Patch"] = "patch";
  return HttpMethods2;
})(HttpMethods || {});
var HttpMethods_default = HttpMethods;

// src/common/constants/HttpStatusCodes.ts
var HttpStatusCodes = /* @__PURE__ */ ((HttpStatusCodes2) => {
  HttpStatusCodes2[HttpStatusCodes2["Success"] = 200] = "Success";
  HttpStatusCodes2[HttpStatusCodes2["NoContent"] = 204] = "NoContent";
  HttpStatusCodes2[HttpStatusCodes2["BadRequest"] = 400] = "BadRequest";
  HttpStatusCodes2[HttpStatusCodes2["Unauthorized"] = 401] = "Unauthorized";
  HttpStatusCodes2[HttpStatusCodes2["Forbidden"] = 403] = "Forbidden";
  HttpStatusCodes2[HttpStatusCodes2["RequestTimeout"] = 408] = "RequestTimeout";
  HttpStatusCodes2[HttpStatusCodes2["InternalServerError"] = 500] = "InternalServerError";
  return HttpStatusCodes2;
})(HttpStatusCodes || {});
function isSuccessCode(statusCode) {
  return statusCode >= 200 /* Success */ && statusCode < 400 /* BadRequest */;
}
var HttpStatusCodes_default = HttpStatusCodes;

// src/common/lib/client/auth.ts
var MAX_TOKEN_LENGTH = Math.pow(2, 17);
function noop() {
}
function random() {
  return ("000000" + Math.floor(Math.random() * 1e16)).slice(-16);
}
function isRealtime(client) {
  return !!client.connection;
}
function normaliseAuthcallbackError(err) {
  if (!isErrorInfoOrPartialErrorInfo(err)) {
    return new ErrorInfo(inspectError(err), err.code || 40170, err.statusCode || 401);
  }
  if (!err.code) {
    if (err.statusCode === 403) {
      err.code = 40300;
    } else {
      err.code = 40170;
      err.statusCode = 401;
    }
  }
  return err;
}
var hmac = (text, key) => {
  const bufferUtils = Platform.BufferUtils;
  const textBuffer = bufferUtils.utf8Encode(text);
  const keyBuffer = bufferUtils.utf8Encode(key);
  const digest = bufferUtils.hmacSha256(textBuffer, keyBuffer);
  return bufferUtils.base64Encode(digest);
};
function c14n(capability) {
  if (!capability)
    return "";
  if (typeof capability == "string")
    capability = JSON.parse(capability);
  const c14nCapability = /* @__PURE__ */ Object.create(null);
  const keys = keysArray(capability, true);
  if (!keys)
    return "";
  keys.sort();
  for (let i = 0; i < keys.length; i++) {
    c14nCapability[keys[i]] = capability[keys[i]].sort();
  }
  return JSON.stringify(c14nCapability);
}
function logAndValidateTokenAuthMethod(authOptions) {
  if (authOptions.authCallback) {
    logger_default.logAction(logger_default.LOG_MINOR, "Auth()", "using token auth with authCallback");
  } else if (authOptions.authUrl) {
    logger_default.logAction(logger_default.LOG_MINOR, "Auth()", "using token auth with authUrl");
  } else if (authOptions.key) {
    logger_default.logAction(logger_default.LOG_MINOR, "Auth()", "using token auth with client-side signing");
  } else if (authOptions.tokenDetails) {
    logger_default.logAction(logger_default.LOG_MINOR, "Auth()", "using token auth with supplied token only");
  } else {
    const msg = "authOptions must include valid authentication parameters";
    logger_default.logAction(logger_default.LOG_ERROR, "Auth()", msg);
    throw new Error(msg);
  }
}
function basicAuthForced(options) {
  return "useTokenAuth" in options && !options.useTokenAuth;
}
function useTokenAuth(options) {
  return options.useTokenAuth || !basicAuthForced(options) && (options.authCallback || options.authUrl || options.token || options.tokenDetails);
}
function noWayToRenew(options) {
  return !options.key && !options.authCallback && !options.authUrl;
}
var trId = 0;
function getTokenRequestId() {
  return trId++;
}
var Auth = class {
  constructor(client, options) {
    // This initialization is always overwritten and only used to prevent a TypeScript compiler error
    this.authOptions = {};
    this.client = client;
    this.tokenParams = options.defaultTokenParams || {};
    this.currentTokenRequestId = null;
    this.waitingForTokenRequest = null;
    if (useTokenAuth(options)) {
      if (noWayToRenew(options)) {
        logger_default.logAction(
          logger_default.LOG_ERROR,
          "Auth()",
          "Warning: library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help"
        );
      }
      this._saveTokenOptions(options.defaultTokenParams, options);
      logAndValidateTokenAuthMethod(this.authOptions);
    } else {
      if (!options.key) {
        const msg = "No authentication options provided; need one of: key, authUrl, or authCallback (or for testing only, token or tokenDetails)";
        logger_default.logAction(logger_default.LOG_ERROR, "Auth()", msg);
        throw new ErrorInfo(msg, 40160, 401);
      }
      logger_default.logAction(logger_default.LOG_MINOR, "Auth()", "anonymous, using basic auth");
      this._saveBasicOptions(options);
    }
  }
  authorize(tokenParams, authOptions, callback) {
    let _authOptions;
    if (typeof tokenParams == "function" && !callback) {
      callback = tokenParams;
      _authOptions = tokenParams = null;
    } else if (typeof authOptions == "function" && !callback) {
      callback = authOptions;
      _authOptions = null;
    } else {
      _authOptions = authOptions;
    }
    if (!callback) {
      return promisify(this, "authorize", arguments);
    }
    if (_authOptions && _authOptions.key && this.authOptions.key !== _authOptions.key) {
      throw new ErrorInfo("Unable to update auth options with incompatible key", 40102, 401);
    }
    this._forceNewToken(
      tokenParams,
      _authOptions,
      (err, tokenDetails) => {
        if (err) {
          if (this.client.connection && err.statusCode === HttpStatusCodes_default.Forbidden) {
            this.client.connection.connectionManager.actOnErrorFromAuthorize(err);
          }
          callback == null ? void 0 : callback(err);
          return;
        }
        if (isRealtime(this.client)) {
          this.client.connection.connectionManager.onAuthUpdated(tokenDetails, callback || noop);
        } else {
          callback == null ? void 0 : callback(null, tokenDetails);
        }
      }
    );
  }
  /* For internal use, eg by connectionManager - useful when want to call back
   * as soon as we have the new token, rather than waiting for it to take
   * effect on the connection as #authorize does */
  _forceNewToken(tokenParams, authOptions, callback) {
    this.tokenDetails = null;
    this._saveTokenOptions(tokenParams, authOptions);
    logAndValidateTokenAuthMethod(this.authOptions);
    this._ensureValidAuthCredentials(true, (err, tokenDetails) => {
      delete this.tokenParams.timestamp;
      delete this.authOptions.queryTime;
      callback(err, tokenDetails);
    });
  }
  requestToken(tokenParams, authOptions, callback) {
    if (typeof tokenParams == "function" && !callback) {
      callback = tokenParams;
      authOptions = tokenParams = null;
    } else if (typeof authOptions == "function" && !callback) {
      callback = authOptions;
      authOptions = null;
    }
    if (!callback) {
      return promisify(this, "requestToken", arguments);
    }
    authOptions = authOptions || this.authOptions;
    tokenParams = tokenParams || copy(this.tokenParams);
    const _callback = callback || noop;
    let tokenRequestCallback, client = this.client;
    if (authOptions.authCallback) {
      logger_default.logAction(logger_default.LOG_MINOR, "Auth.requestToken()", "using token auth with authCallback");
      tokenRequestCallback = authOptions.authCallback;
    } else if (authOptions.authUrl) {
      logger_default.logAction(logger_default.LOG_MINOR, "Auth.requestToken()", "using token auth with authUrl");
      tokenRequestCallback = (params, cb) => {
        const authHeaders = mixin({ accept: "application/json, text/plain" }, authOptions.authHeaders);
        const usePost = authOptions.authMethod && authOptions.authMethod.toLowerCase() === "post";
        let providedQsParams;
        const queryIdx = authOptions.authUrl.indexOf("?");
        if (queryIdx > -1) {
          providedQsParams = parseQueryString(authOptions.authUrl.slice(queryIdx));
          authOptions.authUrl = authOptions.authUrl.slice(0, queryIdx);
          if (!usePost) {
            authOptions.authParams = mixin(providedQsParams, authOptions.authParams);
          }
        }
        const authParams = mixin({}, authOptions.authParams || {}, params);
        const authUrlRequestCallback = function(err, body, headers, unpacked) {
          let contentType;
          if (err) {
            logger_default.logAction(
              logger_default.LOG_MICRO,
              "Auth.requestToken().tokenRequestCallback",
              "Received Error: " + inspectError(err)
            );
          } else {
            contentType = headers["content-type"];
            logger_default.logAction(
              logger_default.LOG_MICRO,
              "Auth.requestToken().tokenRequestCallback",
              "Received; content-type: " + contentType + "; body: " + inspectBody(body)
            );
          }
          if (err || unpacked)
            return cb(err, body);
          if (Platform.BufferUtils.isBuffer(body))
            body = body.toString();
          if (!contentType) {
            cb(new ErrorInfo("authUrl response is missing a content-type header", 40170, 401));
            return;
          }
          const json = contentType.indexOf("application/json") > -1, text = contentType.indexOf("text/plain") > -1 || contentType.indexOf("application/jwt") > -1;
          if (!json && !text) {
            cb(
              new ErrorInfo(
                "authUrl responded with unacceptable content-type " + contentType + ", should be either text/plain, application/jwt or application/json",
                40170,
                401
              )
            );
            return;
          }
          if (json) {
            if (body.length > MAX_TOKEN_LENGTH) {
              cb(new ErrorInfo("authUrl response exceeded max permitted length", 40170, 401));
              return;
            }
            try {
              body = JSON.parse(body);
            } catch (e) {
              cb(
                new ErrorInfo("Unexpected error processing authURL response; err = " + e.message, 40170, 401)
              );
              return;
            }
          }
          cb(null, body, contentType);
        };
        logger_default.logAction(
          logger_default.LOG_MICRO,
          "Auth.requestToken().tokenRequestCallback",
          "Requesting token from " + authOptions.authUrl + "; Params: " + JSON.stringify(authParams) + "; method: " + (usePost ? "POST" : "GET")
        );
        if (usePost) {
          const headers = authHeaders || {};
          headers["content-type"] = "application/x-www-form-urlencoded";
          const body = toQueryString(authParams).slice(1);
          this.client.http.doUri(
            HttpMethods_default.Post,
            authOptions.authUrl,
            headers,
            body,
            providedQsParams,
            authUrlRequestCallback
          );
        } else {
          this.client.http.doUri(
            HttpMethods_default.Get,
            authOptions.authUrl,
            authHeaders || {},
            null,
            authParams,
            authUrlRequestCallback
          );
        }
      };
    } else if (authOptions.key) {
      logger_default.logAction(logger_default.LOG_MINOR, "Auth.requestToken()", "using token auth with client-side signing");
      tokenRequestCallback = (params, cb) => {
        this.createTokenRequest(params, authOptions, cb);
      };
    } else {
      const msg = "Need a new token, but authOptions does not include any way to request one (no authUrl, authCallback, or key)";
      logger_default.logAction(
        logger_default.LOG_ERROR,
        "Auth()",
        "library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help"
      );
      _callback(new ErrorInfo(msg, 40171, 403));
      return;
    }
    if ("capability" in tokenParams)
      tokenParams.capability = c14n(tokenParams.capability);
    const tokenRequest = (signedTokenParams, tokenCb) => {
      const keyName = signedTokenParams.keyName, path = "/keys/" + keyName + "/requestToken", tokenUri = function(host) {
        return client.baseUri(host) + path;
      };
      const requestHeaders = defaults_default.defaultPostHeaders(this.client.options);
      if (authOptions.requestHeaders)
        mixin(requestHeaders, authOptions.requestHeaders);
      logger_default.logAction(
        logger_default.LOG_MICRO,
        "Auth.requestToken().requestToken",
        "Sending POST to " + path + "; Token params: " + JSON.stringify(signedTokenParams)
      );
      this.client.http.do(
        HttpMethods_default.Post,
        tokenUri,
        requestHeaders,
        JSON.stringify(signedTokenParams),
        null,
        tokenCb
      );
    };
    let tokenRequestCallbackTimeoutExpired = false, timeoutLength = this.client.options.timeouts.realtimeRequestTimeout, tokenRequestCallbackTimeout = setTimeout(function() {
      tokenRequestCallbackTimeoutExpired = true;
      const msg = "Token request callback timed out after " + timeoutLength / 1e3 + " seconds";
      logger_default.logAction(logger_default.LOG_ERROR, "Auth.requestToken()", msg);
      _callback(new ErrorInfo(msg, 40170, 401));
    }, timeoutLength);
    tokenRequestCallback(tokenParams, function(err, tokenRequestOrDetails, contentType) {
      if (tokenRequestCallbackTimeoutExpired)
        return;
      clearTimeout(tokenRequestCallbackTimeout);
      if (err) {
        logger_default.logAction(
          logger_default.LOG_ERROR,
          "Auth.requestToken()",
          "token request signing call returned error; err = " + inspectError(err)
        );
        _callback(normaliseAuthcallbackError(err));
        return;
      }
      if (typeof tokenRequestOrDetails === "string") {
        if (tokenRequestOrDetails.length === 0) {
          _callback(new ErrorInfo("Token string is empty", 40170, 401));
        } else if (tokenRequestOrDetails.length > MAX_TOKEN_LENGTH) {
          _callback(
            new ErrorInfo(
              "Token string exceeded max permitted length (was " + tokenRequestOrDetails.length + " bytes)",
              40170,
              401
            )
          );
        } else if (tokenRequestOrDetails === "undefined" || tokenRequestOrDetails === "null") {
          _callback(new ErrorInfo("Token string was literal null/undefined", 40170, 401));
        } else if (tokenRequestOrDetails[0] === "{" && !(contentType && contentType.indexOf("application/jwt") > -1)) {
          _callback(
            new ErrorInfo(
              "Token was double-encoded; make sure you're not JSON-encoding an already encoded token request or details",
              40170,
              401
            )
          );
        } else {
          _callback(null, { token: tokenRequestOrDetails });
        }
        return;
      }
      if (typeof tokenRequestOrDetails !== "object") {
        const msg = "Expected token request callback to call back with a token string or token request/details object, but got a " + typeof tokenRequestOrDetails;
        logger_default.logAction(logger_default.LOG_ERROR, "Auth.requestToken()", msg);
        _callback(new ErrorInfo(msg, 40170, 401));
        return;
      }
      const objectSize = JSON.stringify(tokenRequestOrDetails).length;
      if (objectSize > MAX_TOKEN_LENGTH && !authOptions.suppressMaxLengthCheck) {
        _callback(
          new ErrorInfo(
            "Token request/details object exceeded max permitted stringified size (was " + objectSize + " bytes)",
            40170,
            401
          )
        );
        return;
      }
      if ("issued" in tokenRequestOrDetails) {
        _callback(null, tokenRequestOrDetails);
        return;
      }
      if (!("keyName" in tokenRequestOrDetails)) {
        const msg = "Expected token request callback to call back with a token string, token request object, or token details object";
        logger_default.logAction(logger_default.LOG_ERROR, "Auth.requestToken()", msg);
        _callback(new ErrorInfo(msg, 40170, 401));
        return;
      }
      tokenRequest(
        tokenRequestOrDetails,
        function(err2, tokenResponse, headers, unpacked) {
          if (err2) {
            logger_default.logAction(
              logger_default.LOG_ERROR,
              "Auth.requestToken()",
              "token request API call returned error; err = " + inspectError(err2)
            );
            _callback(normaliseAuthcallbackError(err2));
            return;
          }
          if (!unpacked)
            tokenResponse = JSON.parse(tokenResponse);
          logger_default.logAction(logger_default.LOG_MINOR, "Auth.getToken()", "token received");
          _callback(null, tokenResponse);
        }
      );
    });
  }
  /**
   * Create and sign a token request based on the given options.
   * NOTE this can only be used when the key value is available locally.
   * Otherwise, signed token requests must be obtained from the key
   * owner (either using the token request callback or url).
   *
   * @param authOptions
   * an object containing the request options:
   * - key:           the key to use. If not specified, a key passed in constructing
   *                  the Rest interface will be used
   *
   * - queryTime      (optional) boolean indicating that the ably system should be
   *                  queried for the current time when none is specified explicitly
   *
   * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the
   *                  requestToken request
   *
   * @param tokenParams
   * an object containing the parameters for the requested token:
   * - ttl:       (optional) the requested life of the token in ms. If none is specified
   *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request
   *                  exceeding that lifetime will be rejected with an error.
   *
   * - capability:    (optional) the capability to associate with the access token.
   *                  If none is specified, a token will be requested with all of the
   *                  capabilities of the specified key.
   *
   * - clientId:      (optional) a client ID to associate with the token; if not
   *                  specified, a clientId passed in constructing the Rest interface will be used
   *
   * - timestamp:     (optional) the time in ms since the epoch. If none is specified,
   *                  the system will be queried for a time value to use.
   *
   * @param callback
   */
  createTokenRequest(tokenParams, authOptions, callback) {
    if (typeof tokenParams == "function" && !callback) {
      callback = tokenParams;
      authOptions = tokenParams = null;
    } else if (typeof authOptions == "function" && !callback) {
      callback = authOptions;
      authOptions = null;
    }
    if (!callback) {
      return promisify(this, "createTokenRequest", arguments);
    }
    authOptions = authOptions || this.authOptions;
    tokenParams = tokenParams || copy(this.tokenParams);
    const key = authOptions.key;
    if (!key) {
      callback(new ErrorInfo("No key specified", 40101, 403));
      return;
    }
    const keyParts = key.split(":"), keyName = keyParts[0], keySecret = keyParts[1];
    if (!keySecret) {
      callback(new ErrorInfo("Invalid key specified", 40101, 403));
      return;
    }
    if (tokenParams.clientId === "") {
      callback(new ErrorInfo("clientId can\u2019t be an empty string", 40012, 400));
      return;
    }
    if ("capability" in tokenParams) {
      tokenParams.capability = c14n(tokenParams.capability);
    }
    const request = mixin({ keyName }, tokenParams), clientId = tokenParams.clientId || "", ttl = tokenParams.ttl || "", capability = tokenParams.capability || "";
    ((authoriseCb) => {
      if (request.timestamp) {
        authoriseCb();
        return;
      }
      this.getTimestamp(authOptions && authOptions.queryTime, function(err, time) {
        if (err) {
          callback(err);
          return;
        }
        request.timestamp = time;
        authoriseCb();
      });
    })(function() {
      const nonce = request.nonce || (request.nonce = random()), timestamp = request.timestamp;
      const signText = request.keyName + "\n" + ttl + "\n" + capability + "\n" + clientId + "\n" + timestamp + "\n" + nonce + "\n";
      request.mac = request.mac || hmac(signText, keySecret);
      logger_default.logAction(logger_default.LOG_MINOR, "Auth.getTokenRequest()", "generated signed request");
      callback(null, request);
    });
  }
  /**
   * Get the auth query params to use for a websocket connection,
   * based on the current auth parameters
   */
  getAuthParams(callback) {
    if (this.method == "basic")
      callback(null, { key: this.key });
    else
      this._ensureValidAuthCredentials(false, function(err, tokenDetails) {
        if (err) {
          callback(err);
          return;
        }
        if (!tokenDetails) {
          throw new Error("Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails");
        }
        callback(null, { access_token: tokenDetails.token });
      });
  }
  /**
   * Get the authorization header to use for a REST or comet request,
   * based on the current auth parameters
   */
  getAuthHeaders(callback) {
    if (this.method == "basic") {
      callback(null, { authorization: "Basic " + this.basicKey });
    } else {
      this._ensureValidAuthCredentials(false, function(err, tokenDetails) {
        if (err) {
          callback(err);
          return;
        }
        if (!tokenDetails) {
          throw new Error("Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails");
        }
        callback(null, { authorization: "Bearer " + toBase64(tokenDetails.token) });
      });
    }
  }
  /**
   * Get the current time based on the local clock,
   * or if the option queryTime is true, return the server time.
   * The server time offset from the local time is stored so that
   * only one request to the server to get the time is ever needed
   */
  getTimestamp(queryTime, callback) {
    if (!this.isTimeOffsetSet() && (queryTime || this.authOptions.queryTime)) {
      this.client.time(callback);
    } else {
      callback(null, this.getTimestampUsingOffset());
    }
  }
  getTimestampUsingOffset() {
    return now() + (this.client.serverTimeOffset || 0);
  }
  isTimeOffsetSet() {
    return this.client.serverTimeOffset !== null;
  }
  _saveBasicOptions(authOptions) {
    this.method = "basic";
    this.key = authOptions.key;
    this.basicKey = toBase64(authOptions.key);
    this.authOptions = authOptions || {};
    if ("clientId" in authOptions) {
      this._userSetClientId(authOptions.clientId);
    }
  }
  _saveTokenOptions(tokenParams, authOptions) {
    this.method = "token";
    if (tokenParams) {
      this.tokenParams = tokenParams;
    }
    if (authOptions) {
      if (authOptions.token) {
        authOptions.tokenDetails = typeof authOptions.token === "string" ? { token: authOptions.token } : authOptions.token;
      }
      if (authOptions.tokenDetails) {
        this.tokenDetails = authOptions.tokenDetails;
      }
      if ("clientId" in authOptions) {
        this._userSetClientId(authOptions.clientId);
      }
      this.authOptions = authOptions;
    }
  }
  /* @param forceSupersede: force a new token request even if there's one in
   * progress, making all pending callbacks wait for the new one */
  _ensureValidAuthCredentials(forceSupersede, callback) {
    const token = this.tokenDetails;
    if (token) {
      if (this._tokenClientIdMismatch(token.clientId)) {
        callback(
          new ErrorInfo(
            "Mismatch between clientId in token (" + token.clientId + ") and current clientId (" + this.clientId + ")",
            40102,
            403
          )
        );
        return;
      }
      if (!this.isTimeOffsetSet() || !token.expires || token.expires >= this.getTimestampUsingOffset()) {
        logger_default.logAction(logger_default.LOG_MINOR, "Auth.getToken()", "using cached token; expires = " + token.expires);
        callback(null, token);
        return;
      }
      logger_default.logAction(logger_default.LOG_MINOR, "Auth.getToken()", "deleting expired token");
      this.tokenDetails = null;
    }
    (this.waitingForTokenRequest || (this.waitingForTokenRequest = multicaster_default.create())).push(callback);
    if (this.currentTokenRequestId !== null && !forceSupersede) {
      return;
    }
    const tokenRequestId = this.currentTokenRequestId = getTokenRequestId();
    this.requestToken(this.tokenParams, this.authOptions, (err, tokenResponse) => {
      if (this.currentTokenRequestId > tokenRequestId) {
        logger_default.logAction(
          logger_default.LOG_MINOR,
          "Auth._ensureValidAuthCredentials()",
          "Discarding token request response; overtaken by newer one"
        );
        return;
      }
      this.currentTokenRequestId = null;
      const callbacks = this.waitingForTokenRequest || noop;
      this.waitingForTokenRequest = null;
      if (err) {
        callbacks(err);
        return;
      }
      callbacks(null, this.tokenDetails = tokenResponse);
    });
  }
  /* User-set: check types, '*' is disallowed, throw any errors */
  _userSetClientId(clientId) {
    if (!(typeof clientId === "string" || clientId === null)) {
      throw new ErrorInfo("clientId must be either a string or null", 40012, 400);
    } else if (clientId === "*") {
      throw new ErrorInfo(
        'Can\u2019t use "*" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, instantiate the library with {defaultTokenParams: {clientId: "*"}}), or if calling authorize(), pass it in as a tokenParam: authorize({clientId: "*"}, authOptions)',
        40012,
        400
      );
    } else {
      const err = this._uncheckedSetClientId(clientId);
      if (err)
        throw err;
    }
  }
  /* Ably-set: no typechecking, '*' is allowed but not set on this.clientId), return errors to the caller */
  _uncheckedSetClientId(clientId) {
    if (this._tokenClientIdMismatch(clientId)) {
      const msg = "Unexpected clientId mismatch: client has " + this.clientId + ", requested " + clientId;
      const err = new ErrorInfo(msg, 40102, 401);
      logger_default.logAction(logger_default.LOG_ERROR, "Auth._uncheckedSetClientId()", msg);
      return err;
    } else {
      this.clientId = this.tokenParams.clientId = clientId;
      return null;
    }
  }
  _tokenClientIdMismatch(tokenClientId) {
    return !!(this.clientId && this.clientId !== "*" && tokenClientId && tokenClientId !== "*" && this.clientId !== tokenClientId);
  }
  static isTokenErr(error) {
    return error.code && error.code >= 40140 && error.code < 40150;
  }
  revokeTokens(specifiers, options) {
    return this.client.rest.revokeTokens(specifiers, options);
  }
};
var auth_default = Auth;

// src/common/lib/client/baseclient.ts
var BaseClient = class {
  constructor(options, modules) {
    var _a2, _b, _c;
    this._additionalHTTPRequestImplementations = modules;
    if (!options) {
      const msg = "no options provided";
      logger_default.logAction(logger_default.LOG_ERROR, "BaseClient()", msg);
      throw new Error(msg);
    }
    const optionsObj = defaults_default.objectifyOptions(options);
    logger_default.setLog(optionsObj.logLevel, optionsObj.logHandler);
    logger_default.logAction(
      logger_default.LOG_MICRO,
      "BaseClient()",
      "initialized with clientOptions " + Platform.Config.inspect(options)
    );
    this._MsgPack = (_a2 = modules.MsgPack) != null ? _a2 : null;
    const normalOptions = this.options = defaults_default.normaliseOptions(optionsObj, this._MsgPack);
    if (normalOptions.key) {
      const keyMatch = normalOptions.key.match(/^([^:\s]+):([^:.\s]+)$/);
      if (!keyMatch) {
        const msg = "invalid key parameter";
        logger_default.logAction(logger_default.LOG_ERROR, "BaseClient()", msg);
        throw new ErrorInfo(msg, 40400, 404);
      }
      normalOptions.keyName = keyMatch[1];
      normalOptions.keySecret = keyMatch[2];
    }
    if ("clientId" in normalOptions) {
      if (!(typeof normalOptions.clientId === "string" || normalOptions.clientId === null))
        throw new ErrorInfo("clientId must be either a string or null", 40012, 400);
      else if (normalOptions.clientId === "*")
        throw new ErrorInfo(
          'Can\u2019t use "*" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, use {defaultTokenParams: {clientId: "*"}})',
          40012,
          400
        );
    }
    logger_default.logAction(logger_default.LOG_MINOR, "BaseClient()", "started; version = " + defaults_default.version);
    this._currentFallback = null;
    this.serverTimeOffset = null;
    this.http = new Platform.Http(this);
    this.auth = new auth_default(this, normalOptions);
    this._rest = modules.Rest ? new modules.Rest(this) : null;
    this._Crypto = (_b = modules.Crypto) != null ? _b : null;
    this.__FilteredSubscriptions = (_c = modules.MessageInteractions) != null ? _c : null;
  }
  get rest() {
    if (!this._rest) {
      throwMissingModuleError("Rest");
    }
    return this._rest;
  }
  get _FilteredSubscriptions() {
    if (!this.__FilteredSubscriptions) {
      throwMissingModuleError("MessageInteractions");
    }
    return this.__FilteredSubscriptions;
  }
  get channels() {
    return this.rest.channels;
  }
  get push() {
    return this.rest.push;
  }
  baseUri(host) {
    return defaults_default.getHttpScheme(this.options) + host + ":" + defaults_default.getPort(this.options, false);
  }
  stats(params, callback) {
    return this.rest.stats(params, callback);
  }
  time(params, callback) {
    return this.rest.time(params, callback);
  }
  request(method, path, version2, params, body, customHeaders, callback) {
    return this.rest.request(method, path, version2, params, body, customHeaders, callback);
  }
  batchPublish(specOrSpecs) {
    return this.rest.batchPublish(specOrSpecs);
  }
  batchPresence(channels) {
    return this.rest.batchPresence(channels);
  }
  setLog(logOptions) {
    logger_default.setLog(logOptions.level, logOptions.handler);
  }
};
BaseClient.Platform = Platform;
var baseclient_default = BaseClient;

// src/common/lib/types/devicedetails.ts
var DeviceDetails = class _DeviceDetails {
  toJSON() {
    var _a2, _b, _c;
    return {
      id: this.id,
      deviceSecret: this.deviceSecret,
      platform: this.platform,
      formFactor: this.formFactor,
      clientId: this.clientId,
      metadata: this.metadata,
      deviceIdentityToken: this.deviceIdentityToken,
      push: {
        recipient: (_a2 = this.push) == null ? void 0 : _a2.recipient,
        state: (_b = this.push) == null ? void 0 : _b.state,
        error: (_c = this.push) == null ? void 0 : _c.error
      }
    };
  }
  toString() {
    var _a2, _b, _c, _d;
    let result = "[DeviceDetails";
    if (this.id)
      result += "; id=" + this.id;
    if (this.platform)
      result += "; platform=" + this.platform;
    if (this.formFactor)
      result += "; formFactor=" + this.formFactor;
    if (this.clientId)
      result += "; clientId=" + this.clientId;
    if (this.metadata)
      result += "; metadata=" + this.metadata;
    if (this.deviceIdentityToken)
      result += "; deviceIdentityToken=" + JSON.stringify(this.deviceIdentityToken);
    if ((_a2 = this.push) == null ? void 0 : _a2.recipient)
      result += "; push.recipient=" + JSON.stringify(this.push.recipient);
    if ((_b = this.push) == null ? void 0 : _b.state)
      result += "; push.state=" + this.push.state;
    if ((_c = this.push) == null ? void 0 : _c.error)
      result += "; push.error=" + JSON.stringify(this.push.error);
    if ((_d = this.push) == null ? void 0 : _d.metadata)
      result += "; push.metadata=" + this.push.metadata;
    result += "]";
    return result;
  }
  static toRequestBody(body, MsgPack, format) {
    return encodeBody(body, MsgPack, format);
  }
  static fromResponseBody(body, MsgPack, format) {
    if (format) {
      body = decodeBody(body, MsgPack, format);
    }
    if (isArray(body)) {
      return _DeviceDetails.fromValuesArray(body);
    } else {
      return _DeviceDetails.fromValues(body);
    }
  }
  static fromValues(values) {
    values.error = values.error && ErrorInfo.fromValues(values.error);
    return Object.assign(new _DeviceDetails(), values);
  }
  static fromValuesArray(values) {
    const count = values.length, result = new Array(count);
    for (let i = 0; i < count; i++)
      result[i] = _DeviceDetails.fromValues(values[i]);
    return result;
  }
};
var devicedetails_default = DeviceDetails;

// src/common/lib/client/resource.ts
function withAuthDetails(client, headers, params, errCallback, opCallback) {
  if (client.http.supportsAuthHeaders) {
    client.auth.getAuthHeaders(function(err, authHeaders) {
      if (err)
        errCallback(err);
      else
        opCallback(mixin(authHeaders, headers), params);
    });
  } else {
    client.auth.getAuthParams(function(err, authParams) {
      if (err)
        errCallback(err);
      else
        opCallback(headers, mixin(authParams, params));
    });
  }
}
function unenvelope(callback, MsgPack, format) {
  return (err, body, outerHeaders, unpacked, outerStatusCode) => {
    if (err && !body) {
      callback(err);
      return;
    }
    if (!unpacked) {
      try {
        body = decodeBody(body, MsgPack, format);
      } catch (e) {
        if (isErrorInfoOrPartialErrorInfo(e)) {
          callback(e);
        } else {
          callback(new PartialErrorInfo(inspectError(e), null));
        }
        return;
      }
    }
    if (!body) {
      callback(new PartialErrorInfo("unenvelope(): Response body is missing", null));
      return;
    }
    const { statusCode: wrappedStatusCode, response, headers: wrappedHeaders } = body;
    if (wrappedStatusCode === void 0) {
      callback(err, body, outerHeaders, true, outerStatusCode);
      return;
    }
    if (wrappedStatusCode < 200 || wrappedStatusCode >= 300) {
      let wrappedErr = response && response.error || err;
      if (!wrappedErr) {
        wrappedErr = new Error("Error in unenveloping " + body);
        wrappedErr.statusCode = wrappedStatusCode;
      }
      callback(wrappedErr, response, wrappedHeaders, true, wrappedStatusCode);
      return;
    }
    callback(err, response, wrappedHeaders, true, wrappedStatusCode);
  };
}
function paramString(params) {
  const paramPairs = [];
  if (params) {
    for (const needle in params) {
      paramPairs.push(needle + "=" + params[needle]);
    }
  }
  return paramPairs.join("&");
}
function urlFromPathAndParams(path, params) {
  return path + (params ? "?" : "") + paramString(params);
}
function logResponseHandler(callback, method, path, params) {
  return (err, body, headers, unpacked, statusCode) => {
    if (err) {
      logger_default.logAction(
        logger_default.LOG_MICRO,
        "Resource." + method + "()",
        "Received Error; " + urlFromPathAndParams(path, params) + "; Error: " + inspectError(err)
      );
    } else {
      logger_default.logAction(
        logger_default.LOG_MICRO,
        "Resource." + method + "()",
        "Received; " + urlFromPathAndParams(path, params) + "; Headers: " + paramString(headers) + "; StatusCode: " + statusCode + "; Body: " + (Platform.BufferUtils.isBuffer(body) ? body.toString() : body)
      );
    }
    if (callback) {
      callback(err, body, headers, unpacked, statusCode);
    }
  };
}
var Resource = class _Resource {
  static get(client, path, headers, params, envelope, callback) {
    _Resource.do(HttpMethods_default.Get, client, path, null, headers, params, envelope, callback);
  }
  static delete(client, path, headers, params, envelope, callback) {
    _Resource.do(HttpMethods_default.Delete, client, path, null, headers, params, envelope, callback);
  }
  static post(client, path, body, headers, params, envelope, callback) {
    _Resource.do(HttpMethods_default.Post, client, path, body, headers, params, envelope, callback);
  }
  static patch(client, path, body, headers, params, envelope, callback) {
    _Resource.do(HttpMethods_default.Patch, client, path, body, headers, params, envelope, callback);
  }
  static put(client, path, body, headers, params, envelope, callback) {
    _Resource.do(HttpMethods_default.Put, client, path, body, headers, params, envelope, callback);
  }
  static do(method, client, path, body, headers, params, envelope, callback) {
    if (logger_default.shouldLog(logger_default.LOG_MICRO)) {
      callback = logResponseHandler(callback, method, path, params);
    }
    if (envelope) {
      callback = callback && unenvelope(callback, client._MsgPack, envelope);
      (params = params || {})["envelope"] = envelope;
    }
    function doRequest(headers2, params2) {
      var _a2;
      if (logger_default.shouldLog(logger_default.LOG_MICRO)) {
        logger_default.logAction(
          logger_default.LOG_MICRO,
          "Resource." + method + "()",
          "Sending; " + urlFromPathAndParams(path, params2)
        );
      }
      if (logger_default.shouldLog(logger_default.LOG_MICRO)) {
        let decodedBody = body;
        if (((_a2 = headers2["content-type"]) == null ? void 0 : _a2.indexOf("msgpack")) > 0) {
          try {
            if (!client._MsgPack) {
              throwMissingModuleError("MsgPack");
            }
            decodedBody = client._MsgPack.decode(body);
          } catch (decodeErr) {
            logger_default.logAction(
              logger_default.LOG_MICRO,
              "Resource." + method + "()",
              "Sending MsgPack Decoding Error: " + inspectError(decodeErr)
            );
          }
        }
        logger_default.logAction(
          logger_default.LOG_MICRO,
          "Resource." + method + "()",
          "Sending; " + urlFromPathAndParams(path, params2) + "; Body: " + decodedBody
        );
      }
      client.http.do(method, path, headers2, body, params2, function(err, res, resHeaders, unpacked, statusCode) {
        if (err && auth_default.isTokenErr(err)) {
          client.auth.authorize(null, null, function(err2) {
            if (err2) {
              callback(err2);
              return;
            }
            withAuthDetails(client, headers2, params2, callback, doRequest);
          });
          return;
        }
        callback(err, res, resHeaders, unpacked, statusCode);
      });
    }
    withAuthDetails(client, headers, params, callback, doRequest);
  }
};
var resource_default = Resource;

// src/common/lib/client/paginatedresource.ts
function getRelParams(linkUrl) {
  const urlMatch = linkUrl.match(/^\.\/(\w+)\?(.*)$/);
  return urlMatch && urlMatch[2] && parseQueryString(urlMatch[2]);
}
function parseRelLinks(linkHeader) {
  if (typeof linkHeader == "string")
    linkHeader = linkHeader.split(",");
  const relParams = {};
  for (let i = 0; i < linkHeader.length; i++) {
    const linkMatch = linkHeader[i].match(/^\s*<(.+)>;\s*rel="(\w+)"$/);
    if (linkMatch) {
      const params = getRelParams(linkMatch[1]);
      if (params)
        relParams[linkMatch[2]] = params;
    }
  }
  return relParams;
}
function returnErrOnly(err, body, useHPR) {
  return !(useHPR && (body || typeof err.code === "number"));
}
var PaginatedResource = class {
  constructor(client, path, headers, envelope, bodyHandler, useHttpPaginatedResponse) {
    this.client = client;
    this.path = path;
    this.headers = headers;
    this.envelope = envelope != null ? envelope : null;
    this.bodyHandler = bodyHandler;
    this.useHttpPaginatedResponse = useHttpPaginatedResponse || false;
  }
  get(params, callback) {
    resource_default.get(
      this.client,
      this.path,
      this.headers,
      params,
      this.envelope,
      (err, body, headers, unpacked, statusCode) => {
        this.handlePage(err, body, headers, unpacked, statusCode, callback);
      }
    );
  }
  delete(params, callback) {
    resource_default.delete(
      this.client,
      this.path,
      this.headers,
      params,
      this.envelope,
      (err, body, headers, unpacked, statusCode) => {
        this.handlePage(err, body, headers, unpacked, statusCode, callback);
      }
    );
  }
  post(params, body, callback) {
    resource_default.post(
      this.client,
      this.path,
      body,
      this.headers,
      params,
      this.envelope,
      (err, responseBody, headers, unpacked, statusCode) => {
        if (callback) {
          this.handlePage(err, responseBody, headers, unpacked, statusCode, callback);
        }
      }
    );
  }
  put(params, body, callback) {
    resource_default.put(
      this.client,
      this.path,
      body,
      this.headers,
      params,
      this.envelope,
      (err, responseBody, headers, unpacked, statusCode) => {
        if (callback) {
          this.handlePage(err, responseBody, headers, unpacked, statusCode, callback);
        }
      }
    );
  }
  patch(params, body, callback) {
    resource_default.patch(
      this.client,
      this.path,
      body,
      this.headers,
      params,
      this.envelope,
      (err, responseBody, headers, unpacked, statusCode) => {
        if (callback) {
          this.handlePage(err, responseBody, headers, unpacked, statusCode, callback);
        }
      }
    );
  }
  handlePage(err, body, headers, unpacked, statusCode, callback) {
    if (err && returnErrOnly(err, body, this.useHttpPaginatedResponse)) {
      logger_default.logAction(
        logger_default.LOG_ERROR,
        "PaginatedResource.handlePage()",
        "Unexpected error getting resource: err = " + inspectError(err)
      );
      callback == null ? void 0 : callback(err);
      return;
    }
    const handleBody = () => __async(this, null, function* () {
      let items, linkHeader, relParams;
      try {
        items = yield this.bodyHandler(body, headers || {}, unpacked);
      } catch (e) {
        throw err || e;
      }
      if (headers && (linkHeader = headers["Link"] || headers["link"])) {
        relParams = parseRelLinks(linkHeader);
      }
      if (this.useHttpPaginatedResponse) {
        return new HttpPaginatedResponse(this, items, headers || {}, statusCode, relParams, err);
      } else {
        return new PaginatedResult(this, items, relParams);
      }
    });
    handleBody().then((result) => callback(null, result)).catch((err2) => callback(err2, null));
  }
};
var PaginatedResult = class {
  constructor(resource, items, relParams) {
    this.resource = resource;
    this.items = items;
    const self2 = this;
    if (relParams) {
      if ("first" in relParams) {
        this.first = function(callback) {
          if (!callback) {
            return promisify(self2, "first", []);
          }
          self2.get(relParams.first, callback);
        };
      }
      if ("current" in relParams) {
        this.current = function(callback) {
          if (!callback) {
            return promisify(self2, "current", []);
          }
          self2.get(relParams.current, callback);
        };
      }
      this.next = function(callback) {
        if (!callback) {
          return promisify(self2, "next", []);
        }
        if ("next" in relParams) {
          self2.get(relParams.next, callback);
        } else {
          callback(null, null);
        }
      };
      this.hasNext = function() {
        return "next" in relParams;
      };
      this.isLast = () => {
        var _a2;
        return !((_a2 = this.hasNext) == null ? void 0 : _a2.call(this));
      };
    }
  }
  /* We assume that only the initial request can be a POST, and that accessing
   * the rest of a multipage set of results can always be done with GET */
  get(params, callback) {
    const res = this.resource;
    resource_default.get(
      res.client,
      res.path,
      res.headers,
      params,
      res.envelope,
      function(err, body, headers, unpacked, statusCode) {
        res.handlePage(err, body, headers, unpacked, statusCode, callback);
      }
    );
  }
};
var HttpPaginatedResponse = class extends PaginatedResult {
  constructor(resource, items, headers, statusCode, relParams, err) {
    super(resource, items, relParams);
    this.statusCode = statusCode;
    this.success = statusCode < 300 && statusCode >= 200;
    this.headers = headers;
    this.errorCode = err && err.code;
    this.errorMessage = err && err.message;
  }
  toJSON() {
    return {
      items: this.items,
      statusCode: this.statusCode,
      success: this.success,
      headers: this.headers,
      errorCode: this.errorCode,
      errorMessage: this.errorMessage
    };
  }
};
var paginatedresource_default = PaginatedResource;

// src/common/lib/types/pushchannelsubscription.ts
var _PushChannelSubscription = class _PushChannelSubscription {
  /**
   * Overload toJSON() to intercept JSON.stringify()
   * @return {*}
   */
  toJSON() {
    return {
      channel: this.channel,
      deviceId: this.deviceId,
      clientId: this.clientId
    };
  }
  toString() {
    let result = "[PushChannelSubscription";
    if (this.channel)
      result += "; channel=" + this.channel;
    if (this.deviceId)
      result += "; deviceId=" + this.deviceId;
    if (this.clientId)
      result += "; clientId=" + this.clientId;
    result += "]";
    return result;
  }
  static fromResponseBody(body, MsgPack, format) {
    if (format) {
      body = decodeBody(body, MsgPack, format);
    }
    if (isArray(body)) {
      return _PushChannelSubscription.fromValuesArray(body);
    } else {
      return _PushChannelSubscription.fromValues(body);
    }
  }
  static fromValues(values) {
    return Object.assign(new _PushChannelSubscription(), values);
  }
  static fromValuesArray(values) {
    const count = values.length, result = new Array(count);
    for (let i = 0; i < count; i++)
      result[i] = _PushChannelSubscription.fromValues(values[i]);
    return result;
  }
};
_PushChannelSubscription.toRequestBody = encodeBody;
var PushChannelSubscription = _PushChannelSubscription;
var pushchannelsubscription_default = PushChannelSubscription;

// src/common/lib/client/push.ts
var Push = class {
  constructor(client) {
    this.client = client;
    this.admin = new Admin(client);
  }
};
var Admin = class {
  constructor(client) {
    this.client = client;
    this.deviceRegistrations = new DeviceRegistrations(client);
    this.channelSubscriptions = new ChannelSubscriptions(client);
  }
  publish(recipient, payload, callback) {
    const client = this.client;
    const format = client.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, headers = defaults_default.defaultPostHeaders(client.options, { format }), params = {};
    const body = mixin({ recipient }, payload);
    if (typeof callback !== "function") {
      return promisify(this, "publish", arguments);
    }
    mixin(headers, client.options.headers);
    if (client.options.pushFullWait)
      mixin(params, { fullWait: "true" });
    const requestBody = encodeBody(body, client._MsgPack, format);
    resource_default.post(client, "/push/publish", requestBody, headers, params, null, (err) => callback(err));
  }
};
var DeviceRegistrations = class {
  constructor(client) {
    this.client = client;
  }
  save(device, callback) {
    const client = this.client;
    const body = devicedetails_default.fromValues(device);
    const format = client.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, headers = defaults_default.defaultPostHeaders(client.options, { format }), params = {};
    if (typeof callback !== "function") {
      return promisify(this, "save", arguments);
    }
    mixin(headers, client.options.headers);
    if (client.options.pushFullWait)
      mixin(params, { fullWait: "true" });
    const requestBody = encodeBody(body, client._MsgPack, format);
    resource_default.put(
      client,
      "/push/deviceRegistrations/" + encodeURIComponent(device.id),
      requestBody,
      headers,
      params,
      null,
      (err, body2, headers2, unpacked) => {
        callback(
          err,
          !err ? devicedetails_default.fromResponseBody(
            body2,
            client._MsgPack,
            unpacked ? void 0 : format
          ) : void 0
        );
      }
    );
  }
  get(deviceIdOrDetails, callback) {
    const client = this.client, format = client.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, headers = defaults_default.defaultGetHeaders(client.options, { format }), deviceId = deviceIdOrDetails.id || deviceIdOrDetails;
    if (typeof callback !== "function") {
      return promisify(this, "get", arguments);
    }
    if (typeof deviceId !== "string" || !deviceId.length) {
      callback(
        new ErrorInfo(
          "First argument to DeviceRegistrations#get must be a deviceId string or DeviceDetails",
          4e4,
          400
        )
      );
      return;
    }
    mixin(headers, client.options.headers);
    resource_default.get(
      client,
      "/push/deviceRegistrations/" + encodeURIComponent(deviceId),
      headers,
      {},
      null,
      function(err, body, headers2, unpacked) {
        callback(
          err,
          !err ? devicedetails_default.fromResponseBody(
            body,
            client._MsgPack,
            unpacked ? void 0 : format
          ) : void 0
        );
      }
    );
  }
  list(params, callback) {
    const client = this.client, format = client.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });
    if (typeof callback !== "function") {
      return promisify(this, "list", arguments);
    }
    mixin(headers, client.options.headers);
    new paginatedresource_default(client, "/push/deviceRegistrations", headers, envelope, function(body, headers2, unpacked) {
      return __async(this, null, function* () {
        return devicedetails_default.fromResponseBody(
          body,
          client._MsgPack,
          unpacked ? void 0 : format
        );
      });
    }).get(params, callback);
  }
  remove(deviceIdOrDetails, callback) {
    const client = this.client, format = client.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, headers = defaults_default.defaultGetHeaders(client.options, { format }), params = {}, deviceId = deviceIdOrDetails.id || deviceIdOrDetails;
    if (typeof callback !== "function") {
      return promisify(this, "remove", arguments);
    }
    if (typeof deviceId !== "string" || !deviceId.length) {
      callback(
        new ErrorInfo(
          "First argument to DeviceRegistrations#remove must be a deviceId string or DeviceDetails",
          4e4,
          400
        )
      );
      return;
    }
    mixin(headers, client.options.headers);
    if (client.options.pushFullWait)
      mixin(params, { fullWait: "true" });
    resource_default["delete"](
      client,
      "/push/deviceRegistrations/" + encodeURIComponent(deviceId),
      headers,
      params,
      null,
      (err) => callback(err)
    );
  }
  removeWhere(params, callback) {
    const client = this.client, format = client.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, headers = defaults_default.defaultGetHeaders(client.options, { format });
    if (typeof callback !== "function") {
      return promisify(this, "removeWhere", arguments);
    }
    mixin(headers, client.options.headers);
    if (client.options.pushFullWait)
      mixin(params, { fullWait: "true" });
    resource_default["delete"](client, "/push/deviceRegistrations", headers, params, null, (err) => callback(err));
  }
};
var ChannelSubscriptions = class _ChannelSubscriptions {
  constructor(client) {
    /* ChannelSubscriptions have no unique id; removing one is equivalent to removeWhere by its properties */
    this.remove = _ChannelSubscriptions.prototype.removeWhere;
    this.client = client;
  }
  save(subscription, callback) {
    const client = this.client;
    const body = pushchannelsubscription_default.fromValues(subscription);
    const format = client.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, headers = defaults_default.defaultPostHeaders(client.options, { format }), params = {};
    if (typeof callback !== "function") {
      return promisify(this, "save", arguments);
    }
    mixin(headers, client.options.headers);
    if (client.options.pushFullWait)
      mixin(params, { fullWait: "true" });
    const requestBody = encodeBody(body, client._MsgPack, format);
    resource_default.post(
      client,
      "/push/channelSubscriptions",
      requestBody,
      headers,
      params,
      null,
      function(err, body2, headers2, unpacked) {
        callback(
          err,
          !err && pushchannelsubscription_default.fromResponseBody(
            body2,
            client._MsgPack,
            unpacked ? void 0 : format
          )
        );
      }
    );
  }
  list(params, callback) {
    const client = this.client, format = client.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });
    if (typeof callback !== "function") {
      return promisify(this, "list", arguments);
    }
    mixin(headers, client.options.headers);
    new paginatedresource_default(client, "/push/channelSubscriptions", headers, envelope, function(body, headers2, unpacked) {
      return __async(this, null, function* () {
        return pushchannelsubscription_default.fromResponseBody(
          body,
          client._MsgPack,
          unpacked ? void 0 : format
        );
      });
    }).get(params, callback);
  }
  removeWhere(params, callback) {
    const client = this.client, format = client.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, headers = defaults_default.defaultGetHeaders(client.options, { format });
    if (typeof callback !== "function") {
      return promisify(this, "removeWhere", arguments);
    }
    mixin(headers, client.options.headers);
    if (client.options.pushFullWait)
      mixin(params, { fullWait: "true" });
    resource_default["delete"](client, "/push/channelSubscriptions", headers, params, null, (err) => callback(err));
  }
  listChannels(params, callback) {
    const client = this.client, format = client.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });
    if (typeof callback !== "function") {
      return promisify(this, "listChannels", arguments);
    }
    mixin(headers, client.options.headers);
    if (client.options.pushFullWait)
      mixin(params, { fullWait: "true" });
    new paginatedresource_default(client, "/push/channels", headers, envelope, function(body, headers2, unpacked) {
      return __async(this, null, function* () {
        const parsedBody = !unpacked && format ? decodeBody(body, client._MsgPack, format) : body;
        for (let i = 0; i < parsedBody.length; i++) {
          parsedBody[i] = String(parsedBody[i]);
        }
        return parsedBody;
      });
    }).get(params, callback);
  }
};
var push_default = Push;

// src/common/lib/types/message.ts
function normaliseContext(context) {
  if (!context || !context.channelOptions) {
    return {
      channelOptions: context,
      baseEncodedPreviousPayload: void 0
    };
  }
  return context;
}
function normalizeCipherOptions(Crypto2, options) {
  if (options && options.cipher) {
    if (!Crypto2)
      throwMissingModuleError("Crypto");
    const cipher = Crypto2.getCipher(options.cipher);
    return {
      cipher: cipher.cipherParams,
      channelCipher: cipher.cipher
    };
  }
  return options != null ? options : {};
}
function getMessageSize(msg) {
  let size = 0;
  if (msg.name) {
    size += msg.name.length;
  }
  if (msg.clientId) {
    size += msg.clientId.length;
  }
  if (msg.extras) {
    size += JSON.stringify(msg.extras).length;
  }
  if (msg.data) {
    size += dataSizeBytes(msg.data);
  }
  return size;
}
function fromEncoded(Crypto2, encoded, inputOptions) {
  return __async(this, null, function* () {
    const msg = fromValues(encoded);
    const options = normalizeCipherOptions(Crypto2, inputOptions != null ? inputOptions : null);
    try {
      yield decode(msg, options);
    } catch (e) {
      logger_default.logAction(logger_default.LOG_ERROR, "Message.fromEncoded()", e.toString());
    }
    return msg;
  });
}
function fromEncodedArray(Crypto2, encodedArray, options) {
  return __async(this, null, function* () {
    return Promise.all(
      encodedArray.map(function(encoded) {
        return fromEncoded(Crypto2, encoded, options);
      })
    );
  });
}
function encrypt(msg, options, callback) {
  let data = msg.data, encoding = msg.encoding, cipher = options.channelCipher;
  encoding = encoding ? encoding + "/" : "";
  if (!Platform.BufferUtils.isBuffer(data)) {
    data = Platform.BufferUtils.utf8Encode(String(data));
    encoding = encoding + "utf-8/";
  }
  cipher.encrypt(data, function(err, data2) {
    if (err) {
      callback(err);
      return;
    }
    msg.data = data2;
    msg.encoding = encoding + "cipher+" + cipher.algorithm;
    callback(null, msg);
  });
}
function encode(msg, options, callback) {
  const data = msg.data;
  const nativeDataType = typeof data == "string" || Platform.BufferUtils.isBuffer(data) || data === null || data === void 0;
  if (!nativeDataType) {
    if (isObject(data) || isArray(data)) {
      msg.data = JSON.stringify(data);
      msg.encoding = msg.encoding ? msg.encoding + "/json" : "json";
    } else {
      throw new ErrorInfo("Data type is unsupported", 40013, 400);
    }
  }
  if (options != null && options.cipher) {
    encrypt(msg, options, callback);
  } else {
    callback(null, msg);
  }
}
function encodeArray(messages, options, callback) {
  let processed = 0;
  for (let i = 0; i < messages.length; i++) {
    encode(messages[i], options, function(err) {
      if (err) {
        callback(err);
        return;
      }
      processed++;
      if (processed == messages.length) {
        callback(null, messages);
      }
    });
  }
}
var serialize = encodeBody;
function decode(message, inputContext) {
  return __async(this, null, function* () {
    const context = normaliseContext(inputContext);
    let lastPayload = message.data;
    const encoding = message.encoding;
    if (encoding) {
      const xforms = encoding.split("/");
      let lastProcessedEncodingIndex, encodingsToProcess = xforms.length, data = message.data;
      let xform = "";
      try {
        while ((lastProcessedEncodingIndex = encodingsToProcess) > 0) {
          const match = xforms[--encodingsToProcess].match(/([-\w]+)(\+([\w-]+))?/);
          if (!match)
            break;
          xform = match[1];
          switch (xform) {
            case "base64":
              data = Platform.BufferUtils.base64Decode(String(data));
              if (lastProcessedEncodingIndex == xforms.length) {
                lastPayload = data;
              }
              continue;
            case "utf-8":
              data = Platform.BufferUtils.utf8Decode(data);
              continue;
            case "json":
              data = JSON.parse(data);
              continue;
            case "cipher":
              if (context.channelOptions != null && context.channelOptions.cipher && context.channelOptions.channelCipher) {
                const xformAlgorithm = match[3], cipher = context.channelOptions.channelCipher;
                if (xformAlgorithm != cipher.algorithm) {
                  throw new Error("Unable to decrypt message with given cipher; incompatible cipher params");
                }
                data = yield cipher.decrypt(data);
                continue;
              } else {
                throw new Error("Unable to decrypt message; not an encrypted channel");
              }
            case "vcdiff":
              if (!context.decodeVcdiff) {
                if (Platform.Vcdiff.supported) {
                  throwMissingModuleError("Vcdiff");
                } else {
                  throw new ErrorInfo(Platform.Vcdiff.errorMessage, 40019, 400);
                }
              }
              if (typeof Uint8Array === "undefined") {
                throw new ErrorInfo(
                  "Delta decoding not supported on this browser (need ArrayBuffer & Uint8Array)",
                  40020,
                  400
                );
              }
              try {
                let deltaBase = context.baseEncodedPreviousPayload;
                if (typeof deltaBase === "string") {
                  deltaBase = Platform.BufferUtils.utf8Encode(deltaBase);
                }
                const deltaBaseBuffer = Platform.BufferUtils.toBuffer(deltaBase);
                data = Platform.BufferUtils.toBuffer(data);
                data = Platform.BufferUtils.arrayBufferViewToBuffer(context.decodeVcdiff(data, deltaBaseBuffer));
                lastPayload = data;
              } catch (e) {
                throw new ErrorInfo("Vcdiff delta decode failed with " + e, 40018, 400);
              }
              continue;
            default:
              throw new Error("Unknown encoding");
          }
        }
      } catch (e) {
        const err = e;
        throw new ErrorInfo(
          "Error processing the " + xform + " encoding, decoder returned \u2018" + err.message + "\u2019",
          err.code || 40013,
          400
        );
      } finally {
        message.encoding = lastProcessedEncodingIndex <= 0 ? null : xforms.slice(0, lastProcessedEncodingIndex).join("/");
        message.data = data;
      }
    }
    context.baseEncodedPreviousPayload = lastPayload;
  });
}
function fromResponseBody(body, options, MsgPack, format) {
  return __async(this, null, function* () {
    if (format) {
      body = decodeBody(body, MsgPack, format);
    }
    for (let i = 0; i < body.length; i++) {
      const msg = body[i] = fromValues(body[i]);
      try {
        yield decode(msg, options);
      } catch (e) {
        logger_default.logAction(logger_default.LOG_ERROR, "Message.fromResponseBody()", e.toString());
      }
    }
    return body;
  });
}
function fromValues(values) {
  return Object.assign(new Message(), values);
}
function fromValuesArray(values) {
  const count = values.length, result = new Array(count);
  for (let i = 0; i < count; i++)
    result[i] = fromValues(values[i]);
  return result;
}
function getMessagesSize(messages) {
  let msg, total = 0;
  for (let i = 0; i < messages.length; i++) {
    msg = messages[i];
    total += msg.size || (msg.size = getMessageSize(msg));
  }
  return total;
}
var Message = class {
  /**
   * Overload toJSON() to intercept JSON.stringify()
   * @return {*}
   */
  toJSON() {
    let encoding = this.encoding;
    let data = this.data;
    if (data && Platform.BufferUtils.isBuffer(data)) {
      if (arguments.length > 0) {
        encoding = encoding ? encoding + "/base64" : "base64";
        data = Platform.BufferUtils.base64Encode(data);
      } else {
        data = Platform.BufferUtils.toBuffer(data);
      }
    }
    return {
      name: this.name,
      id: this.id,
      clientId: this.clientId,
      connectionId: this.connectionId,
      connectionKey: this.connectionKey,
      extras: this.extras,
      encoding,
      data
    };
  }
  toString() {
    let result = "[Message";
    if (this.name)
      result += "; name=" + this.name;
    if (this.id)
      result += "; id=" + this.id;
    if (this.timestamp)
      result += "; timestamp=" + this.timestamp;
    if (this.clientId)
      result += "; clientId=" + this.clientId;
    if (this.connectionId)
      result += "; connectionId=" + this.connectionId;
    if (this.encoding)
      result += "; encoding=" + this.encoding;
    if (this.extras)
      result += "; extras =" + JSON.stringify(this.extras);
    if (this.data) {
      if (typeof this.data == "string")
        result += "; data=" + this.data;
      else if (Platform.BufferUtils.isBuffer(this.data))
        result += "; data (buffer)=" + Platform.BufferUtils.base64Encode(this.data);
      else
        result += "; data (json)=" + JSON.stringify(this.data);
    }
    if (this.extras)
      result += "; extras=" + JSON.stringify(this.extras);
    result += "]";
    return result;
  }
};

// src/common/lib/types/presencemessage.ts
var actions = ["absent", "present", "enter", "leave", "update"];
function toActionValue(actionString) {
  return actions.indexOf(actionString);
}
function fromEncoded2(encoded, options) {
  return __async(this, null, function* () {
    const msg = fromValues2(encoded, true);
    try {
      yield decode2(msg, options != null ? options : {});
    } catch (e) {
      logger_default.logAction(logger_default.LOG_ERROR, "PresenceMessage.fromEncoded()", e.toString());
    }
    return msg;
  });
}
function fromEncodedArray2(encodedArray, options) {
  return __async(this, null, function* () {
    return Promise.all(
      encodedArray.map(function(encoded) {
        return fromEncoded2(encoded, options);
      })
    );
  });
}
function fromValues2(values, stringifyAction) {
  if (stringifyAction) {
    values.action = actions[values.action];
  }
  return Object.assign(new PresenceMessage(), values);
}
var decode2 = decode;
function fromResponseBody2(body, options, MsgPack, format) {
  return __async(this, null, function* () {
    const messages = [];
    if (format) {
      body = decodeBody(body, MsgPack, format);
    }
    for (let i = 0; i < body.length; i++) {
      const msg = messages[i] = fromValues2(body[i], true);
      try {
        yield decode2(msg, options);
      } catch (e) {
        logger_default.logAction(logger_default.LOG_ERROR, "PresenceMessage.fromResponseBody()", e.toString());
      }
    }
    return messages;
  });
}
function fromValuesArray2(values) {
  const count = values.length, result = new Array(count);
  for (let i = 0; i < count; i++)
    result[i] = fromValues2(values[i]);
  return result;
}
function fromData(data) {
  if (data instanceof PresenceMessage) {
    return data;
  }
  return fromValues2({
    data
  });
}
var PresenceMessage = class {
  /* Returns whether this presenceMessage is synthesized, i.e. was not actually
   * sent by the connection (usually means a leave event sent 15s after a
   * disconnection). This is useful because synthesized messages cannot be
   * compared for newness by id lexicographically - RTP2b1
   */
  isSynthesized() {
    if (!this.id || !this.connectionId) {
      return true;
    }
    return this.id.substring(this.connectionId.length, 0) !== this.connectionId;
  }
  /* RTP2b2 */
  parseId() {
    if (!this.id)
      throw new Error("parseId(): Presence message does not contain an id");
    const parts = this.id.split(":");
    return {
      connectionId: parts[0],
      msgSerial: parseInt(parts[1], 10),
      index: parseInt(parts[2], 10)
    };
  }
  /**
   * Overload toJSON() to intercept JSON.stringify()
   * @return {*}
   */
  toJSON() {
    let data = this.data;
    let encoding = this.encoding;
    if (data && Platform.BufferUtils.isBuffer(data)) {
      if (arguments.length > 0) {
        encoding = encoding ? encoding + "/base64" : "base64";
        data = Platform.BufferUtils.base64Encode(data);
      } else {
        data = Platform.BufferUtils.toBuffer(data);
      }
    }
    return {
      id: this.id,
      clientId: this.clientId,
      /* Convert presence action back to an int for sending to Ably */
      action: toActionValue(this.action),
      data,
      encoding,
      extras: this.extras
    };
  }
  toString() {
    let result = "[PresenceMessage";
    result += "; action=" + this.action;
    if (this.id)
      result += "; id=" + this.id;
    if (this.timestamp)
      result += "; timestamp=" + this.timestamp;
    if (this.clientId)
      result += "; clientId=" + this.clientId;
    if (this.connectionId)
      result += "; connectionId=" + this.connectionId;
    if (this.encoding)
      result += "; encoding=" + this.encoding;
    if (this.data) {
      if (typeof this.data == "string")
        result += "; data=" + this.data;
      else if (Platform.BufferUtils.isBuffer(this.data))
        result += "; data (buffer)=" + Platform.BufferUtils.base64Encode(this.data);
      else
        result += "; data (json)=" + JSON.stringify(this.data);
    }
    if (this.extras) {
      result += "; extras=" + JSON.stringify(this.extras);
    }
    result += "]";
    return result;
  }
};

// src/common/lib/client/restpresence.ts
var RestPresence = class {
  constructor(channel) {
    this.channel = channel;
  }
  get(params, callback) {
    logger_default.logAction(logger_default.LOG_MICRO, "RestPresence.get()", "channel = " + this.channel.name);
    if (callback === void 0) {
      if (typeof params == "function") {
        callback = params;
        params = null;
      } else {
        return promisify(this, "get", arguments);
      }
    }
    const client = this.channel.client, format = client.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, envelope = this.channel.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });
    mixin(headers, client.options.headers);
    const options = this.channel.channelOptions;
    new paginatedresource_default(
      client,
      this.channel.client.rest.presenceMixin.basePath(this),
      headers,
      envelope,
      function(body, headers2, unpacked) {
        return __async(this, null, function* () {
          return yield fromResponseBody2(
            body,
            options,
            client._MsgPack,
            unpacked ? void 0 : format
          );
        });
      }
    ).get(params, callback);
  }
  history(params, callback) {
    logger_default.logAction(logger_default.LOG_MICRO, "RestPresence.history()", "channel = " + this.channel.name);
    return this.channel.client.rest.presenceMixin.history(this, params, callback);
  }
};
var restpresence_default = RestPresence;

// src/common/lib/client/restchannel.ts
var MSG_ID_ENTROPY_BYTES = 9;
function allEmptyIds(messages) {
  return arrEvery(messages, function(message) {
    return !message.id;
  });
}
var RestChannel = class {
  constructor(client, name, channelOptions) {
    var _a2;
    logger_default.logAction(logger_default.LOG_MINOR, "RestChannel()", "started; name = " + name);
    this.name = name;
    this.client = client;
    this.presence = new restpresence_default(this);
    this.channelOptions = normaliseChannelOptions((_a2 = client._Crypto) != null ? _a2 : null, channelOptions);
  }
  setOptions(options) {
    var _a2;
    this.channelOptions = normaliseChannelOptions((_a2 = this.client._Crypto) != null ? _a2 : null, options);
  }
  history(params, callback) {
    logger_default.logAction(logger_default.LOG_MICRO, "RestChannel.history()", "channel = " + this.name);
    if (callback === void 0) {
      if (typeof params == "function") {
        callback = params;
        params = null;
      } else {
        return promisify(this, "history", arguments);
      }
    }
    this.client.rest.channelMixin.history(this, params, callback);
  }
  publish() {
    const argCount = arguments.length, first = arguments[0], second = arguments[1];
    let callback = arguments[argCount - 1];
    let messages;
    let params;
    if (typeof callback !== "function") {
      return promisify(this, "publish", arguments);
    }
    if (typeof first === "string" || first === null) {
      messages = [fromValues({ name: first, data: second })];
      params = arguments[2];
    } else if (isObject(first)) {
      messages = [fromValues(first)];
      params = arguments[1];
    } else if (isArray(first)) {
      messages = fromValuesArray(first);
      params = arguments[1];
    } else {
      throw new ErrorInfo(
        "The single-argument form of publish() expects a message object or an array of message objects",
        40013,
        400
      );
    }
    if (typeof params !== "object" || !params) {
      params = {};
    }
    const client = this.client, options = client.options, format = options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, idempotentRestPublishing = client.options.idempotentRestPublishing, headers = defaults_default.defaultPostHeaders(client.options, { format });
    mixin(headers, options.headers);
    if (idempotentRestPublishing && allEmptyIds(messages)) {
      const msgIdBase = randomString(MSG_ID_ENTROPY_BYTES);
      arrForEach(messages, function(message, index) {
        message.id = msgIdBase + ":" + index.toString();
      });
    }
    encodeArray(messages, this.channelOptions, (err) => {
      if (err) {
        callback(err);
        return;
      }
      const size = getMessagesSize(messages), maxMessageSize = options.maxMessageSize;
      if (size > maxMessageSize) {
        callback(
          new ErrorInfo(
            "Maximum size of messages that can be published at once exceeded ( was " + size + " bytes; limit is " + maxMessageSize + " bytes)",
            40009,
            400
          )
        );
        return;
      }
      this._publish(serialize(messages, client._MsgPack, format), headers, params, callback);
    });
  }
  _publish(requestBody, headers, params, callback) {
    resource_default.post(
      this.client,
      this.client.rest.channelMixin.basePath(this) + "/messages",
      requestBody,
      headers,
      params,
      null,
      callback
    );
  }
  status(callback) {
    return this.client.rest.channelMixin.status(this, callback);
  }
};
var restchannel_default = RestChannel;

// src/common/lib/types/stats.ts
var Stats = class _Stats {
  constructor(values) {
    this.entries = values && values.entries || void 0;
    this.schema = values && values.schema || void 0;
    this.appId = values && values.appId || void 0;
    this.inProgress = values && values.inProgress || void 0;
    this.unit = values && values.unit || void 0;
    this.intervalId = values && values.intervalId || void 0;
  }
  static fromValues(values) {
    return new _Stats(values);
  }
};
var stats_default = Stats;

// src/common/lib/client/restchannelmixin.ts
var noop2 = function() {
};
var RestChannelMixin = class {
  static basePath(channel) {
    return "/channels/" + encodeURIComponent(channel.name);
  }
  static history(channel, params, callback) {
    const client = channel.client, format = client.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, envelope = channel.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });
    mixin(headers, client.options.headers);
    const options = channel.channelOptions;
    new paginatedresource_default(client, this.basePath(channel) + "/messages", headers, envelope, function(body, headers2, unpacked) {
      return __async(this, null, function* () {
        return yield fromResponseBody(body, options, client._MsgPack, unpacked ? void 0 : format);
      });
    }).get(params, callback);
  }
  static status(channel, callback) {
    if (typeof callback !== "function") {
      return promisify(this, "status", [channel]);
    }
    const format = channel.client.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */;
    const headers = defaults_default.defaultPostHeaders(channel.client.options, { format });
    resource_default.get(channel.client, this.basePath(channel), headers, {}, format, callback || noop2);
  }
};

// src/common/lib/client/restpresencemixin.ts
var RestPresenceMixin = class {
  static basePath(presence) {
    return RestChannelMixin.basePath(presence.channel) + "/presence";
  }
  static history(presence, params, callback) {
    if (callback === void 0) {
      if (typeof params == "function") {
        callback = params;
        params = null;
      } else {
        return promisify(this, "history", [presence, params]);
      }
    }
    const client = presence.channel.client, format = client.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, envelope = presence.channel.client.http.supportsLinkHeaders ? void 0 : format, headers = defaults_default.defaultGetHeaders(client.options, { format });
    mixin(headers, client.options.headers);
    const options = presence.channel.channelOptions;
    new paginatedresource_default(client, this.basePath(presence) + "/history", headers, envelope, function(body, headers2, unpacked) {
      return __async(this, null, function* () {
        return yield fromResponseBody2(
          body,
          options,
          client._MsgPack,
          unpacked ? void 0 : format
        );
      });
    }).get(params, callback);
  }
};

// src/common/lib/client/rest.ts
var noop3 = function() {
};
var Rest = class {
  constructor(client) {
    this.channelMixin = RestChannelMixin;
    this.presenceMixin = RestPresenceMixin;
    this.client = client;
    this.channels = new Channels(this.client);
    this.push = new push_default(this.client);
  }
  stats(params, callback) {
    if (callback === void 0) {
      if (typeof params == "function") {
        callback = params;
        params = null;
      } else {
        return promisify(this, "stats", [params]);
      }
    }
    const headers = defaults_default.defaultGetHeaders(this.client.options), format = this.client.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, envelope = this.client.http.supportsLinkHeaders ? void 0 : format;
    mixin(headers, this.client.options.headers);
    new paginatedresource_default(this.client, "/stats", headers, envelope, function(body, headers2, unpacked) {
      const statsValues = unpacked ? body : JSON.parse(body);
      for (let i = 0; i < statsValues.length; i++)
        statsValues[i] = stats_default.fromValues(statsValues[i]);
      return statsValues;
    }).get(params, callback);
  }
  time(params, callback) {
    if (callback === void 0) {
      if (typeof params == "function") {
        callback = params;
        params = null;
      } else {
        return promisify(this, "time", [params]);
      }
    }
    const _callback = callback || noop3;
    const headers = defaults_default.defaultGetHeaders(this.client.options);
    if (this.client.options.headers)
      mixin(headers, this.client.options.headers);
    const timeUri = (host) => {
      return this.client.baseUri(host) + "/time";
    };
    this.client.http.do(
      HttpMethods_default.Get,
      timeUri,
      headers,
      null,
      params,
      (err, res, headers2, unpacked) => {
        if (err) {
          _callback(err);
          return;
        }
        if (!unpacked)
          res = JSON.parse(res);
        const time = res[0];
        if (!time) {
          _callback(new ErrorInfo("Internal error (unexpected result type from GET /time)", 5e4, 500));
          return;
        }
        this.client.serverTimeOffset = time - now();
        _callback(null, time);
      }
    );
  }
  request(method, path, version2, params, body, customHeaders, callback) {
    const [encoder, decoder, format] = (() => {
      if (this.client.options.useBinaryProtocol) {
        if (!this.client._MsgPack) {
          throwMissingModuleError("MsgPack");
        }
        return [this.client._MsgPack.encode, this.client._MsgPack.decode, "msgpack" /* msgpack */];
      } else {
        return [JSON.stringify, JSON.parse, "json" /* json */];
      }
    })();
    const envelope = this.client.http.supportsLinkHeaders ? void 0 : format;
    params = params || {};
    const _method = method.toLowerCase();
    const headers = _method == "get" ? defaults_default.defaultGetHeaders(this.client.options, { format, protocolVersion: version2 }) : defaults_default.defaultPostHeaders(this.client.options, { format, protocolVersion: version2 });
    if (callback === void 0) {
      return promisify(this, "request", [method, path, version2, params, body, customHeaders]);
    }
    if (typeof body !== "string") {
      body = encoder(body);
    }
    mixin(headers, this.client.options.headers);
    if (customHeaders) {
      mixin(headers, customHeaders);
    }
    const paginatedResource = new paginatedresource_default(
      this.client,
      path,
      headers,
      envelope,
      function(resbody, headers2, unpacked) {
        return __async(this, null, function* () {
          return ensureArray(unpacked ? resbody : decoder(resbody));
        });
      },
      /* useHttpPaginatedResponse: */
      true
    );
    if (!arrIn(Platform.Http.methods, _method)) {
      throw new ErrorInfo("Unsupported method " + _method, 40500, 405);
    }
    if (arrIn(Platform.Http.methodsWithBody, _method)) {
      paginatedResource[_method](params, body, callback);
    } else {
      paginatedResource[_method](
        params,
        callback
      );
    }
  }
  batchPublish(specOrSpecs, callback) {
    if (callback === void 0) {
      return promisify(this, "batchPublish", [specOrSpecs]);
    }
    let requestBodyDTO;
    let singleSpecMode;
    if (isArray(specOrSpecs)) {
      requestBodyDTO = specOrSpecs;
      singleSpecMode = false;
    } else {
      requestBodyDTO = [specOrSpecs];
      singleSpecMode = true;
    }
    const format = this.client.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, headers = defaults_default.defaultPostHeaders(this.client.options, { format });
    if (this.client.options.headers)
      mixin(headers, this.client.options.headers);
    const requestBody = encodeBody(requestBodyDTO, this.client._MsgPack, format);
    resource_default.post(this.client, "/messages", requestBody, headers, {}, null, (err, body, headers2, unpacked) => {
      if (err) {
        callback(err);
        return;
      }
      const batchResults = unpacked ? body : decodeBody(body, this.client._MsgPack, format);
      if (singleSpecMode) {
        callback(null, batchResults[0]);
      } else {
        callback(null, batchResults);
      }
    });
  }
  batchPresence(channels, callback) {
    if (callback === void 0) {
      return promisify(this, "batchPresence", [channels]);
    }
    const format = this.client.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, headers = defaults_default.defaultPostHeaders(this.client.options, { format });
    if (this.client.options.headers)
      mixin(headers, this.client.options.headers);
    const channelsParam = channels.join(",");
    resource_default.get(
      this.client,
      "/presence",
      headers,
      { channels: channelsParam },
      null,
      (err, body, headers2, unpacked) => {
        if (err) {
          callback(err);
          return;
        }
        const batchResult = unpacked ? body : decodeBody(body, this.client._MsgPack, format);
        callback(null, batchResult);
      }
    );
  }
  revokeTokens(specifiers, options) {
    if (useTokenAuth(this.client.options)) {
      throw new ErrorInfo("Cannot revoke tokens when using token auth", 40162, 401);
    }
    const keyName = this.client.options.keyName;
    let resolvedOptions = options != null ? options : {};
    const requestBodyDTO = __spreadValues({
      targets: specifiers.map((specifier) => `${specifier.type}:${specifier.value}`)
    }, resolvedOptions);
    const format = this.client.options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */, headers = defaults_default.defaultPostHeaders(this.client.options, { format });
    if (this.client.options.headers)
      mixin(headers, this.client.options.headers);
    const requestBody = encodeBody(requestBodyDTO, this.client._MsgPack, format);
    return new Promise((resolve, reject) => {
      resource_default.post(
        this.client,
        `/keys/${keyName}/revokeTokens`,
        requestBody,
        headers,
        {},
        null,
        (err, body, headers2, unpacked) => {
          if (err) {
            reject(err);
            return;
          }
          const batchResult = unpacked ? body : decodeBody(body, this.client._MsgPack, format);
          resolve(batchResult);
        }
      );
    });
  }
  setLog(logOptions) {
    logger_default.setLog(logOptions.level, logOptions.handler);
  }
};
var Channels = class {
  constructor(client) {
    this.client = client;
    this.all = /* @__PURE__ */ Object.create(null);
  }
  get(name, channelOptions) {
    name = String(name);
    let channel = this.all[name];
    if (!channel) {
      this.all[name] = channel = new restchannel_default(this.client, name, channelOptions);
    } else if (channelOptions) {
      channel.setOptions(channelOptions);
    }
    return channel;
  }
  /* Included to support certain niche use-cases; most users should ignore this.
   * Please do not use this unless you know what you're doing */
  release(name) {
    delete this.all[String(name)];
  }
};

// src/common/lib/client/baserest.ts
var BaseRest = class extends baseclient_default {
  constructor(options, modules) {
    super(options, __spreadValues({ Rest }, modules));
  }
};

// src/common/lib/util/eventemitter.ts
function callListener(eventThis, listener, args) {
  try {
    listener.apply(eventThis, args);
  } catch (e) {
    logger_default.logAction(
      logger_default.LOG_ERROR,
      "EventEmitter.emit()",
      "Unexpected listener exception: " + e + "; stack = " + (e && e.stack)
    );
  }
}
function removeListener(targetListeners, listener, eventFilter) {
  let listeners;
  let index;
  let eventName;
  for (let targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {
    listeners = targetListeners[targetListenersIndex];
    if (eventFilter) {
      listeners = listeners[eventFilter];
    }
    if (isArray(listeners)) {
      while ((index = arrIndexOf(listeners, listener)) !== -1) {
        listeners.splice(index, 1);
      }
      if (eventFilter && listeners.length === 0) {
        delete targetListeners[targetListenersIndex][eventFilter];
      }
    } else if (isObject(listeners)) {
      for (eventName in listeners) {
        if (Object.prototype.hasOwnProperty.call(listeners, eventName) && isArray(listeners[eventName])) {
          removeListener([listeners], listener, eventName);
        }
      }
    }
  }
}
var EventEmitter = class _EventEmitter {
  constructor() {
    this.any = [];
    this.events = /* @__PURE__ */ Object.create(null);
    this.anyOnce = [];
    this.eventsOnce = /* @__PURE__ */ Object.create(null);
  }
  on(...args) {
    if (args.length === 1) {
      const listener = args[0];
      if (typeof listener === "function") {
        this.any.push(listener);
      } else {
        throw new Error("EventListener.on(): Invalid arguments: " + Platform.Config.inspect(args));
      }
    }
    if (args.length === 2) {
      const [event, listener] = args;
      if (typeof listener !== "function") {
        throw new Error("EventListener.on(): Invalid arguments: " + Platform.Config.inspect(args));
      }
      if (isEmptyArg(event)) {
        this.any.push(listener);
      } else if (isArray(event)) {
        event.forEach((eventName) => {
          this.on(eventName, listener);
        });
      } else {
        if (typeof event !== "string") {
          throw new Error("EventListener.on(): Invalid arguments: " + Platform.Config.inspect(args));
        }
        const listeners = this.events[event] || (this.events[event] = []);
        listeners.push(listener);
      }
    }
  }
  off(...args) {
    if (args.length == 0 || isEmptyArg(args[0]) && isEmptyArg(args[1])) {
      this.any = [];
      this.events = /* @__PURE__ */ Object.create(null);
      this.anyOnce = [];
      this.eventsOnce = /* @__PURE__ */ Object.create(null);
      return;
    }
    const [firstArg, secondArg] = args;
    let listener = null;
    let event = null;
    if (args.length === 1 || !secondArg) {
      if (typeof firstArg === "function") {
        listener = firstArg;
      } else {
        event = firstArg;
      }
    } else {
      if (typeof secondArg !== "function") {
        throw new Error("EventEmitter.off(): invalid arguments:" + Platform.Config.inspect(args));
      }
      [event, listener] = [firstArg, secondArg];
    }
    if (listener && isEmptyArg(event)) {
      removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listener);
      return;
    }
    if (isArray(event)) {
      event.forEach((eventName) => {
        this.off(eventName, listener);
      });
      return;
    }
    if (typeof event !== "string") {
      throw new Error("EventEmitter.off(): invalid arguments:" + Platform.Config.inspect(args));
    }
    if (listener) {
      removeListener([this.events, this.eventsOnce], listener, event);
    } else {
      delete this.events[event];
      delete this.eventsOnce[event];
    }
  }
  /**
   * Get the array of listeners for a given event; excludes once events
   * @param event (optional) the name of the event, or none for 'any'
   * @return array of events, or null if none
   */
  listeners(event) {
    if (event) {
      const listeners = this.events[event] || [];
      if (this.eventsOnce[event])
        Array.prototype.push.apply(listeners, this.eventsOnce[event]);
      return listeners.length ? listeners : null;
    }
    return this.any.length ? this.any : null;
  }
  /**
   * Emit an event
   * @param event the event name
   * @param args the arguments to pass to the listener
   */
  emit(event, ...args) {
    const eventThis = { event };
    const listeners = [];
    if (this.anyOnce.length) {
      Array.prototype.push.apply(listeners, this.anyOnce);
      this.anyOnce = [];
    }
    if (this.any.length) {
      Array.prototype.push.apply(listeners, this.any);
    }
    const eventsOnceListeners = this.eventsOnce[event];
    if (eventsOnceListeners) {
      Array.prototype.push.apply(listeners, eventsOnceListeners);
      delete this.eventsOnce[event];
    }
    const eventsListeners = this.events[event];
    if (eventsListeners) {
      Array.prototype.push.apply(listeners, eventsListeners);
    }
    arrForEach(listeners, function(listener) {
      callListener(eventThis, listener, args);
    });
  }
  once(...args) {
    const argCount = args.length;
    if (argCount === 0 || argCount === 1 && typeof args[0] !== "function") {
      const event = args[0];
      return new Promise((resolve) => {
        this.once(event, resolve);
      });
    }
    const [firstArg, secondArg] = args;
    if (args.length === 1 && typeof firstArg === "function") {
      this.anyOnce.push(firstArg);
    } else if (isEmptyArg(firstArg)) {
      if (typeof secondArg !== "function") {
        throw new Error("EventEmitter.once(): Invalid arguments:" + Platform.Config.inspect(args));
      }
      this.anyOnce.push(secondArg);
    } else if (isArray(firstArg)) {
      const self2 = this;
      const listenerWrapper = function() {
        const innerArgs = Array.prototype.slice.call(arguments);
        arrForEach(firstArg, function(eventName) {
          self2.off(eventName, listenerWrapper);
        });
        if (typeof secondArg !== "function") {
          throw new Error("EventEmitter.once(): Invalid arguments:" + Platform.Config.inspect(args));
        }
        secondArg.apply(this, innerArgs);
      };
      arrForEach(firstArg, function(eventName) {
        self2.on(eventName, listenerWrapper);
      });
    } else {
      if (typeof firstArg !== "string") {
        throw new Error("EventEmitter.once(): Invalid arguments:" + Platform.Config.inspect(args));
      }
      const listeners = this.eventsOnce[firstArg] || (this.eventsOnce[firstArg] = []);
      if (secondArg) {
        if (typeof secondArg !== "function") {
          throw new Error("EventEmitter.once(): Invalid arguments:" + Platform.Config.inspect(args));
        }
        listeners.push(secondArg);
      }
    }
  }
  /**
   * Private API
   *
   * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState
   * @param targetState the name of the state event to listen to
   * @param currentState the name of the current state of this object
   * @param listener the listener to be called
   * @param listenerArgs
   */
  whenState(targetState, currentState, listener, ...listenerArgs) {
    const eventThis = { event: targetState };
    if (typeof targetState !== "string" || typeof currentState !== "string") {
      throw "whenState requires a valid event String argument";
    }
    if (typeof listener !== "function") {
      return new Promise((resolve) => {
        _EventEmitter.prototype.whenState.apply(
          this,
          [targetState, currentState, resolve].concat(listenerArgs)
        );
      });
    }
    if (targetState === currentState) {
      callListener(eventThis, listener, listenerArgs);
    } else {
      this.once(targetState, listener);
    }
  }
};
var eventemitter_default = EventEmitter;

// src/common/lib/types/protocolmessage.ts
var actions2 = {
  HEARTBEAT: 0,
  ACK: 1,
  NACK: 2,
  CONNECT: 3,
  CONNECTED: 4,
  DISCONNECT: 5,
  DISCONNECTED: 6,
  CLOSE: 7,
  CLOSED: 8,
  ERROR: 9,
  ATTACH: 10,
  ATTACHED: 11,
  DETACH: 12,
  DETACHED: 13,
  PRESENCE: 14,
  MESSAGE: 15,
  SYNC: 16,
  AUTH: 17,
  ACTIVATE: 18
};
var ActionName = [];
Object.keys(actions2).forEach(function(name) {
  ActionName[actions2[name]] = name;
});
var flags = {
  /* Channel attach state flags */
  HAS_PRESENCE: 1 << 0,
  HAS_BACKLOG: 1 << 1,
  RESUMED: 1 << 2,
  TRANSIENT: 1 << 4,
  ATTACH_RESUME: 1 << 5,
  /* Channel mode flags */
  PRESENCE: 1 << 16,
  PUBLISH: 1 << 17,
  SUBSCRIBE: 1 << 18,
  PRESENCE_SUBSCRIBE: 1 << 19
};
var flagNames = Object.keys(flags);
flags.MODE_ALL = flags.PRESENCE | flags.PUBLISH | flags.SUBSCRIBE | flags.PRESENCE_SUBSCRIBE;
function toStringArray(array) {
  const result = [];
  if (array) {
    for (let i = 0; i < array.length; i++) {
      result.push(array[i].toString());
    }
  }
  return "[ " + result.join(", ") + " ]";
}
var channelModes = ["PRESENCE", "PUBLISH", "SUBSCRIBE", "PRESENCE_SUBSCRIBE"];
var serialize2 = encodeBody;
function deserialize(serialized, MsgPack, presenceMessageModule, format) {
  const deserialized = decodeBody(serialized, MsgPack, format);
  return fromDeserialized(deserialized, presenceMessageModule);
}
function fromDeserialized(deserialized, presenceMessageModule) {
  const error = deserialized.error;
  if (error)
    deserialized.error = ErrorInfo.fromValues(error);
  const messages = deserialized.messages;
  if (messages)
    for (let i = 0; i < messages.length; i++)
      messages[i] = fromValues(messages[i]);
  const presence = presenceMessageModule ? deserialized.presence : void 0;
  if (presenceMessageModule) {
    if (presence && presenceMessageModule)
      for (let i = 0; i < presence.length; i++)
        presence[i] = presenceMessageModule.presenceMessageFromValues(presence[i], true);
  }
  return Object.assign(new ProtocolMessage(), __spreadProps(__spreadValues({}, deserialized), { presence }));
}
function fromValues3(values) {
  return Object.assign(new ProtocolMessage(), values);
}
function stringify(msg, presenceMessageModule) {
  let result = "[ProtocolMessage";
  if (msg.action !== void 0)
    result += "; action=" + ActionName[msg.action] || msg.action;
  const simpleAttributes = ["id", "channel", "channelSerial", "connectionId", "count", "msgSerial", "timestamp"];
  let attribute;
  for (let attribIndex = 0; attribIndex < simpleAttributes.length; attribIndex++) {
    attribute = simpleAttributes[attribIndex];
    if (msg[attribute] !== void 0)
      result += "; " + attribute + "=" + msg[attribute];
  }
  if (msg.messages)
    result += "; messages=" + toStringArray(fromValuesArray(msg.messages));
  if (msg.presence && presenceMessageModule)
    result += "; presence=" + toStringArray(presenceMessageModule.presenceMessagesFromValuesArray(msg.presence));
  if (msg.error)
    result += "; error=" + ErrorInfo.fromValues(msg.error).toString();
  if (msg.auth && msg.auth.accessToken)
    result += "; token=" + msg.auth.accessToken;
  if (msg.flags)
    result += "; flags=" + flagNames.filter(msg.hasFlag).join(",");
  if (msg.params) {
    let stringifiedParams = "";
    forInOwnNonNullProperties(msg.params, function(prop) {
      if (stringifiedParams.length > 0) {
        stringifiedParams += "; ";
      }
      stringifiedParams += prop + "=" + msg.params[prop];
    });
    if (stringifiedParams.length > 0) {
      result += "; params=[" + stringifiedParams + "]";
    }
  }
  result += "]";
  return result;
}
var ProtocolMessage = class {
  constructor() {
    this.hasFlag = (flag) => {
      return (this.flags & flags[flag]) > 0;
    };
  }
  setFlag(flag) {
    return this.flags = this.flags | flags[flag];
  }
  getMode() {
    return this.flags && this.flags & flags.MODE_ALL;
  }
  encodeModesToFlags(modes) {
    modes.forEach((mode) => this.setFlag(mode));
  }
  decodeModesFromFlags() {
    const modes = [];
    channelModes.forEach((mode) => {
      if (this.hasFlag(mode)) {
        modes.push(mode);
      }
    });
    return modes.length > 0 ? modes : void 0;
  }
};
var protocolmessage_default = ProtocolMessage;

// src/common/lib/transport/messagequeue.ts
var MessageQueue = class extends eventemitter_default {
  constructor() {
    super();
    this.messages = [];
  }
  count() {
    return this.messages.length;
  }
  push(message) {
    this.messages.push(message);
  }
  shift() {
    return this.messages.shift();
  }
  last() {
    return this.messages[this.messages.length - 1];
  }
  copyAll() {
    return this.messages.slice();
  }
  append(messages) {
    this.messages.push.apply(this.messages, messages);
  }
  prepend(messages) {
    this.messages.unshift.apply(this.messages, messages);
  }
  completeMessages(serial, count, err) {
    logger_default.logAction(logger_default.LOG_MICRO, "MessageQueue.completeMessages()", "serial = " + serial + "; count = " + count);
    err = err || null;
    const messages = this.messages;
    if (messages.length === 0) {
      throw new Error("MessageQueue.completeMessages(): completeMessages called on any empty MessageQueue");
    }
    const first = messages[0];
    if (first) {
      const startSerial = first.message.msgSerial;
      const endSerial = serial + count;
      if (endSerial > startSerial) {
        const completeMessages = messages.splice(0, endSerial - startSerial);
        for (const message of completeMessages) {
          message.callback(err);
        }
      }
      if (messages.length == 0)
        this.emit("idle");
    }
  }
  completeAllMessages(err) {
    this.completeMessages(0, Number.MAX_SAFE_INTEGER || Number.MAX_VALUE, err);
  }
  resetSendAttempted() {
    for (let msg of this.messages) {
      msg.sendAttempted = false;
    }
  }
  clear() {
    logger_default.logAction(logger_default.LOG_MICRO, "MessageQueue.clear()", "clearing " + this.messages.length + " messages");
    this.messages = [];
    this.emit("idle");
  }
};
var messagequeue_default = MessageQueue;

// src/common/lib/transport/protocol.ts
var PendingMessage = class {
  constructor(message, callback) {
    this.message = message;
    this.callback = callback;
    this.merged = false;
    const action = message.action;
    this.sendAttempted = false;
    this.ackRequired = action == actions2.MESSAGE || action == actions2.PRESENCE;
  }
};
var Protocol = class extends eventemitter_default {
  constructor(transport) {
    super();
    this.transport = transport;
    this.messageQueue = new messagequeue_default();
    transport.on("ack", (serial, count) => {
      this.onAck(serial, count);
    });
    transport.on("nack", (serial, count, err) => {
      this.onNack(serial, count, err);
    });
  }
  onAck(serial, count) {
    logger_default.logAction(logger_default.LOG_MICRO, "Protocol.onAck()", "serial = " + serial + "; count = " + count);
    this.messageQueue.completeMessages(serial, count);
  }
  onNack(serial, count, err) {
    logger_default.logAction(
      logger_default.LOG_ERROR,
      "Protocol.onNack()",
      "serial = " + serial + "; count = " + count + "; err = " + inspectError(err)
    );
    if (!err) {
      err = new ErrorInfo("Unable to send message; channel not responding", 50001, 500);
    }
    this.messageQueue.completeMessages(serial, count, err);
  }
  onceIdle(listener) {
    const messageQueue = this.messageQueue;
    if (messageQueue.count() === 0) {
      listener();
      return;
    }
    messageQueue.once("idle", listener);
  }
  send(pendingMessage) {
    if (pendingMessage.ackRequired) {
      this.messageQueue.push(pendingMessage);
    }
    if (logger_default.shouldLog(logger_default.LOG_MICRO)) {
      logger_default.logAction(
        logger_default.LOG_MICRO,
        "Protocol.send()",
        "sending msg; " + stringify(pendingMessage.message, this.transport.connectionManager.realtime._RealtimePresence)
      );
    }
    pendingMessage.sendAttempted = true;
    this.transport.send(pendingMessage.message);
  }
  getTransport() {
    return this.transport;
  }
  getPendingMessages() {
    return this.messageQueue.copyAll();
  }
  clearPendingMessages() {
    return this.messageQueue.clear();
  }
  finish() {
    const transport = this.transport;
    this.onceIdle(function() {
      transport.disconnect();
    });
  }
};
var protocol_default = Protocol;

// src/common/lib/client/connectionstatechange.ts
var ConnectionStateChange = class {
  constructor(previous, current, retryIn, reason) {
    this.previous = previous;
    this.current = current;
    if (retryIn)
      this.retryIn = retryIn;
    if (reason)
      this.reason = reason;
  }
};
var connectionstatechange_default = ConnectionStateChange;

// src/common/lib/transport/connectionerrors.ts
var ConnectionErrorCodes = {
  DISCONNECTED: 80003,
  SUSPENDED: 80002,
  FAILED: 8e4,
  CLOSING: 80017,
  CLOSED: 80017,
  UNKNOWN_CONNECTION_ERR: 50002,
  UNKNOWN_CHANNEL_ERR: 50001
};
var ConnectionErrors = {
  disconnected: () => ErrorInfo.fromValues({
    statusCode: 400,
    code: ConnectionErrorCodes.DISCONNECTED,
    message: "Connection to server temporarily unavailable"
  }),
  suspended: () => ErrorInfo.fromValues({
    statusCode: 400,
    code: ConnectionErrorCodes.SUSPENDED,
    message: "Connection to server unavailable"
  }),
  failed: () => ErrorInfo.fromValues({
    statusCode: 400,
    code: ConnectionErrorCodes.FAILED,
    message: "Connection failed or disconnected by server"
  }),
  closing: () => ErrorInfo.fromValues({
    statusCode: 400,
    code: ConnectionErrorCodes.CLOSING,
    message: "Connection closing"
  }),
  closed: () => ErrorInfo.fromValues({
    statusCode: 400,
    code: ConnectionErrorCodes.CLOSED,
    message: "Connection closed"
  }),
  unknownConnectionErr: () => ErrorInfo.fromValues({
    statusCode: 500,
    code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,
    message: "Internal connection error"
  }),
  unknownChannelErr: () => ErrorInfo.fromValues({
    statusCode: 500,
    code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,
    message: "Internal channel error"
  })
};
function isRetriable(err) {
  if (!err.statusCode || !err.code || err.statusCode >= 500) {
    return true;
  }
  return Object.values(ConnectionErrorCodes).includes(err.code);
}
var connectionerrors_default = ConnectionErrors;

// src/common/lib/transport/transport.ts
var closeMessage = fromValues3({ action: actions2.CLOSE });
var disconnectMessage = fromValues3({ action: actions2.DISCONNECT });
var Transport = class extends eventemitter_default {
  constructor(connectionManager, auth, params, forceJsonProtocol) {
    super();
    if (forceJsonProtocol) {
      params.format = void 0;
      params.heartbeats = true;
    }
    this.connectionManager = connectionManager;
    connectionManager.registerProposedTransport(this);
    this.auth = auth;
    this.params = params;
    this.timeouts = params.options.timeouts;
    this.format = params.format;
    this.isConnected = false;
    this.isFinished = false;
    this.isDisposed = false;
    this.maxIdleInterval = null;
    this.idleTimer = null;
    this.lastActivity = null;
  }
  connect() {
  }
  close() {
    if (this.isConnected) {
      this.requestClose();
    }
    this.finish("closed", connectionerrors_default.closed());
  }
  disconnect(err) {
    if (this.isConnected) {
      this.requestDisconnect();
    }
    this.finish("disconnected", err || connectionerrors_default.disconnected());
  }
  fail(err) {
    if (this.isConnected) {
      this.requestDisconnect();
    }
    this.finish("failed", err || connectionerrors_default.failed());
  }
  finish(event, err) {
    var _a2;
    if (this.isFinished) {
      return;
    }
    this.isFinished = true;
    this.isConnected = false;
    this.maxIdleInterval = null;
    clearTimeout((_a2 = this.idleTimer) != null ? _a2 : void 0);
    this.idleTimer = null;
    this.emit(event, err);
    this.dispose();
  }
  onProtocolMessage(message) {
    if (logger_default.shouldLog(logger_default.LOG_MICRO)) {
      logger_default.logAction(
        logger_default.LOG_MICRO,
        "Transport.onProtocolMessage()",
        "received on " + this.shortName + ": " + stringify(message, this.connectionManager.realtime._RealtimePresence) + "; connectionId = " + this.connectionManager.connectionId
      );
    }
    this.onActivity();
    switch (message.action) {
      case actions2.HEARTBEAT:
        logger_default.logAction(
          logger_default.LOG_MICRO,
          "Transport.onProtocolMessage()",
          this.shortName + " heartbeat; connectionId = " + this.connectionManager.connectionId
        );
        this.emit("heartbeat", message.id);
        break;
      case actions2.CONNECTED:
        this.onConnect(message);
        this.emit("connected", message.error, message.connectionId, message.connectionDetails, message);
        break;
      case actions2.CLOSED:
        this.onClose(message);
        break;
      case actions2.DISCONNECTED:
        this.onDisconnect(message);
        break;
      case actions2.ACK:
        this.emit("ack", message.msgSerial, message.count);
        break;
      case actions2.NACK:
        this.emit("nack", message.msgSerial, message.count, message.error);
        break;
      case actions2.SYNC:
        this.connectionManager.onChannelMessage(message, this);
        break;
      case actions2.ACTIVATE:
        break;
      case actions2.AUTH:
        this.auth.authorize(function(err) {
          if (err) {
            logger_default.logAction(
              logger_default.LOG_ERROR,
              "Transport.onProtocolMessage()",
              "Ably requested re-authentication, but unable to obtain a new token: " + inspectError(err)
            );
          }
        });
        break;
      case actions2.ERROR:
        logger_default.logAction(
          logger_default.LOG_MINOR,
          "Transport.onProtocolMessage()",
          "received error action; connectionId = " + this.connectionManager.connectionId + "; err = " + Platform.Config.inspect(message.error) + (message.channel ? ", channel: " + message.channel : "")
        );
        if (message.channel === void 0) {
          this.onFatalError(message);
          break;
        }
        this.connectionManager.onChannelMessage(message, this);
        break;
      default:
        this.connectionManager.onChannelMessage(message, this);
    }
  }
  onConnect(message) {
    this.isConnected = true;
    if (!message.connectionDetails) {
      throw new Error("Transport.onConnect(): Connect message recieved without connectionDetails");
    }
    const maxPromisedIdle = message.connectionDetails.maxIdleInterval;
    if (maxPromisedIdle) {
      this.maxIdleInterval = maxPromisedIdle + this.timeouts.realtimeRequestTimeout;
      this.onActivity();
    }
  }
  onDisconnect(message) {
    const err = message && message.error;
    logger_default.logAction(logger_default.LOG_MINOR, "Transport.onDisconnect()", "err = " + inspectError(err));
    this.finish("disconnected", err);
  }
  onFatalError(message) {
    const err = message && message.error;
    logger_default.logAction(logger_default.LOG_MINOR, "Transport.onFatalError()", "err = " + inspectError(err));
    this.finish("failed", err);
  }
  onClose(message) {
    const err = message && message.error;
    logger_default.logAction(logger_default.LOG_MINOR, "Transport.onClose()", "err = " + inspectError(err));
    this.finish("closed", err);
  }
  requestClose() {
    logger_default.logAction(logger_default.LOG_MINOR, "Transport.requestClose()", "");
    this.send(closeMessage);
  }
  requestDisconnect() {
    logger_default.logAction(logger_default.LOG_MINOR, "Transport.requestDisconnect()", "");
    this.send(disconnectMessage);
  }
  ping(id) {
    const msg = { action: actions2.HEARTBEAT };
    if (id)
      msg.id = id;
    this.send(fromValues3(msg));
  }
  dispose() {
    logger_default.logAction(logger_default.LOG_MINOR, "Transport.dispose()", "");
    this.isDisposed = true;
    this.off();
  }
  onActivity() {
    if (!this.maxIdleInterval) {
      return;
    }
    this.lastActivity = this.connectionManager.lastActivity = now();
    this.setIdleTimer(this.maxIdleInterval + 100);
  }
  setIdleTimer(timeout) {
    if (!this.idleTimer) {
      this.idleTimer = setTimeout(() => {
        this.onIdleTimerExpire();
      }, timeout);
    }
  }
  onIdleTimerExpire() {
    if (!this.lastActivity || !this.maxIdleInterval) {
      throw new Error("Transport.onIdleTimerExpire(): lastActivity/maxIdleInterval not set");
    }
    this.idleTimer = null;
    const sinceLast = now() - this.lastActivity;
    const timeRemaining = this.maxIdleInterval - sinceLast;
    if (timeRemaining <= 0) {
      const msg = "No activity seen from realtime in " + sinceLast + "ms; assuming connection has dropped";
      logger_default.logAction(logger_default.LOG_ERROR, "Transport.onIdleTimerExpire()", msg);
      this.disconnect(new ErrorInfo(msg, 80003, 408));
    } else {
      this.setIdleTimer(timeRemaining + 100);
    }
  }
  static tryConnect(transportCtor, connectionManager, auth, transportParams, callback) {
    const transport = new transportCtor(connectionManager, auth, transportParams);
    let transportAttemptTimer;
    const errorCb = function(err) {
      clearTimeout(transportAttemptTimer);
      callback({ event: this.event, error: err });
    };
    const realtimeRequestTimeout = connectionManager.options.timeouts.realtimeRequestTimeout;
    transportAttemptTimer = setTimeout(() => {
      transport.off(["preconnect", "disconnected", "failed"]);
      transport.dispose();
      errorCb.call(
        { event: "disconnected" },
        new ErrorInfo("Timeout waiting for transport to indicate itself viable", 5e4, 500)
      );
    }, realtimeRequestTimeout);
    transport.on(["failed", "disconnected"], errorCb);
    transport.on("preconnect", function() {
      logger_default.logAction(logger_default.LOG_MINOR, "Transport.tryConnect()", "viable transport " + transport);
      clearTimeout(transportAttemptTimer);
      transport.off(["failed", "disconnected"], errorCb);
      callback(null, transport);
    });
    transport.connect();
  }
};
var transport_default = Transport;

// src/common/constants/TransportName.ts
var TransportNames;
((TransportNames2) => {
  TransportNames2.WebSocket = "web_socket";
  TransportNames2.Comet = "comet";
  TransportNames2.XhrStreaming = "xhr_streaming";
  TransportNames2.XhrPolling = "xhr_polling";
})(TransportNames || (TransportNames = {}));

// src/common/lib/transport/connectionmanager.ts
var globalObject2 = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : self;
var haveWebStorage = () => {
  var _a2;
  return typeof Platform.WebStorage !== "undefined" && ((_a2 = Platform.WebStorage) == null ? void 0 : _a2.localSupported);
};
var haveSessionStorage = () => {
  var _a2;
  return typeof Platform.WebStorage !== "undefined" && ((_a2 = Platform.WebStorage) == null ? void 0 : _a2.sessionSupported);
};
var noop4 = function() {
};
var transportPreferenceName = "ably-transport-preference";
var sessionRecoveryName = "ably-connection-recovery";
function getSessionRecoverData() {
  var _a2, _b;
  return haveSessionStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.getSession) == null ? void 0 : _b.call(_a2, sessionRecoveryName));
}
function setSessionRecoverData(value) {
  var _a2, _b;
  return haveSessionStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.setSession) == null ? void 0 : _b.call(_a2, sessionRecoveryName, value));
}
function clearSessionRecoverData() {
  var _a2, _b;
  return haveSessionStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.removeSession) == null ? void 0 : _b.call(_a2, sessionRecoveryName));
}
function betterTransportThan(a, b) {
  return arrIndexOf(Platform.Defaults.transportPreferenceOrder, a.shortName) > arrIndexOf(Platform.Defaults.transportPreferenceOrder, b.shortName);
}
function bundleWith(dest, src, maxSize) {
  let action;
  if (dest.channel !== src.channel) {
    return false;
  }
  if ((action = dest.action) !== actions2.PRESENCE && action !== actions2.MESSAGE) {
    return false;
  }
  if (action !== src.action) {
    return false;
  }
  const kind = action === actions2.PRESENCE ? "presence" : "messages", proposed = dest[kind].concat(src[kind]), size = getMessagesSize(proposed);
  if (size > maxSize) {
    return false;
  }
  if (!allSame(proposed, "clientId")) {
    return false;
  }
  if (!arrEvery(proposed, function(msg) {
    return !msg.id;
  })) {
    return false;
  }
  dest[kind] = proposed;
  return true;
}
function decodeRecoveryKey(recoveryKey) {
  try {
    return JSON.parse(recoveryKey);
  } catch (e) {
    return null;
  }
}
var TransportParams = class {
  constructor(options, host, mode, connectionKey) {
    this.options = options;
    this.host = host;
    this.mode = mode;
    this.connectionKey = connectionKey;
    this.format = options.useBinaryProtocol ? "msgpack" /* msgpack */ : "json" /* json */;
  }
  getConnectParams(authParams) {
    const params = authParams ? copy(authParams) : {};
    const options = this.options;
    switch (this.mode) {
      case "upgrade":
        params.upgrade = this.connectionKey;
        break;
      case "resume":
        params.resume = this.connectionKey;
        break;
      case "recover": {
        const recoveryContext = decodeRecoveryKey(options.recover);
        if (recoveryContext) {
          params.recover = recoveryContext.connectionKey;
        }
        break;
      }
      default:
    }
    if (options.clientId !== void 0) {
      params.clientId = options.clientId;
    }
    if (options.echoMessages === false) {
      params.echo = "false";
    }
    if (this.format !== void 0) {
      params.format = this.format;
    }
    if (this.stream !== void 0) {
      params.stream = this.stream;
    }
    if (this.heartbeats !== void 0) {
      params.heartbeats = this.heartbeats;
    }
    params.v = defaults_default.protocolVersion;
    params.agent = getAgentString(this.options);
    if (options.transportParams !== void 0) {
      mixin(params, options.transportParams);
    }
    return params;
  }
  toString() {
    let result = "[mode=" + this.mode;
    if (this.host) {
      result += ",host=" + this.host;
    }
    if (this.connectionKey) {
      result += ",connectionKey=" + this.connectionKey;
    }
    if (this.format) {
      result += ",format=" + this.format;
    }
    result += "]";
    return result;
  }
};
var ConnectionManager = class _ConnectionManager extends eventemitter_default {
  constructor(realtime, options) {
    super();
    this.supportedTransports = {};
    this.disconnectedRetryCount = 0;
    this.pendingChannelMessagesState = { isProcessing: false, queue: [] };
    this.realtime = realtime;
    this.initTransports();
    this.options = options;
    const timeouts = options.timeouts;
    const connectingTimeout = timeouts.preferenceConnectTimeout + timeouts.realtimeRequestTimeout;
    this.states = {
      initialized: {
        state: "initialized",
        terminal: false,
        queueEvents: true,
        sendEvents: false,
        failState: "disconnected"
      },
      connecting: {
        state: "connecting",
        terminal: false,
        queueEvents: true,
        sendEvents: false,
        retryDelay: connectingTimeout,
        failState: "disconnected"
      },
      connected: {
        state: "connected",
        terminal: false,
        queueEvents: false,
        sendEvents: true,
        failState: "disconnected"
      },
      synchronizing: {
        state: "connected",
        terminal: false,
        queueEvents: true,
        sendEvents: false,
        forceQueueEvents: true,
        failState: "disconnected"
      },
      disconnected: {
        state: "disconnected",
        terminal: false,
        queueEvents: true,
        sendEvents: false,
        retryDelay: timeouts.disconnectedRetryTimeout,
        failState: "disconnected"
      },
      suspended: {
        state: "suspended",
        terminal: false,
        queueEvents: false,
        sendEvents: false,
        retryDelay: timeouts.suspendedRetryTimeout,
        failState: "suspended"
      },
      closing: {
        state: "closing",
        terminal: false,
        queueEvents: false,
        sendEvents: false,
        retryDelay: timeouts.realtimeRequestTimeout,
        failState: "closed"
      },
      closed: { state: "closed", terminal: true, queueEvents: false, sendEvents: false, failState: "closed" },
      failed: { state: "failed", terminal: true, queueEvents: false, sendEvents: false, failState: "failed" }
    };
    this.state = this.states.initialized;
    this.errorReason = null;
    this.queuedMessages = new messagequeue_default();
    this.msgSerial = 0;
    this.connectionDetails = void 0;
    this.connectionId = void 0;
    this.connectionKey = void 0;
    this.connectionStateTtl = timeouts.connectionStateTtl;
    this.maxIdleInterval = null;
    this.transports = intersect(options.transports || defaults_default.defaultTransports, this.supportedTransports);
    this.baseTransport = intersect(defaults_default.baseTransportOrder, this.transports)[0];
    this.upgradeTransports = intersect(this.transports, defaults_default.upgradeTransports);
    this.transportPreference = null;
    this.httpHosts = defaults_default.getHosts(options);
    this.activeProtocol = null;
    this.proposedTransports = [];
    this.pendingTransports = [];
    this.host = null;
    this.lastAutoReconnectAttempt = null;
    this.lastActivity = null;
    this.forceFallbackHost = false;
    this.connectCounter = 0;
    logger_default.logAction(logger_default.LOG_MINOR, "Realtime.ConnectionManager()", "started");
    logger_default.logAction(
      logger_default.LOG_MICRO,
      "Realtime.ConnectionManager()",
      "requested transports = [" + (options.transports || defaults_default.defaultTransports) + "]"
    );
    logger_default.logAction(
      logger_default.LOG_MICRO,
      "Realtime.ConnectionManager()",
      "available transports = [" + this.transports + "]"
    );
    logger_default.logAction(logger_default.LOG_MICRO, "Realtime.ConnectionManager()", "http hosts = [" + this.httpHosts + "]");
    if (!this.transports.length) {
      const msg = "no requested transports available";
      logger_default.logAction(logger_default.LOG_ERROR, "realtime.ConnectionManager()", msg);
      throw new Error(msg);
    }
    const addEventListener = Platform.Config.addEventListener;
    if (addEventListener) {
      if (haveSessionStorage() && typeof options.recover === "function") {
        addEventListener("beforeunload", this.persistConnection.bind(this));
      }
      if (options.closeOnUnload === true) {
        addEventListener("beforeunload", () => {
          logger_default.logAction(
            logger_default.LOG_MAJOR,
            "Realtime.ConnectionManager()",
            "beforeunload event has triggered the connection to close as closeOnUnload is true"
          );
          this.requestState({ state: "closing" });
        });
      }
      addEventListener("online", () => {
        if (this.state == this.states.disconnected || this.state == this.states.suspended) {
          logger_default.logAction(
            logger_default.LOG_MINOR,
            "ConnectionManager caught browser \u2018online\u2019 event",
            "reattempting connection"
          );
          this.requestState({ state: "connecting" });
        } else if (this.state == this.states.connecting) {
          this.pendingTransports.forEach(function(transport) {
            transport.off();
          });
          this.disconnectAllTransports();
          this.startConnect();
        }
      });
      addEventListener("offline", () => {
        if (this.state == this.states.connected) {
          logger_default.logAction(
            logger_default.LOG_MINOR,
            "ConnectionManager caught browser \u2018offline\u2019 event",
            "disconnecting active transport"
          );
          this.disconnectAllTransports();
        }
      });
    }
  }
  /*********************
   * transport management
   *********************/
  // Used by tests
  static supportedTransports(additionalImplementations) {
    const storage = { supportedTransports: {} };
    this.initTransports(additionalImplementations, storage);
    return storage.supportedTransports;
  }
  static initTransports(additionalImplementations, storage) {
    const implementations = __spreadValues(__spreadValues({}, Platform.Transports.bundledImplementations), additionalImplementations);
    const initialiseWebSocketTransport = implementations[TransportNames.WebSocket];
    if (initialiseWebSocketTransport) {
      initialiseWebSocketTransport(storage);
    }
    arrForEach(Platform.Transports.order, function(transportName) {
      const initFn = implementations[transportName];
      if (initFn) {
        initFn(storage);
      }
    });
  }
  initTransports() {
    _ConnectionManager.initTransports(this.realtime._additionalTransportImplementations, this);
  }
  createTransportParams(host, mode) {
    return new TransportParams(this.options, host, mode, this.connectionKey);
  }
  getTransportParams(callback) {
    const decideMode = (modeCb) => {
      if (this.connectionKey) {
        modeCb("resume");
        return;
      }
      if (typeof this.options.recover === "string") {
        modeCb("recover");
        return;
      }
      const recoverFn = this.options.recover, lastSessionData = getSessionRecoverData();
      if (lastSessionData && typeof recoverFn === "function") {
        logger_default.logAction(
          logger_default.LOG_MINOR,
          "ConnectionManager.getTransportParams()",
          "Calling clientOptions-provided recover function with last session data"
        );
        recoverFn(lastSessionData, (shouldRecover) => {
          if (shouldRecover) {
            this.options.recover = lastSessionData.recoveryKey;
            modeCb("recover");
          } else {
            modeCb("clean");
          }
        });
        return;
      }
      modeCb("clean");
    };
    decideMode((mode) => {
      const transportParams = this.createTransportParams(null, mode);
      if (mode === "recover") {
        logger_default.logAction(
          logger_default.LOG_MINOR,
          "ConnectionManager.getTransportParams()",
          "Transport recovery mode = recover; recoveryKey = " + this.options.recover
        );
        const recoveryContext = decodeRecoveryKey(this.options.recover);
        if (recoveryContext) {
          this.msgSerial = recoveryContext.msgSerial;
        }
      } else {
        logger_default.logAction(
          logger_default.LOG_MINOR,
          "ConnectionManager.getTransportParams()",
          "Transport params = " + transportParams.toString()
        );
      }
      callback(transportParams);
    });
  }
  /**
   * Attempt to connect using a given transport
   * @param transportParams
   * @param candidate, the transport to try
   * @param callback
   */
  tryATransport(transportParams, candidate, callback) {
    logger_default.logAction(logger_default.LOG_MICRO, "ConnectionManager.tryATransport()", "trying " + candidate);
    transport_default.tryConnect(
      this.supportedTransports[candidate],
      this,
      this.realtime.auth,
      transportParams,
      (wrappedErr, transport) => {
        const state = this.state;
        if (state == this.states.closing || state == this.states.closed || state == this.states.failed) {
          if (transport) {
            logger_default.logAction(
              logger_default.LOG_MINOR,
              "ConnectionManager.tryATransport()",
              "connection " + state.state + " while we were attempting the transport; closing " + transport
            );
            transport.close();
          }
          callback(true);
          return;
        }
        if (wrappedErr) {
          logger_default.logAction(
            logger_default.LOG_MINOR,
            "ConnectionManager.tryATransport()",
            "transport " + candidate + " " + wrappedErr.event + ", err: " + wrappedErr.error.toString()
          );
          if (auth_default.isTokenErr(wrappedErr.error) && !(this.errorReason && auth_default.isTokenErr(this.errorReason))) {
            this.errorReason = wrappedErr.error;
            this.realtime.auth._forceNewToken(null, null, (err) => {
              if (err) {
                this.actOnErrorFromAuthorize(err);
                return;
              }
              this.tryATransport(transportParams, candidate, callback);
            });
          } else if (wrappedErr.event === "failed") {
            this.notifyState({ state: "failed", error: wrappedErr.error });
            callback(true);
          } else if (wrappedErr.event === "disconnected") {
            if (!isRetriable(wrappedErr.error)) {
              this.notifyState({ state: this.states.connecting.failState, error: wrappedErr.error });
              callback(true);
            } else {
              callback(false);
            }
          }
          return;
        }
        logger_default.logAction(
          logger_default.LOG_MICRO,
          "ConnectionManager.tryATransport()",
          "viable transport " + candidate + "; setting pending"
        );
        this.setTransportPending(transport, transportParams);
        callback(null, transport);
      }
    );
  }
  /**
   * Called when a transport is indicated to be viable, and the ConnectionManager
   * expects to activate this transport as soon as it is connected.
   * @param transport
   * @param transportParams
   */
  setTransportPending(transport, transportParams) {
    const mode = transportParams.mode;
    logger_default.logAction(
      logger_default.LOG_MINOR,
      "ConnectionManager.setTransportPending()",
      "transport = " + transport + "; mode = " + mode
    );
    arrDeleteValue(this.proposedTransports, transport);
    this.pendingTransports.push(transport);
    const optimalTransport = Platform.Defaults.transportPreferenceOrder[Platform.Defaults.transportPreferenceOrder.length - 1];
    transport.once("connected", (error, connectionId, connectionDetails) => {
      if (mode == "upgrade" && this.activeProtocol) {
        if (transport.shortName !== optimalTransport && arrIn(this.getUpgradePossibilities(), optimalTransport) && this.activeProtocol) {
          setTimeout(() => {
            this.scheduleTransportActivation(error, transport, connectionId, connectionDetails);
          }, this.options.timeouts.parallelUpgradeDelay);
        } else {
          this.scheduleTransportActivation(error, transport, connectionId, connectionDetails);
        }
      } else {
        this.activateTransport(error, transport, connectionId, connectionDetails);
        Platform.Config.nextTick(() => {
          this.connectImpl(transportParams);
        });
      }
      if (mode === "recover" && this.options.recover) {
        delete this.options.recover;
        this.unpersistConnection();
      }
    });
    const self2 = this;
    transport.on(["disconnected", "closed", "failed"], function(error) {
      self2.deactivateTransport(transport, this.event, error);
    });
    this.emit("transport.pending", transport);
  }
  /**
   * Called when an upgrade transport is connected,
   * to schedule the activation of that transport.
   * @param error
   * @param transport
   * @param connectionId
   * @param connectionDetails
   */
  scheduleTransportActivation(error, transport, connectionId, connectionDetails) {
    const currentTransport = this.activeProtocol && this.activeProtocol.getTransport(), abandon = () => {
      transport.disconnect();
      arrDeleteValue(this.pendingTransports, transport);
    };
    if (this.state !== this.states.connected && this.state !== this.states.connecting) {
      logger_default.logAction(
        logger_default.LOG_MINOR,
        "ConnectionManager.scheduleTransportActivation()",
        "Current connection state (" + this.state.state + (this.state === this.states.synchronizing ? ", but with an upgrade already in progress" : "") + ") is not valid to upgrade in; abandoning upgrade to " + transport.shortName
      );
      abandon();
      return;
    }
    if (currentTransport && !betterTransportThan(transport, currentTransport)) {
      logger_default.logAction(
        logger_default.LOG_MINOR,
        "ConnectionManager.scheduleTransportActivation()",
        "Proposed transport " + transport.shortName + " is no better than current active transport " + currentTransport.shortName + " - abandoning upgrade"
      );
      abandon();
      return;
    }
    logger_default.logAction(
      logger_default.LOG_MINOR,
      "ConnectionManager.scheduleTransportActivation()",
      "Scheduling transport upgrade; transport = " + transport
    );
    let oldProtocol = null;
    if (!transport.isConnected) {
      logger_default.logAction(
        logger_default.LOG_MINOR,
        "ConnectionManager.scheduleTransportActivation()",
        "Proposed transport " + transport.shortName + "is no longer connected; abandoning upgrade"
      );
      abandon();
      return;
    }
    if (this.state === this.states.connected) {
      logger_default.logAction(
        logger_default.LOG_MICRO,
        "ConnectionManager.scheduleTransportActivation()",
        "Currently connected, so temporarily pausing events until the upgrade is complete"
      );
      this.state = this.states.synchronizing;
      oldProtocol = this.activeProtocol;
    } else if (this.state !== this.states.connecting) {
      logger_default.logAction(
        logger_default.LOG_MINOR,
        "ConnectionManager.scheduleTransportActivation()",
        "Current connection state (" + this.state.state + (this.state === this.states.synchronizing ? ", but with an upgrade already in progress" : "") + ") is not valid to upgrade in; abandoning upgrade to " + transport.shortName
      );
      abandon();
      return;
    }
    logger_default.logAction(
      logger_default.LOG_MINOR,
      "ConnectionManager.scheduleTransportActivation()",
      "Syncing transport; transport = " + transport
    );
    const finishUpgrade = () => {
      logger_default.logAction(
        logger_default.LOG_MINOR,
        "ConnectionManager.scheduleTransportActivation()",
        "Activating transport; transport = " + transport
      );
      transport.send(
        fromValues3({
          action: actions2.ACTIVATE
        })
      );
      this.activateTransport(error, transport, connectionId, connectionDetails);
      if (this.state === this.states.synchronizing) {
        logger_default.logAction(
          logger_default.LOG_MICRO,
          "ConnectionManager.scheduleTransportActivation()",
          "Pre-upgrade protocol idle, sending queued messages on upgraded transport; transport = " + transport
        );
        this.state = this.states.connected;
      } else {
        logger_default.logAction(
          logger_default.LOG_MINOR,
          "ConnectionManager.scheduleTransportActivation()",
          "Pre-upgrade protocol idle, but state is now " + this.state.state + ", so leaving unchanged"
        );
      }
      if (this.state.sendEvents) {
        this.sendQueuedMessages();
      }
    };
    if (oldProtocol) {
      oldProtocol.onceIdle(finishUpgrade);
    } else {
      finishUpgrade();
    }
  }
  /**
   * Called when a transport is connected, and the connectionmanager decides that
   * it will now be the active transport. Returns whether or not it activated
   * the transport (if the connection is closing/closed it will choose not to).
   * @param transport the transport instance
   * @param connectionId the id of the new active connection
   * @param connectionDetails the details of the new active connection
   */
  activateTransport(error, transport, connectionId, connectionDetails) {
    logger_default.logAction(logger_default.LOG_MINOR, "ConnectionManager.activateTransport()", "transport = " + transport);
    if (error) {
      logger_default.logAction(logger_default.LOG_ERROR, "ConnectionManager.activateTransport()", "error = " + error);
    }
    if (connectionId) {
      logger_default.logAction(logger_default.LOG_MICRO, "ConnectionManager.activateTransport()", "connectionId =  " + connectionId);
    }
    if (connectionDetails) {
      logger_default.logAction(
        logger_default.LOG_MICRO,
        "ConnectionManager.activateTransport()",
        "connectionDetails =  " + JSON.stringify(connectionDetails)
      );
    }
    this.persistTransportPreference(transport);
    const existingState = this.state, connectedState = this.states.connected.state;
    logger_default.logAction(
      logger_default.LOG_MINOR,
      "ConnectionManager.activateTransport()",
      "current state = " + existingState.state
    );
    if (existingState.state == this.states.closing.state || existingState.state == this.states.closed.state || existingState.state == this.states.failed.state) {
      logger_default.logAction(
        logger_default.LOG_MINOR,
        "ConnectionManager.activateTransport()",
        "Disconnecting transport and abandoning"
      );
      transport.disconnect();
      return false;
    }
    arrDeleteValue(this.pendingTransports, transport);
    if (!transport.isConnected) {
      logger_default.logAction(
        logger_default.LOG_MINOR,
        "ConnectionManager.activateTransport()",
        "Declining to activate transport " + transport + " since it appears to no longer be connected"
      );
      return false;
    }
    const existingActiveProtocol = this.activeProtocol;
    this.activeProtocol = new protocol_default(transport);
    this.host = transport.params.host;
    const connectionKey = connectionDetails.connectionKey;
    if (connectionKey && this.connectionKey != connectionKey) {
      this.setConnection(connectionId, connectionDetails, !!error);
    }
    this.onConnectionDetailsUpdate(connectionDetails, transport);
    Platform.Config.nextTick(() => {
      transport.on(
        "connected",
        (connectedErr, _connectionId, connectionDetails2) => {
          this.onConnectionDetailsUpdate(connectionDetails2, transport);
          this.emit("update", new connectionstatechange_default(connectedState, connectedState, null, connectedErr));
        }
      );
    });
    if (existingState.state === this.states.connected.state) {
      if (error) {
        this.errorReason = this.realtime.connection.errorReason = error;
        this.emit("update", new connectionstatechange_default(connectedState, connectedState, null, error));
      }
    } else {
      this.notifyState({ state: "connected", error });
      this.errorReason = this.realtime.connection.errorReason = error || null;
    }
    this.emit("transport.active", transport);
    if (existingActiveProtocol) {
      if (existingActiveProtocol.messageQueue.count() > 0) {
        logger_default.logAction(
          logger_default.LOG_ERROR,
          "ConnectionManager.activateTransport()",
          "Previous active protocol (for transport " + existingActiveProtocol.transport.shortName + ", new one is " + transport.shortName + ") finishing with " + existingActiveProtocol.messageQueue.count() + " messages still pending"
        );
      }
      if (existingActiveProtocol.transport === transport) {
        const msg = "Assumption violated: activating a transport that was also the transport for the previous active protocol; transport = " + transport.shortName + "; stack = " + new Error().stack;
        logger_default.logAction(logger_default.LOG_ERROR, "ConnectionManager.activateTransport()", msg);
      } else {
        existingActiveProtocol.finish();
      }
    }
    safeArrForEach(this.pendingTransports, (pendingTransport) => {
      if (pendingTransport === transport) {
        const msg = "Assumption violated: activating a transport that is still marked as a pending transport; transport = " + transport.shortName + "; stack = " + new Error().stack;
        logger_default.logAction(logger_default.LOG_ERROR, "ConnectionManager.activateTransport()", msg);
        arrDeleteValue(this.pendingTransports, transport);
      } else {
        pendingTransport.disconnect();
      }
    });
    safeArrForEach(this.proposedTransports, (proposedTransport) => {
      if (proposedTransport === transport) {
        logger_default.logAction(
          logger_default.LOG_ERROR,
          "ConnectionManager.activateTransport()",
          "Assumption violated: activating a transport that is still marked as a proposed transport; transport = " + transport.shortName + "; stack = " + new Error().stack
        );
        arrDeleteValue(this.proposedTransports, transport);
      } else {
        proposedTransport.dispose();
      }
    });
    return true;
  }
  /**
   * Called when a transport is no longer the active transport. This can occur
   * in any transport connection state.
   * @param transport
   */
  deactivateTransport(transport, state, error) {
    const currentProtocol = this.activeProtocol, wasActive = currentProtocol && currentProtocol.getTransport() === transport, wasPending = arrDeleteValue(this.pendingTransports, transport), wasProposed = arrDeleteValue(this.proposedTransports, transport), noTransportsScheduledForActivation = this.noTransportsScheduledForActivation();
    logger_default.logAction(logger_default.LOG_MINOR, "ConnectionManager.deactivateTransport()", "transport = " + transport);
    logger_default.logAction(
      logger_default.LOG_MINOR,
      "ConnectionManager.deactivateTransport()",
      "state = " + state + (wasActive ? "; was active" : wasPending ? "; was pending" : wasProposed ? "; was proposed" : "") + (noTransportsScheduledForActivation ? "" : "; another transport is scheduled for activation")
    );
    if (error && error.message)
      logger_default.logAction(logger_default.LOG_MICRO, "ConnectionManager.deactivateTransport()", "reason =  " + error.message);
    if (wasActive) {
      logger_default.logAction(
        logger_default.LOG_MICRO,
        "ConnectionManager.deactivateTransport()",
        "Getting, clearing, and requeuing " + this.activeProtocol.messageQueue.count() + " pending messages"
      );
      this.queuePendingMessages(currentProtocol.getPendingMessages());
      Platform.Config.nextTick(function() {
        currentProtocol.clearPendingMessages();
      });
      this.activeProtocol = this.host = null;
    }
    this.emit("transport.inactive", transport);
    if (wasActive && noTransportsScheduledForActivation || wasActive && state === "failed" || state === "closed" || currentProtocol === null && wasPending && this.pendingTransports.length === 0) {
      if (state === "disconnected" && error && error.statusCode > 500 && this.httpHosts.length > 1) {
        this.unpersistTransportPreference();
        this.forceFallbackHost = true;
        this.notifyState({ state, error, retryImmediately: true });
        return;
      }
      const newConnectionState = state === "failed" && auth_default.isTokenErr(error) ? "disconnected" : state;
      this.notifyState({ state: newConnectionState, error });
      return;
    }
    if (wasActive && state === "disconnected" && this.state !== this.states.synchronizing) {
      logger_default.logAction(
        logger_default.LOG_MICRO,
        "ConnectionManager.deactivateTransport()",
        "wasActive but another transport is connected and scheduled for activation, so going into the connecting state until it activates"
      );
      this.startSuspendTimer();
      this.startTransitionTimer(this.states.connecting);
      this.notifyState({ state: "connecting", error });
    }
  }
  /* Helper that returns true if there are no transports which are pending,
   * have been connected, and are just waiting for onceNoPending to fire before
   * being activated */
  noTransportsScheduledForActivation() {
    return isEmpty(this.pendingTransports) || this.pendingTransports.every(function(transport) {
      return !transport.isConnected;
    });
  }
  setConnection(connectionId, connectionDetails, hasConnectionError) {
    const prevConnId = this.connectionId, connIdChanged = prevConnId && prevConnId !== connectionId, recoverFailure = !prevConnId && hasConnectionError;
    if (connIdChanged || recoverFailure) {
      logger_default.logAction(logger_default.LOG_MINOR, "ConnectionManager.setConnection()", "Resetting msgSerial");
      this.msgSerial = 0;
      this.queuedMessages.resetSendAttempted();
    }
    if (this.connectionId !== connectionId) {
      logger_default.logAction(
        logger_default.LOG_MINOR,
        "ConnectionManager.setConnection()",
        "New connectionId; reattaching any attached channels"
      );
    }
    this.realtime.connection.id = this.connectionId = connectionId;
    this.realtime.connection.key = this.connectionKey = connectionDetails.connectionKey;
  }
  clearConnection() {
    this.realtime.connection.id = this.connectionId = void 0;
    this.realtime.connection.key = this.connectionKey = void 0;
    this.msgSerial = 0;
    this.unpersistConnection();
  }
  createRecoveryKey() {
    if (!this.connectionKey) {
      return null;
    }
    return JSON.stringify({
      connectionKey: this.connectionKey,
      msgSerial: this.msgSerial,
      channelSerials: this.realtime.channels.channelSerials()
    });
  }
  checkConnectionStateFreshness() {
    if (!this.lastActivity || !this.connectionId) {
      return;
    }
    const sinceLast = now() - this.lastActivity;
    if (sinceLast > this.connectionStateTtl + this.maxIdleInterval) {
      logger_default.logAction(
        logger_default.LOG_MINOR,
        "ConnectionManager.checkConnectionStateFreshness()",
        "Last known activity from realtime was " + sinceLast + "ms ago; discarding connection state"
      );
      this.clearConnection();
      this.states.connecting.failState = "suspended";
    }
  }
  /**
   * Called when the connectionmanager wants to persist transport
   * state for later recovery. Only applicable in the browser context.
   */
  persistConnection() {
    if (haveSessionStorage()) {
      const recoveryKey = this.createRecoveryKey();
      if (recoveryKey) {
        setSessionRecoverData({
          recoveryKey,
          disconnectedAt: now(),
          location: globalObject2.location,
          clientId: this.realtime.auth.clientId
        });
      }
    }
  }
  /**
   * Called when the connectionmanager wants to persist transport
   * state for later recovery. Only applicable in the browser context.
   */
  unpersistConnection() {
    clearSessionRecoverData();
  }
  /*********************
   * state management
   *********************/
  getError() {
    return this.errorReason || this.getStateError();
  }
  getStateError() {
    var _a2, _b;
    return (_b = (_a2 = connectionerrors_default)[this.state.state]) == null ? void 0 : _b.call(_a2);
  }
  activeState() {
    return this.state.queueEvents || this.state.sendEvents;
  }
  enactStateChange(stateChange) {
    const logLevel = stateChange.current === "failed" ? logger_default.LOG_ERROR : logger_default.LOG_MAJOR;
    logger_default.logAction(
      logLevel,
      "Connection state",
      stateChange.current + (stateChange.reason ? "; reason: " + stateChange.reason : "")
    );
    logger_default.logAction(
      logger_default.LOG_MINOR,
      "ConnectionManager.enactStateChange",
      "setting new state: " + stateChange.current + "; reason = " + (stateChange.reason && stateChange.reason.message)
    );
    const newState = this.state = this.states[stateChange.current];
    if (stateChange.reason) {
      this.errorReason = stateChange.reason;
      this.realtime.connection.errorReason = stateChange.reason;
    }
    if (newState.terminal || newState.state === "suspended") {
      this.clearConnection();
    }
    this.emit("connectionstate", stateChange);
  }
  /****************************************
   * ConnectionManager connection lifecycle
   ****************************************/
  startTransitionTimer(transitionState) {
    logger_default.logAction(
      logger_default.LOG_MINOR,
      "ConnectionManager.startTransitionTimer()",
      "transitionState: " + transitionState.state
    );
    if (this.transitionTimer) {
      logger_default.logAction(logger_default.LOG_MINOR, "ConnectionManager.startTransitionTimer()", "clearing already-running timer");
      clearTimeout(this.transitionTimer);
    }
    this.transitionTimer = setTimeout(() => {
      if (this.transitionTimer) {
        this.transitionTimer = null;
        logger_default.logAction(
          logger_default.LOG_MINOR,
          "ConnectionManager " + transitionState.state + " timer expired",
          "requesting new state: " + transitionState.failState
        );
        this.notifyState({ state: transitionState.failState });
      }
    }, transitionState.retryDelay);
  }
  cancelTransitionTimer() {
    logger_default.logAction(logger_default.LOG_MINOR, "ConnectionManager.cancelTransitionTimer()", "");
    if (this.transitionTimer) {
      clearTimeout(this.transitionTimer);
      this.transitionTimer = null;
    }
  }
  startSuspendTimer() {
    if (this.suspendTimer)
      return;
    this.suspendTimer = setTimeout(() => {
      if (this.suspendTimer) {
        this.suspendTimer = null;
        logger_default.logAction(
          logger_default.LOG_MINOR,
          "ConnectionManager suspend timer expired",
          "requesting new state: suspended"
        );
        this.states.connecting.failState = "suspended";
        this.notifyState({ state: "suspended" });
      }
    }, this.connectionStateTtl);
  }
  checkSuspendTimer(state) {
    if (state !== "disconnected" && state !== "suspended" && state !== "connecting")
      this.cancelSuspendTimer();
  }
  cancelSuspendTimer() {
    this.states.connecting.failState = "disconnected";
    if (this.suspendTimer) {
      clearTimeout(this.suspendTimer);
      this.suspendTimer = null;
    }
  }
  startRetryTimer(interval) {
    this.retryTimer = setTimeout(() => {
      logger_default.logAction(logger_default.LOG_MINOR, "ConnectionManager retry timer expired", "retrying");
      this.retryTimer = null;
      this.requestState({ state: "connecting" });
    }, interval);
  }
  cancelRetryTimer() {
    if (this.retryTimer) {
      clearTimeout(this.retryTimer);
      this.retryTimer = null;
    }
  }
  notifyState(indicated) {
    var _a2, _b;
    const state = indicated.state;
    const retryImmediately = state === "disconnected" && (this.state === this.states.connected || this.state === this.states.synchronizing || indicated.retryImmediately || this.state === this.states.connecting && indicated.error && auth_default.isTokenErr(indicated.error) && !(this.errorReason && auth_default.isTokenErr(this.errorReason)));
    logger_default.logAction(
      logger_default.LOG_MINOR,
      "ConnectionManager.notifyState()",
      "new state: " + state + (retryImmediately ? "; will retry connection immediately" : "")
    );
    if (state == this.state.state)
      return;
    this.cancelTransitionTimer();
    this.cancelRetryTimer();
    this.checkSuspendTimer(indicated.state);
    if (state === "suspended" || state === "connected") {
      this.disconnectedRetryCount = 0;
    }
    if (this.state.terminal)
      return;
    const newState = this.states[indicated.state];
    let retryDelay = newState.retryDelay;
    if (newState.state === "disconnected") {
      this.disconnectedRetryCount++;
      retryDelay = getRetryTime(newState.retryDelay, this.disconnectedRetryCount);
    }
    const change = new connectionstatechange_default(
      this.state.state,
      newState.state,
      retryDelay,
      indicated.error || ((_b = (_a2 = connectionerrors_default)[newState.state]) == null ? void 0 : _b.call(_a2))
    );
    if (retryImmediately) {
      const autoReconnect = () => {
        if (this.state === this.states.disconnected) {
          this.lastAutoReconnectAttempt = now();
          this.requestState({ state: "connecting" });
        }
      };
      const sinceLast = this.lastAutoReconnectAttempt && now() - this.lastAutoReconnectAttempt + 1;
      if (sinceLast && sinceLast < 1e3) {
        logger_default.logAction(
          logger_default.LOG_MICRO,
          "ConnectionManager.notifyState()",
          "Last reconnect attempt was only " + sinceLast + "ms ago, waiting another " + (1e3 - sinceLast) + "ms before trying again"
        );
        setTimeout(autoReconnect, 1e3 - sinceLast);
      } else {
        Platform.Config.nextTick(autoReconnect);
      }
    } else if (state === "disconnected" || state === "suspended") {
      this.startRetryTimer(retryDelay);
    }
    if (state === "disconnected" && !retryImmediately || state === "suspended" || newState.terminal) {
      Platform.Config.nextTick(() => {
        this.disconnectAllTransports();
      });
    }
    if (state == "connected" && !this.activeProtocol) {
      logger_default.logAction(
        logger_default.LOG_ERROR,
        "ConnectionManager.notifyState()",
        "Broken invariant: attempted to go into connected state, but there is no active protocol"
      );
    }
    this.enactStateChange(change);
    if (this.state.sendEvents) {
      this.sendQueuedMessages();
    } else if (!this.state.queueEvents) {
      this.realtime.channels.propogateConnectionInterruption(state, change.reason);
      this.failQueuedMessages(change.reason);
    }
  }
  requestState(request) {
    var _a2, _b;
    const state = request.state;
    logger_default.logAction(
      logger_default.LOG_MINOR,
      "ConnectionManager.requestState()",
      "requested state: " + state + "; current state: " + this.state.state
    );
    if (state == this.state.state)
      return;
    this.cancelTransitionTimer();
    this.cancelRetryTimer();
    this.checkSuspendTimer(state);
    if (state == "connecting" && this.state.state == "connected")
      return;
    if (state == "closing" && this.state.state == "closed")
      return;
    const newState = this.states[state], change = new connectionstatechange_default(
      this.state.state,
      newState.state,
      null,
      request.error || ((_b = (_a2 = connectionerrors_default)[newState.state]) == null ? void 0 : _b.call(_a2))
    );
    this.enactStateChange(change);
    if (state == "connecting") {
      Platform.Config.nextTick(() => {
        this.startConnect();
      });
    }
    if (state == "closing") {
      this.closeImpl();
    }
  }
  startConnect() {
    if (this.state !== this.states.connecting) {
      logger_default.logAction(
        logger_default.LOG_MINOR,
        "ConnectionManager.startConnect()",
        "Must be in connecting state to connect, but was " + this.state.state
      );
      return;
    }
    const auth = this.realtime.auth;
    const connectCount = ++this.connectCounter;
    const connect = () => {
      this.checkConnectionStateFreshness();
      this.getTransportParams((transportParams) => {
        if (transportParams.mode === "recover" && transportParams.options.recover) {
          const recoveryContext = decodeRecoveryKey(transportParams.options.recover);
          if (recoveryContext) {
            this.realtime.channels.recoverChannels(recoveryContext.channelSerials);
          }
        }
        if (connectCount !== this.connectCounter) {
          return;
        }
        this.connectImpl(transportParams, connectCount);
      });
    };
    logger_default.logAction(logger_default.LOG_MINOR, "ConnectionManager.startConnect()", "starting connection");
    this.startSuspendTimer();
    this.startTransitionTimer(this.states.connecting);
    if (auth.method === "basic") {
      connect();
    } else {
      const authCb = (err) => {
        if (connectCount !== this.connectCounter) {
          return;
        }
        if (err) {
          this.actOnErrorFromAuthorize(err);
        } else {
          connect();
        }
      };
      if (this.errorReason && auth_default.isTokenErr(this.errorReason)) {
        auth._forceNewToken(null, null, authCb);
      } else {
        auth._ensureValidAuthCredentials(false, authCb);
      }
    }
  }
  /**
   * There are three stages in connecting:
   * - preference: if there is a cached transport preference, we try to connect
   *   on that. If that fails or times out we abort the attempt, remove the
   *   preference and fall back to base. If it succeeds, we try upgrading it if
   *   needed (will only be in the case where the preference is xhrs and the
   *   browser supports ws).
   * - base: we try to connect with the best transport that we think will
   *   never fail for this platform. If it doesn't work, we try fallback hosts.
   * - upgrade: given a connected transport, we see if there are any better
   *   ones, and if so, try to upgrade to them.
   *
   * connectImpl works out what stage you're at (which is purely a function of
   * the current connection state and whether there are any stored preferences),
   * and dispatches accordingly. After a transport has been set pending,
   * tryATransport calls connectImpl to see if there's another stage to be done.
   * */
  connectImpl(transportParams, connectCount) {
    const state = this.state.state;
    if (state !== this.states.connecting.state && state !== this.states.connected.state) {
      logger_default.logAction(
        logger_default.LOG_MINOR,
        "ConnectionManager.connectImpl()",
        "Must be in connecting state to connect (or connected to upgrade), but was " + state
      );
    } else if (this.pendingTransports.length) {
      logger_default.logAction(
        logger_default.LOG_MINOR,
        "ConnectionManager.connectImpl()",
        "Transports " + this.pendingTransports[0].toString() + " currently pending; taking no action"
      );
    } else if (state == this.states.connected.state) {
      this.upgradeIfNeeded(transportParams);
    } else if (this.transports.length > 1 && this.getTransportPreference()) {
      this.connectPreference(transportParams, connectCount);
    } else {
      this.connectBase(transportParams, connectCount);
    }
  }
  connectPreference(transportParams, connectCount) {
    const preference = this.getTransportPreference();
    let preferenceTimeoutExpired = false;
    if (!arrIn(this.transports, preference)) {
      this.unpersistTransportPreference();
      this.connectImpl(transportParams, connectCount);
    }
    logger_default.logAction(
      logger_default.LOG_MINOR,
      "ConnectionManager.connectPreference()",
      "Trying to connect with stored transport preference " + preference
    );
    const preferenceTimeout = setTimeout(() => {
      preferenceTimeoutExpired = true;
      if (!(this.state.state === this.states.connected.state)) {
        logger_default.logAction(
          logger_default.LOG_MINOR,
          "ConnectionManager.connectPreference()",
          "Shortcircuit connection attempt with " + preference + " failed; clearing preference and trying from scratch"
        );
        this.disconnectAllTransports();
        this.unpersistTransportPreference();
      }
      this.connectImpl(transportParams, connectCount);
    }, this.options.timeouts.preferenceConnectTimeout);
    transportParams.host = this.httpHosts[0];
    this.tryATransport(transportParams, preference, (fatal, transport) => {
      clearTimeout(preferenceTimeout);
      if (preferenceTimeoutExpired && transport) {
        transport.off();
        transport.disconnect();
        arrDeleteValue(this.pendingTransports, transport);
      } else if (!transport && !fatal) {
        this.unpersistTransportPreference();
        this.connectImpl(transportParams, connectCount);
      }
    });
  }
  /**
   * Try to establish a transport on the base transport (the best transport
   * such that if it doesn't work, nothing will work) as determined through
   * static feature detection, checking for network connectivity and trying
   * fallback hosts if applicable.
   * @param transportParams
   */
  connectBase(transportParams, connectCount) {
    const giveUp = (err) => {
      this.notifyState({ state: this.states.connecting.failState, error: err });
    };
    const candidateHosts = this.httpHosts.slice();
    const hostAttemptCb = (fatal, transport) => {
      if (connectCount !== this.connectCounter) {
        return;
      }
      if (!transport && !fatal) {
        tryFallbackHosts();
      }
    };
    logger_default.logAction(
      logger_default.LOG_MINOR,
      "ConnectionManager.connectBase()",
      "Trying to connect with base transport " + this.baseTransport
    );
    const host = candidateHosts.shift();
    if (!host) {
      giveUp(new ErrorInfo("Unable to connect (no available host)", 80003, 404));
      return;
    }
    transportParams.host = host;
    const tryFallbackHosts = () => {
      if (!candidateHosts.length) {
        giveUp(new ErrorInfo("Unable to connect (and no more fallback hosts to try)", 80003, 404));
        return;
      }
      if (!this.realtime.http.checkConnectivity) {
        giveUp(new PartialErrorInfo("Internal error: Http.checkConnectivity not set", null, 500));
        return;
      }
      this.realtime.http.checkConnectivity((err, connectivity) => {
        if (connectCount !== this.connectCounter) {
          return;
        }
        if (err) {
          giveUp(err);
          return;
        }
        if (!connectivity) {
          giveUp(new ErrorInfo("Unable to connect (network unreachable)", 80003, 404));
          return;
        }
        transportParams.host = arrPopRandomElement(candidateHosts);
        this.tryATransport(transportParams, this.baseTransport, hostAttemptCb);
      });
    };
    if (this.forceFallbackHost && candidateHosts.length) {
      this.forceFallbackHost = false;
      tryFallbackHosts();
      return;
    }
    this.tryATransport(transportParams, this.baseTransport, hostAttemptCb);
  }
  getUpgradePossibilities() {
    const current = this.activeProtocol.getTransport().shortName;
    const currentSerial = arrIndexOf(this.upgradeTransports, current);
    return this.upgradeTransports.slice(currentSerial + 1);
  }
  upgradeIfNeeded(transportParams) {
    const upgradePossibilities = this.getUpgradePossibilities();
    logger_default.logAction(
      logger_default.LOG_MINOR,
      "ConnectionManager.upgradeIfNeeded()",
      "upgrade possibilities: " + Platform.Config.inspect(upgradePossibilities)
    );
    if (!upgradePossibilities.length) {
      return;
    }
    arrForEach(upgradePossibilities, (upgradeTransport) => {
      const upgradeTransportParams = this.createTransportParams(transportParams.host, "upgrade");
      this.tryATransport(upgradeTransportParams, upgradeTransport, noop4);
    });
  }
  closeImpl() {
    logger_default.logAction(logger_default.LOG_MINOR, "ConnectionManager.closeImpl()", "closing connection");
    this.cancelSuspendTimer();
    this.startTransitionTimer(this.states.closing);
    safeArrForEach(this.pendingTransports, function(transport) {
      logger_default.logAction(logger_default.LOG_MICRO, "ConnectionManager.closeImpl()", "Closing pending transport: " + transport);
      if (transport)
        transport.close();
    });
    safeArrForEach(this.proposedTransports, function(transport) {
      logger_default.logAction(
        logger_default.LOG_MICRO,
        "ConnectionManager.closeImpl()",
        "Disposing of proposed transport: " + transport
      );
      if (transport)
        transport.dispose();
    });
    if (this.activeProtocol) {
      logger_default.logAction(
        logger_default.LOG_MICRO,
        "ConnectionManager.closeImpl()",
        "Closing active transport: " + this.activeProtocol.getTransport()
      );
      this.activeProtocol.getTransport().close();
    }
    this.notifyState({ state: "closed" });
  }
  onAuthUpdated(tokenDetails, callback) {
    var _a2;
    switch (this.state.state) {
      case "connected": {
        logger_default.logAction(
          logger_default.LOG_MICRO,
          "ConnectionManager.onAuthUpdated()",
          "Sending AUTH message on active transport"
        );
        if ((this.pendingTransports.length || this.proposedTransports.length) && this.state !== this.states.synchronizing) {
          this.disconnectAllTransports(
            /* exceptActive: */
            true
          );
          const transportParams = this.activeProtocol.getTransport().params;
          Platform.Config.nextTick(() => {
            if (this.state.state === "connected") {
              this.upgradeIfNeeded(transportParams);
            }
          });
        }
        const activeTransport = (_a2 = this.activeProtocol) == null ? void 0 : _a2.getTransport();
        if (activeTransport && activeTransport.onAuthUpdated) {
          activeTransport.onAuthUpdated(tokenDetails);
        }
        const authMsg = fromValues3({
          action: actions2.AUTH,
          auth: {
            accessToken: tokenDetails.token
          }
        });
        this.send(authMsg);
        const successListener = () => {
          this.off(failureListener);
          callback(null, tokenDetails);
        };
        const failureListener = (stateChange) => {
          if (stateChange.current === "failed") {
            this.off(successListener);
            this.off(failureListener);
            callback(stateChange.reason || this.getStateError());
          }
        };
        this.once("connectiondetails", successListener);
        this.on("connectionstate", failureListener);
        break;
      }
      case "connecting":
        logger_default.logAction(
          logger_default.LOG_MICRO,
          "ConnectionManager.onAuthUpdated()",
          "Aborting current connection attempts in order to start again with the new auth details"
        );
        this.disconnectAllTransports();
      default: {
        logger_default.logAction(
          logger_default.LOG_MICRO,
          "ConnectionManager.onAuthUpdated()",
          "Connection state is " + this.state.state + "; waiting until either connected or failed"
        );
        const listener = (stateChange) => {
          switch (stateChange.current) {
            case "connected":
              this.off(listener);
              callback(null, tokenDetails);
              break;
            case "failed":
            case "closed":
            case "suspended":
              this.off(listener);
              callback(stateChange.reason || this.getStateError());
              break;
            default:
              break;
          }
        };
        this.on("connectionstate", listener);
        if (this.state.state === "connecting") {
          this.startConnect();
        } else {
          this.requestState({ state: "connecting" });
        }
      }
    }
  }
  disconnectAllTransports(exceptActive) {
    logger_default.logAction(
      logger_default.LOG_MINOR,
      "ConnectionManager.disconnectAllTransports()",
      "Disconnecting all transports" + (exceptActive ? " except the active transport" : "")
    );
    this.connectCounter++;
    safeArrForEach(this.pendingTransports, function(transport) {
      logger_default.logAction(
        logger_default.LOG_MICRO,
        "ConnectionManager.disconnectAllTransports()",
        "Disconnecting pending transport: " + transport
      );
      if (transport)
        transport.disconnect();
    });
    this.pendingTransports = [];
    safeArrForEach(this.proposedTransports, function(transport) {
      logger_default.logAction(
        logger_default.LOG_MICRO,
        "ConnectionManager.disconnectAllTransports()",
        "Disposing of proposed transport: " + transport
      );
      if (transport)
        transport.dispose();
    });
    this.proposedTransports = [];
    if (this.activeProtocol && !exceptActive) {
      logger_default.logAction(
        logger_default.LOG_MICRO,
        "ConnectionManager.disconnectAllTransports()",
        "Disconnecting active transport: " + this.activeProtocol.getTransport()
      );
      this.activeProtocol.getTransport().disconnect();
    }
  }
  /******************
   * event queueing
   ******************/
  send(msg, queueEvent, callback) {
    callback = callback || noop4;
    const state = this.state;
    if (state.sendEvents) {
      logger_default.logAction(logger_default.LOG_MICRO, "ConnectionManager.send()", "sending event");
      this.sendImpl(new PendingMessage(msg, callback));
      return;
    }
    const shouldQueue = queueEvent && state.queueEvents || state.forceQueueEvents;
    if (!shouldQueue) {
      const err = "rejecting event, queueEvent was " + queueEvent + ", state was " + state.state;
      logger_default.logAction(logger_default.LOG_MICRO, "ConnectionManager.send()", err);
      callback(this.errorReason || new ErrorInfo(err, 9e4, 400));
      return;
    }
    if (logger_default.shouldLog(logger_default.LOG_MICRO)) {
      logger_default.logAction(
        logger_default.LOG_MICRO,
        "ConnectionManager.send()",
        "queueing msg; " + stringify(msg, this.realtime._RealtimePresence)
      );
    }
    this.queue(msg, callback);
  }
  sendImpl(pendingMessage) {
    const msg = pendingMessage.message;
    if (pendingMessage.ackRequired && !pendingMessage.sendAttempted) {
      msg.msgSerial = this.msgSerial++;
    }
    try {
      this.activeProtocol.send(pendingMessage);
    } catch (e) {
      logger_default.logAction(
        logger_default.LOG_ERROR,
        "ConnectionManager.sendImpl()",
        "Unexpected exception in transport.send(): " + e.stack
      );
    }
  }
  queue(msg, callback) {
    logger_default.logAction(logger_default.LOG_MICRO, "ConnectionManager.queue()", "queueing event");
    const lastQueued = this.queuedMessages.last();
    const maxSize = this.options.maxMessageSize;
    if (lastQueued && !lastQueued.sendAttempted && bundleWith(lastQueued.message, msg, maxSize)) {
      if (!lastQueued.merged) {
        lastQueued.callback = multicaster_default.create([lastQueued.callback]);
        lastQueued.merged = true;
      }
      lastQueued.callback.push(callback);
    } else {
      this.queuedMessages.push(new PendingMessage(msg, callback));
    }
  }
  sendQueuedMessages() {
    logger_default.logAction(
      logger_default.LOG_MICRO,
      "ConnectionManager.sendQueuedMessages()",
      "sending " + this.queuedMessages.count() + " queued messages"
    );
    let pendingMessage;
    while (pendingMessage = this.queuedMessages.shift())
      this.sendImpl(pendingMessage);
  }
  queuePendingMessages(pendingMessages) {
    if (pendingMessages && pendingMessages.length) {
      logger_default.logAction(
        logger_default.LOG_MICRO,
        "ConnectionManager.queuePendingMessages()",
        "queueing " + pendingMessages.length + " pending messages"
      );
      this.queuedMessages.prepend(pendingMessages);
    }
  }
  failQueuedMessages(err) {
    const numQueued = this.queuedMessages.count();
    if (numQueued > 0) {
      logger_default.logAction(
        logger_default.LOG_ERROR,
        "ConnectionManager.failQueuedMessages()",
        "failing " + numQueued + " queued messages, err = " + inspectError(err)
      );
      this.queuedMessages.completeAllMessages(err);
    }
  }
  onChannelMessage(message, transport) {
    this.pendingChannelMessagesState.queue.push({ message, transport });
    if (!this.pendingChannelMessagesState.isProcessing) {
      this.processNextPendingChannelMessage();
    }
  }
  processNextPendingChannelMessage() {
    if (this.pendingChannelMessagesState.queue.length > 0) {
      this.pendingChannelMessagesState.isProcessing = true;
      const pendingChannelMessage = this.pendingChannelMessagesState.queue.shift();
      this.processChannelMessage(pendingChannelMessage.message, pendingChannelMessage.transport).catch((err) => {
        logger_default.logAction(
          logger_default.LOG_ERROR,
          "ConnectionManager.processNextPendingChannelMessage() received error ",
          err
        );
      }).finally(() => {
        this.pendingChannelMessagesState.isProcessing = false;
        this.processNextPendingChannelMessage();
      });
    }
  }
  processChannelMessage(message, transport) {
    return __async(this, null, function* () {
      const onActiveTransport = this.activeProtocol && transport === this.activeProtocol.getTransport(), onUpgradeTransport = arrIn(this.pendingTransports, transport) && this.state == this.states.synchronizing;
      if (onActiveTransport || onUpgradeTransport) {
        yield this.realtime.channels.processChannelMessage(message);
      } else {
        if (arrIndexOf([actions2.ACK, actions2.NACK, actions2.ERROR], message.action) > -1) {
          yield this.realtime.channels.processChannelMessage(message);
        } else {
          logger_default.logAction(
            logger_default.LOG_MICRO,
            "ConnectionManager.onChannelMessage()",
            "received message " + JSON.stringify(message) + "on defunct transport; discarding"
          );
        }
      }
    });
  }
  ping(transport, callback) {
    if (transport) {
      logger_default.logAction(logger_default.LOG_MINOR, "ConnectionManager.ping()", "transport = " + transport);
      const onTimeout = function() {
        transport.off("heartbeat", onHeartbeat);
        callback(new ErrorInfo("Timeout waiting for heartbeat response", 5e4, 500));
      };
      const pingStart = now(), id = cheapRandStr();
      const onHeartbeat = function(responseId) {
        if (responseId === id) {
          transport.off("heartbeat", onHeartbeat);
          clearTimeout(timer);
          const responseTime = now() - pingStart;
          callback(null, responseTime);
        }
      };
      const timer = setTimeout(onTimeout, this.options.timeouts.realtimeRequestTimeout);
      transport.on("heartbeat", onHeartbeat);
      transport.ping(id);
      return;
    }
    if (this.state.state !== "connected") {
      callback(new ErrorInfo("Unable to ping service; not connected", 4e4, 400));
      return;
    }
    let completed = false;
    const onPingComplete = (err, responseTime) => {
      this.off("transport.active", onTransportActive);
      if (!completed) {
        completed = true;
        callback(err, responseTime);
      }
    };
    const onTransportActive = () => {
      if (!completed) {
        completed = true;
        Platform.Config.nextTick(() => {
          this.ping(null, callback);
        });
      }
    };
    this.on("transport.active", onTransportActive);
    this.ping(this.activeProtocol.getTransport(), onPingComplete);
  }
  abort(error) {
    this.activeProtocol.getTransport().fail(error);
  }
  registerProposedTransport(transport) {
    this.proposedTransports.push(transport);
  }
  getTransportPreference() {
    var _a2, _b;
    return this.transportPreference || haveWebStorage() && ((_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.get) == null ? void 0 : _b.call(_a2, transportPreferenceName));
  }
  persistTransportPreference(transport) {
    var _a2, _b;
    if (arrIn(defaults_default.upgradeTransports, transport.shortName)) {
      this.transportPreference = transport.shortName;
      if (haveWebStorage()) {
        (_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.set) == null ? void 0 : _b.call(_a2, transportPreferenceName, transport.shortName);
      }
    }
  }
  unpersistTransportPreference() {
    var _a2, _b;
    this.transportPreference = null;
    if (haveWebStorage()) {
      (_b = (_a2 = Platform.WebStorage) == null ? void 0 : _a2.remove) == null ? void 0 : _b.call(_a2, transportPreferenceName);
    }
  }
  /* This method is only used during connection attempts, so implements RSA4c1, RSA4c2,
   * and RSA4d. It is generally not invoked for serverside-triggered reauths or manual
   * reauths, so RSA4c3 does not apply, except (per per RSA4d1) in the case that the auth
   * server returns 403. */
  actOnErrorFromAuthorize(err) {
    if (err.code === 40171) {
      this.notifyState({ state: "failed", error: err });
    } else if (err.code === 40102) {
      this.notifyState({ state: "failed", error: err });
    } else if (err.statusCode === HttpStatusCodes_default.Forbidden) {
      const msg = "Client configured authentication provider returned 403; failing the connection";
      logger_default.logAction(logger_default.LOG_ERROR, "ConnectionManager.actOnErrorFromAuthorize()", msg);
      this.notifyState({ state: "failed", error: new ErrorInfo(msg, 80019, 403, err) });
    } else {
      const msg = "Client configured authentication provider request failed";
      logger_default.logAction(logger_default.LOG_MINOR, "ConnectionManager.actOnErrorFromAuthorize", msg);
      this.notifyState({ state: this.state.failState, error: new ErrorInfo(msg, 80019, 401, err) });
    }
  }
  onConnectionDetailsUpdate(connectionDetails, transport) {
    if (!connectionDetails) {
      return;
    }
    this.connectionDetails = connectionDetails;
    if (connectionDetails.maxMessageSize) {
      this.options.maxMessageSize = connectionDetails.maxMessageSize;
    }
    const clientId = connectionDetails.clientId;
    if (clientId) {
      const err = this.realtime.auth._uncheckedSetClientId(clientId);
      if (err) {
        logger_default.logAction(logger_default.LOG_ERROR, "ConnectionManager.onConnectionDetailsUpdate()", err.message);
        transport.fail(err);
        return;
      }
    }
    const connectionStateTtl = connectionDetails.connectionStateTtl;
    if (connectionStateTtl) {
      this.connectionStateTtl = connectionStateTtl;
    }
    this.maxIdleInterval = connectionDetails.maxIdleInterval;
    this.emit("connectiondetails", connectionDetails);
  }
};
var connectionmanager_default = ConnectionManager;

// src/common/lib/client/connection.ts
var Connection = class extends eventemitter_default {
  constructor(ably, options) {
    super();
    this.whenState = (state, listener) => {
      return eventemitter_default.prototype.whenState.call(
        this,
        state,
        this.state,
        listener,
        new connectionstatechange_default(void 0, state)
      );
    };
    this.ably = ably;
    this.connectionManager = new connectionmanager_default(ably, options);
    this.state = this.connectionManager.state.state;
    this.key = void 0;
    this.id = void 0;
    this.errorReason = null;
    this.connectionManager.on("connectionstate", (stateChange) => {
      const state = this.state = stateChange.current;
      Platform.Config.nextTick(() => {
        this.emit(state, stateChange);
      });
    });
    this.connectionManager.on("update", (stateChange) => {
      Platform.Config.nextTick(() => {
        this.emit("update", stateChange);
      });
    });
  }
  connect() {
    logger_default.logAction(logger_default.LOG_MINOR, "Connection.connect()", "");
    this.connectionManager.requestState({ state: "connecting" });
  }
  ping(callback) {
    logger_default.logAction(logger_default.LOG_MINOR, "Connection.ping()", "");
    if (!callback) {
      return promisify(this, "ping", arguments);
    }
    this.connectionManager.ping(null, callback);
  }
  close() {
    logger_default.logAction(logger_default.LOG_MINOR, "Connection.close()", "connectionKey = " + this.key);
    this.connectionManager.requestState({ state: "closing" });
  }
  get recoveryKey() {
    return this.createRecoveryKey();
  }
  createRecoveryKey() {
    return this.connectionManager.createRecoveryKey();
  }
};
var connection_default = Connection;

// src/common/lib/client/channelstatechange.ts
var ChannelStateChange = class {
  constructor(previous, current, resumed, hasBacklog, reason) {
    this.previous = previous;
    this.current = current;
    if (current === "attached") {
      this.resumed = resumed;
      this.hasBacklog = hasBacklog;
    }
    if (reason)
      this.reason = reason;
  }
};
var channelstatechange_default = ChannelStateChange;

// src/common/lib/client/realtimechannel.ts
var noop5 = function() {
};
function validateChannelOptions(options) {
  if (options && "params" in options && !isObject(options.params)) {
    return new ErrorInfo("options.params must be an object", 4e4, 400);
  }
  if (options && "modes" in options) {
    if (!isArray(options.modes)) {
      return new ErrorInfo("options.modes must be an array", 4e4, 400);
    }
    for (let i = 0; i < options.modes.length; i++) {
      const currentMode = options.modes[i];
      if (!currentMode || typeof currentMode !== "string" || !arrIn(channelModes, String.prototype.toUpperCase.call(currentMode))) {
        return new ErrorInfo("Invalid channel mode: " + currentMode, 4e4, 400);
      }
    }
  }
}
var RealtimeChannel = class _RealtimeChannel extends eventemitter_default {
  constructor(client, name, options) {
    var _a2, _b;
    super();
    this.retryCount = 0;
    this.history = function(params, callback) {
      logger_default.logAction(logger_default.LOG_MICRO, "RealtimeChannel.history()", "channel = " + this.name);
      if (callback === void 0) {
        if (typeof params == "function") {
          callback = params;
          params = null;
        } else {
          return promisify(this, "history", arguments);
        }
      }
      const restMixin = this.client.rest.channelMixin;
      if (params && params.untilAttach) {
        if (this.state !== "attached") {
          callback(new ErrorInfo("option untilAttach requires the channel to be attached", 4e4, 400));
          return;
        }
        if (!this.properties.attachSerial) {
          callback(
            new ErrorInfo(
              "untilAttach was specified and channel is attached, but attachSerial is not defined",
              4e4,
              400
            )
          );
          return;
        }
        delete params.untilAttach;
        params.from_serial = this.properties.attachSerial;
      }
      return restMixin.history(this, params, callback);
    };
    this.whenState = (state, listener) => {
      return eventemitter_default.prototype.whenState.call(this, state, this.state, listener);
    };
    logger_default.logAction(logger_default.LOG_MINOR, "RealtimeChannel()", "started; name = " + name);
    this.name = name;
    this.channelOptions = normaliseChannelOptions((_a2 = client._Crypto) != null ? _a2 : null, options);
    this.client = client;
    this._presence = client._RealtimePresence ? new client._RealtimePresence.RealtimePresence(this) : null;
    this.connectionManager = client.connection.connectionManager;
    this.state = "initialized";
    this.subscriptions = new eventemitter_default();
    this.syncChannelSerial = void 0;
    this.properties = {
      attachSerial: void 0,
      channelSerial: void 0
    };
    this.setOptions(options);
    this.errorReason = null;
    this._requestedFlags = null;
    this._mode = null;
    this._attachResume = false;
    this._decodingContext = {
      channelOptions: this.channelOptions,
      decodeVcdiff: (_b = client._decodeVcdiff) != null ? _b : void 0,
      baseEncodedPreviousPayload: void 0
    };
    this._lastPayload = {
      messageId: null,
      protocolMessageChannelSerial: null,
      decodeFailureRecoveryInProgress: null
    };
    this._allChannelChanges = new eventemitter_default();
  }
  get presence() {
    if (!this._presence) {
      throwMissingModuleError("RealtimePresence");
    }
    return this._presence;
  }
  invalidStateError() {
    return new ErrorInfo(
      "Channel operation failed as channel state is " + this.state,
      90001,
      400,
      this.errorReason || void 0
    );
  }
  static processListenerArgs(args) {
    args = Array.prototype.slice.call(args);
    if (typeof args[0] === "function") {
      args.unshift(null);
    }
    if (args[args.length - 1] == void 0) {
      args.pop();
    }
    return args;
  }
  setOptions(options, callback) {
    var _a2;
    if (!callback) {
      return promisify(this, "setOptions", arguments);
    }
    const _callback = callback || function(err2) {
      if (err2) {
        logger_default.logAction(logger_default.LOG_ERROR, "RealtimeChannel.setOptions()", "Set options failed: " + err2.toString());
      }
    };
    const err = validateChannelOptions(options);
    if (err) {
      _callback(err);
      return;
    }
    this.channelOptions = normaliseChannelOptions((_a2 = this.client._Crypto) != null ? _a2 : null, options);
    if (this._decodingContext)
      this._decodingContext.channelOptions = this.channelOptions;
    if (this._shouldReattachToSetOptions(options)) {
      this.attachImpl();
      this._allChannelChanges.once(
        ["attached", "update", "detached", "failed"],
        function(stateChange) {
          switch (this.event) {
            case "update":
            case "attached":
              _callback == null ? void 0 : _callback(null);
              return;
            default:
              _callback == null ? void 0 : _callback(stateChange.reason);
              return;
          }
        }
      );
    } else {
      _callback();
    }
  }
  _shouldReattachToSetOptions(options) {
    if (!(this.state === "attached" || this.state === "attaching")) {
      return false;
    }
    if (options == null ? void 0 : options.params) {
      const requestedParams = Object.assign({}, options.params);
      delete requestedParams.agent;
      if (Object.keys(requestedParams).length !== 0 && !this.params) {
        return true;
      }
      if (this.params && !shallowEquals(this.params, requestedParams)) {
        return true;
      }
    }
    if (options == null ? void 0 : options.modes) {
      if (!this.modes || !arrEquals(options.modes, this.modes)) {
        return true;
      }
    }
    return false;
  }
  publish(...args) {
    let messages = args[0];
    let argCount = args.length;
    let callback = args[argCount - 1];
    if (typeof callback !== "function") {
      return promisify(this, "publish", arguments);
    }
    if (!this.connectionManager.activeState()) {
      callback(this.connectionManager.getError());
      return;
    }
    if (argCount == 2) {
      if (isObject(messages))
        messages = [fromValues(messages)];
      else if (isArray(messages))
        messages = fromValuesArray(messages);
      else
        throw new ErrorInfo(
          "The single-argument form of publish() expects a message object or an array of message objects",
          40013,
          400
        );
    } else {
      messages = [fromValues({ name: args[0], data: args[1] })];
    }
    const maxMessageSize = this.client.options.maxMessageSize;
    encodeArray(messages, this.channelOptions, (err) => {
      if (err) {
        callback(err);
        return;
      }
      const size = getMessagesSize(messages);
      if (size > maxMessageSize) {
        callback(
          new ErrorInfo(
            "Maximum size of messages that can be published at once exceeded ( was " + size + " bytes; limit is " + maxMessageSize + " bytes)",
            40009,
            400
          )
        );
        return;
      }
      this._publish(messages, callback);
    });
  }
  _publish(messages, callback) {
    logger_default.logAction(logger_default.LOG_MICRO, "RealtimeChannel.publish()", "message count = " + messages.length);
    const state = this.state;
    switch (state) {
      case "failed":
      case "suspended":
        callback(ErrorInfo.fromValues(this.invalidStateError()));
        break;
      default: {
        logger_default.logAction(logger_default.LOG_MICRO, "RealtimeChannel.publish()", "sending message; channel state is " + state);
        const msg = new protocolmessage_default();
        msg.action = actions2.MESSAGE;
        msg.channel = this.name;
        msg.messages = messages;
        this.sendMessage(msg, callback);
        break;
      }
    }
  }
  onEvent(messages) {
    logger_default.logAction(logger_default.LOG_MICRO, "RealtimeChannel.onEvent()", "received message");
    const subscriptions = this.subscriptions;
    for (let i = 0; i < messages.length; i++) {
      const message = messages[i];
      subscriptions.emit(message.name, message);
    }
  }
  attach(callback) {
    if (!callback) {
      return promisify(this, "attach", arguments);
    }
    if (this.state === "attached") {
      callback(null, null);
      return;
    }
    this._attach(false, null, callback);
  }
  _attach(forceReattach, attachReason, callback) {
    if (!callback) {
      callback = function(err) {
        if (err) {
          logger_default.logAction(logger_default.LOG_ERROR, "RealtimeChannel._attach()", "Channel attach failed: " + err.toString());
        }
      };
    }
    const connectionManager = this.connectionManager;
    if (!connectionManager.activeState()) {
      callback(connectionManager.getError());
      return;
    }
    if (this.state !== "attaching" || forceReattach) {
      this.requestState("attaching", attachReason);
    }
    this.once(function(stateChange) {
      switch (this.event) {
        case "attached":
          callback == null ? void 0 : callback(null, stateChange);
          break;
        case "detached":
        case "suspended":
        case "failed":
          callback == null ? void 0 : callback(
            stateChange.reason || connectionManager.getError() || new ErrorInfo("Unable to attach; reason unknown; state = " + this.event, 9e4, 500)
          );
          break;
        case "detaching":
          callback == null ? void 0 : callback(new ErrorInfo("Attach request superseded by a subsequent detach request", 9e4, 409));
          break;
      }
    });
  }
  attachImpl() {
    logger_default.logAction(logger_default.LOG_MICRO, "RealtimeChannel.attachImpl()", "sending ATTACH message");
    const attachMsg = fromValues3({
      action: actions2.ATTACH,
      channel: this.name,
      params: this.channelOptions.params,
      // RTL4c1: Includes the channel serial to resume from a previous message
      // or attachment.
      channelSerial: this.properties.channelSerial
    });
    if (this._requestedFlags) {
      attachMsg.encodeModesToFlags(this._requestedFlags);
    } else if (this.channelOptions.modes) {
      attachMsg.encodeModesToFlags(allToUpperCase(this.channelOptions.modes));
    }
    if (this._attachResume) {
      attachMsg.setFlag("ATTACH_RESUME");
    }
    if (this._lastPayload.decodeFailureRecoveryInProgress) {
      attachMsg.channelSerial = this._lastPayload.protocolMessageChannelSerial;
    }
    this.sendMessage(attachMsg, noop5);
  }
  detach(callback) {
    if (!callback) {
      return promisify(this, "detach", arguments);
    }
    const connectionManager = this.connectionManager;
    if (!connectionManager.activeState()) {
      callback(connectionManager.getError());
      return;
    }
    switch (this.state) {
      case "suspended":
        this.notifyState("detached");
        callback();
        break;
      case "detached":
        callback();
        break;
      case "failed":
        callback(new ErrorInfo("Unable to detach; channel state = failed", 90001, 400));
        break;
      default:
        this.requestState("detaching");
      case "detaching":
        this.once(function(stateChange) {
          switch (this.event) {
            case "detached":
              callback();
              break;
            case "attached":
            case "suspended":
            case "failed":
              callback(
                stateChange.reason || connectionManager.getError() || new ErrorInfo("Unable to detach; reason unknown; state = " + this.event, 9e4, 500)
              );
              break;
            case "attaching":
              callback(new ErrorInfo("Detach request superseded by a subsequent attach request", 9e4, 409));
              break;
          }
        });
    }
  }
  detachImpl(callback) {
    logger_default.logAction(logger_default.LOG_MICRO, "RealtimeChannel.detach()", "sending DETACH message");
    const msg = fromValues3({ action: actions2.DETACH, channel: this.name });
    this.sendMessage(msg, callback || noop5);
  }
  subscribe(...args) {
    const [event, listener, callback] = _RealtimeChannel.processListenerArgs(args);
    if (!callback) {
      return promisify(this, "subscribe", [event, listener]);
    }
    if (this.state === "failed") {
      callback == null ? void 0 : callback(ErrorInfo.fromValues(this.invalidStateError()));
      return;
    }
    if (event && typeof event === "object" && !Array.isArray(event)) {
      this.client._FilteredSubscriptions.subscribeFilter(this, event, listener);
    } else {
      this.subscriptions.on(event, listener);
    }
    return this.attach(callback || noop5);
  }
  unsubscribe(...args) {
    var _a2;
    const [event, listener] = _RealtimeChannel.processListenerArgs(args);
    if (typeof event === "object" && !listener || ((_a2 = this.filteredSubscriptions) == null ? void 0 : _a2.has(listener))) {
      this.client._FilteredSubscriptions.getAndDeleteFilteredSubscriptions(this, event, listener).forEach((l) => this.subscriptions.off(l));
      return;
    }
    this.subscriptions.off(event, listener);
  }
  sync() {
    switch (this.state) {
      case "initialized":
      case "detaching":
      case "detached":
        throw new PartialErrorInfo("Unable to sync to channel; not attached", 4e4);
      default:
    }
    const connectionManager = this.connectionManager;
    if (!connectionManager.activeState()) {
      throw connectionManager.getError();
    }
    const syncMessage = fromValues3({ action: actions2.SYNC, channel: this.name });
    if (this.syncChannelSerial) {
      syncMessage.channelSerial = this.syncChannelSerial;
    }
    connectionManager.send(syncMessage);
  }
  sendMessage(msg, callback) {
    this.connectionManager.send(msg, this.client.options.queueMessages, callback);
  }
  sendPresence(presence, callback) {
    const msg = fromValues3({
      action: actions2.PRESENCE,
      channel: this.name,
      presence: isArray(presence) ? this.client._RealtimePresence.presenceMessagesFromValuesArray(presence) : [this.client._RealtimePresence.presenceMessageFromValues(presence)]
    });
    this.sendMessage(msg, callback);
  }
  // Access to this method is synchronised by ConnectionManager#processChannelMessage, in order to synchronise access to the state stored in _decodingContext.
  processMessage(message) {
    return __async(this, null, function* () {
      if (message.action === actions2.ATTACHED || message.action === actions2.MESSAGE || message.action === actions2.PRESENCE) {
        this.setChannelSerial(message.channelSerial);
      }
      let syncChannelSerial, isSync = false;
      switch (message.action) {
        case actions2.ATTACHED: {
          this.properties.attachSerial = message.channelSerial;
          this._mode = message.getMode();
          this.params = message.params || {};
          const modesFromFlags = message.decodeModesFromFlags();
          this.modes = modesFromFlags && allToLowerCase(modesFromFlags) || void 0;
          const resumed = message.hasFlag("RESUMED");
          const hasPresence = message.hasFlag("HAS_PRESENCE");
          const hasBacklog = message.hasFlag("HAS_BACKLOG");
          if (this.state === "attached") {
            if (!resumed) {
              if (this._presence) {
                this._presence.onAttached(hasPresence);
              }
            }
            const change = new channelstatechange_default(this.state, this.state, resumed, hasBacklog, message.error);
            this._allChannelChanges.emit("update", change);
            if (!resumed || this.channelOptions.updateOnAttached) {
              this.emit("update", change);
            }
          } else if (this.state === "detaching") {
            this.checkPendingState();
          } else {
            this.notifyState("attached", message.error, resumed, hasPresence, hasBacklog);
          }
          break;
        }
        case actions2.DETACHED: {
          const detachErr = message.error ? ErrorInfo.fromValues(message.error) : new ErrorInfo("Channel detached", 90001, 404);
          if (this.state === "detaching") {
            this.notifyState("detached", detachErr);
          } else if (this.state === "attaching") {
            this.notifyState("suspended", detachErr);
          } else {
            this.requestState("attaching", detachErr);
          }
          break;
        }
        case actions2.SYNC:
          isSync = true;
          syncChannelSerial = this.syncChannelSerial = message.channelSerial;
          if (!message.presence)
            break;
        case actions2.PRESENCE: {
          const presence = message.presence;
          if (!presence) {
            break;
          }
          const { id, connectionId, timestamp } = message;
          const options = this.channelOptions;
          let presenceMsg;
          for (let i = 0; i < presence.length; i++) {
            try {
              presenceMsg = presence[i];
              yield decode2(presenceMsg, options);
              if (!presenceMsg.connectionId)
                presenceMsg.connectionId = connectionId;
              if (!presenceMsg.timestamp)
                presenceMsg.timestamp = timestamp;
              if (!presenceMsg.id)
                presenceMsg.id = id + ":" + i;
            } catch (e) {
              logger_default.logAction(logger_default.LOG_ERROR, "RealtimeChannel.processMessage()", e.toString());
            }
          }
          if (this._presence) {
            this._presence.setPresence(presence, isSync, syncChannelSerial);
          }
          break;
        }
        case actions2.MESSAGE: {
          if (this.state !== "attached") {
            logger_default.logAction(
              logger_default.LOG_MAJOR,
              "RealtimeChannel.processMessage()",
              'Message "' + message.id + '" skipped as this channel "' + this.name + '" state is not "attached" (state is "' + this.state + '").'
            );
            return;
          }
          const messages = message.messages, firstMessage = messages[0], lastMessage = messages[messages.length - 1], id = message.id, connectionId = message.connectionId, timestamp = message.timestamp;
          if (firstMessage.extras && firstMessage.extras.delta && firstMessage.extras.delta.from !== this._lastPayload.messageId) {
            const msg = 'Delta message decode failure - previous message not available for message "' + message.id + '" on this channel "' + this.name + '".';
            logger_default.logAction(logger_default.LOG_ERROR, "RealtimeChannel.processMessage()", msg);
            this._startDecodeFailureRecovery(new ErrorInfo(msg, 40018, 400));
            break;
          }
          for (let i = 0; i < messages.length; i++) {
            const msg = messages[i];
            try {
              yield decode(msg, this._decodingContext);
            } catch (e) {
              logger_default.logAction(logger_default.LOG_ERROR, "RealtimeChannel.processMessage()", e.toString());
              switch (e.code) {
                case 40018:
                  this._startDecodeFailureRecovery(e);
                  return;
                case 40019:
                case 40021:
                  this.notifyState("failed", e);
                  return;
              }
            }
            if (!msg.connectionId)
              msg.connectionId = connectionId;
            if (!msg.timestamp)
              msg.timestamp = timestamp;
            if (!msg.id)
              msg.id = id + ":" + i;
          }
          this._lastPayload.messageId = lastMessage.id;
          this._lastPayload.protocolMessageChannelSerial = message.channelSerial;
          this.onEvent(messages);
          break;
        }
        case actions2.ERROR: {
          const err = message.error;
          if (err && err.code == 80016) {
            this.checkPendingState();
          } else {
            this.notifyState("failed", ErrorInfo.fromValues(err));
          }
          break;
        }
        default:
          logger_default.logAction(
            logger_default.LOG_ERROR,
            "RealtimeChannel.processMessage()",
            "Fatal protocol error: unrecognised action (" + message.action + ")"
          );
          this.connectionManager.abort(connectionerrors_default.unknownChannelErr());
      }
    });
  }
  _startDecodeFailureRecovery(reason) {
    if (!this._lastPayload.decodeFailureRecoveryInProgress) {
      logger_default.logAction(
        logger_default.LOG_MAJOR,
        "RealtimeChannel.processMessage()",
        "Starting decode failure recovery process."
      );
      this._lastPayload.decodeFailureRecoveryInProgress = true;
      this._attach(true, reason, () => {
        this._lastPayload.decodeFailureRecoveryInProgress = false;
      });
    }
  }
  onAttached() {
    logger_default.logAction(logger_default.LOG_MINOR, "RealtimeChannel.onAttached", "activating channel; name = " + this.name);
  }
  notifyState(state, reason, resumed, hasPresence, hasBacklog) {
    logger_default.logAction(
      logger_default.LOG_MICRO,
      "RealtimeChannel.notifyState",
      "name = " + this.name + ", current state = " + this.state + ", notifying state " + state
    );
    this.clearStateTimer();
    if (arrIn(["detached", "suspended", "failed"], state)) {
      this.properties.channelSerial = null;
    }
    if (state === this.state) {
      return;
    }
    if (this._presence) {
      this._presence.actOnChannelState(state, hasPresence, reason);
    }
    if (state === "suspended" && this.connectionManager.state.sendEvents) {
      this.startRetryTimer();
    } else {
      this.cancelRetryTimer();
    }
    if (reason) {
      this.errorReason = reason;
    }
    const change = new channelstatechange_default(this.state, state, resumed, hasBacklog, reason);
    const logLevel = state === "failed" ? logger_default.LOG_ERROR : logger_default.LOG_MAJOR;
    logger_default.logAction(
      logLevel,
      'Channel state for channel "' + this.name + '"',
      state + (reason ? "; reason: " + reason : "")
    );
    if (state !== "attaching" && state !== "suspended") {
      this.retryCount = 0;
    }
    if (state === "attached") {
      this.onAttached();
    }
    if (state === "attached") {
      this._attachResume = true;
    } else if (state === "detaching" || state === "failed") {
      this._attachResume = false;
    }
    this.state = state;
    this._allChannelChanges.emit(state, change);
    this.emit(state, change);
  }
  requestState(state, reason) {
    logger_default.logAction(logger_default.LOG_MINOR, "RealtimeChannel.requestState", "name = " + this.name + ", state = " + state);
    this.notifyState(state, reason);
    this.checkPendingState();
  }
  checkPendingState() {
    const cmState = this.connectionManager.state;
    if (!(cmState.sendEvents || cmState.forceQueueEvents)) {
      logger_default.logAction(
        logger_default.LOG_MINOR,
        "RealtimeChannel.checkPendingState",
        "sendEvents is false; state is " + this.connectionManager.state.state
      );
      return;
    }
    logger_default.logAction(
      logger_default.LOG_MINOR,
      "RealtimeChannel.checkPendingState",
      "name = " + this.name + ", state = " + this.state
    );
    switch (this.state) {
      case "attaching":
        this.startStateTimerIfNotRunning();
        this.attachImpl();
        break;
      case "detaching":
        this.startStateTimerIfNotRunning();
        this.detachImpl();
        break;
      case "attached":
        this.sync();
        break;
      default:
        break;
    }
  }
  timeoutPendingState() {
    switch (this.state) {
      case "attaching": {
        const err = new ErrorInfo("Channel attach timed out", 90007, 408);
        this.notifyState("suspended", err);
        break;
      }
      case "detaching": {
        const err = new ErrorInfo("Channel detach timed out", 90007, 408);
        this.notifyState("attached", err);
        break;
      }
      default:
        this.checkPendingState();
        break;
    }
  }
  startStateTimerIfNotRunning() {
    if (!this.stateTimer) {
      this.stateTimer = setTimeout(() => {
        logger_default.logAction(logger_default.LOG_MINOR, "RealtimeChannel.startStateTimerIfNotRunning", "timer expired");
        this.stateTimer = null;
        this.timeoutPendingState();
      }, this.client.options.timeouts.realtimeRequestTimeout);
    }
  }
  clearStateTimer() {
    const stateTimer = this.stateTimer;
    if (stateTimer) {
      clearTimeout(stateTimer);
      this.stateTimer = null;
    }
  }
  startRetryTimer() {
    if (this.retryTimer)
      return;
    this.retryCount++;
    const retryDelay = getRetryTime(this.client.options.timeouts.channelRetryTimeout, this.retryCount);
    this.retryTimer = setTimeout(() => {
      if (this.state === "suspended" && this.connectionManager.state.sendEvents) {
        this.retryTimer = null;
        logger_default.logAction(logger_default.LOG_MINOR, "RealtimeChannel retry timer expired", "attempting a new attach");
        this.requestState("attaching");
      }
    }, retryDelay);
  }
  cancelRetryTimer() {
    if (this.retryTimer) {
      clearTimeout(this.retryTimer);
      this.retryTimer = null;
    }
  }
  /* @returns null (if can safely be released) | ErrorInfo (if cannot) */
  getReleaseErr() {
    const s = this.state;
    if (s === "initialized" || s === "detached" || s === "failed") {
      return null;
    }
    return new ErrorInfo(
      "Can only release a channel in a state where there is no possibility of further updates from the server being received (initialized, detached, or failed); was " + s,
      90001,
      400
    );
  }
  setChannelSerial(channelSerial) {
    logger_default.logAction(
      logger_default.LOG_MICRO,
      "RealtimeChannel.setChannelSerial()",
      "Updating channel serial; serial = " + channelSerial + "; previous = " + this.properties.channelSerial
    );
    if (channelSerial) {
      this.properties.channelSerial = channelSerial;
    }
  }
  status(callback) {
    return this.client.rest.channelMixin.status(this, callback);
  }
};
var realtimechannel_default = RealtimeChannel;

// src/common/lib/client/baserealtime.ts
var BaseRealtime = class _BaseRealtime extends baseclient_default {
  constructor(options, modules) {
    var _a2, _b;
    super(options, modules);
    logger_default.logAction(logger_default.LOG_MINOR, "Realtime()", "");
    this._additionalTransportImplementations = _BaseRealtime.transportImplementationsFromModules(modules);
    this._RealtimePresence = (_a2 = modules.RealtimePresence) != null ? _a2 : null;
    this._decodeVcdiff = ((_b = modules.Vcdiff) != null ? _b : Platform.Vcdiff.supported && Platform.Vcdiff.bundledDecode) || null;
    this.connection = new connection_default(this, this.options);
    this._channels = new Channels2(this);
    if (options.autoConnect !== false)
      this.connect();
  }
  static transportImplementationsFromModules(modules) {
    const transports = {};
    if (modules.WebSocketTransport) {
      transports[TransportNames.WebSocket] = modules.WebSocketTransport;
    }
    if (modules.XHRStreaming) {
      transports[TransportNames.XhrStreaming] = modules.XHRStreaming;
    }
    if (modules.XHRPolling) {
      transports[TransportNames.XhrPolling] = modules.XHRPolling;
    }
    return transports;
  }
  get channels() {
    return this._channels;
  }
  connect() {
    logger_default.logAction(logger_default.LOG_MINOR, "Realtime.connect()", "");
    this.connection.connect();
  }
  close() {
    logger_default.logAction(logger_default.LOG_MINOR, "Realtime.close()", "");
    this.connection.close();
  }
};
var Channels2 = class extends eventemitter_default {
  constructor(realtime) {
    super();
    this.realtime = realtime;
    this.all = /* @__PURE__ */ Object.create(null);
    realtime.connection.connectionManager.on("transport.active", () => {
      this.onTransportActive();
    });
  }
  channelSerials() {
    let serials = {};
    for (const name of keysArray(this.all, true)) {
      const channel = this.all[name];
      if (channel.properties.channelSerial) {
        serials[name] = channel.properties.channelSerial;
      }
    }
    return serials;
  }
  // recoverChannels gets the given channels and sets their channel serials.
  recoverChannels(channelSerials) {
    for (const name of keysArray(channelSerials, true)) {
      const channel = this.get(name);
      channel.properties.channelSerial = channelSerials[name];
    }
  }
  // Access to this method is synchronised by ConnectionManager#processChannelMessage.
  processChannelMessage(msg) {
    return __async(this, null, function* () {
      const channelName = msg.channel;
      if (channelName === void 0) {
        logger_default.logAction(
          logger_default.LOG_ERROR,
          "Channels.processChannelMessage()",
          "received event unspecified channel, action = " + msg.action
        );
        return;
      }
      const channel = this.all[channelName];
      if (!channel) {
        logger_default.logAction(
          logger_default.LOG_ERROR,
          "Channels.processChannelMessage()",
          "received event for non-existent channel: " + channelName
        );
        return;
      }
      yield channel.processMessage(msg);
    });
  }
  /* called when a transport becomes connected; reattempt attach/detach
   * for channels that are attaching or detaching. */
  onTransportActive() {
    for (const channelName in this.all) {
      const channel = this.all[channelName];
      if (channel.state === "attaching" || channel.state === "detaching") {
        channel.checkPendingState();
      } else if (channel.state === "suspended") {
        channel._attach(false, null);
      } else if (channel.state === "attached") {
        channel.requestState("attaching");
      }
    }
  }
  /* Connection interruptions (ie when the connection will no longer queue
   * events) imply connection state changes for any channel which is either
   * attached, pending, or will attempt to become attached in the future */
  propogateConnectionInterruption(connectionState, reason) {
    const connectionStateToChannelState = {
      closing: "detached",
      closed: "detached",
      failed: "failed",
      suspended: "suspended"
    };
    const fromChannelStates = ["attaching", "attached", "detaching", "suspended"];
    const toChannelState = connectionStateToChannelState[connectionState];
    for (const channelId in this.all) {
      const channel = this.all[channelId];
      if (arrIn(fromChannelStates, channel.state)) {
        channel.notifyState(toChannelState, reason);
      }
    }
  }
  get(name, channelOptions) {
    name = String(name);
    let channel = this.all[name];
    if (!channel) {
      channel = this.all[name] = new realtimechannel_default(this.realtime, name, channelOptions);
    } else if (channelOptions) {
      if (channel._shouldReattachToSetOptions(channelOptions)) {
        throw new ErrorInfo(
          "Channels.get() cannot be used to set channel options that would cause the channel to reattach. Please, use RealtimeChannel.setOptions() instead.",
          4e4,
          400
        );
      }
      channel.setOptions(channelOptions);
    }
    return channel;
  }
  getDerived(name, deriveOptions, channelOptions) {
    if (deriveOptions.filter) {
      const filter = toBase64(deriveOptions.filter);
      const match = matchDerivedChannel(name);
      name = `[filter=${filter}${match.qualifierParam}]${match.channelName}`;
    }
    return this.get(name, channelOptions);
  }
  /* Included to support certain niche use-cases; most users should ignore this.
   * Please do not use this unless you know what you're doing */
  release(name) {
    name = String(name);
    const channel = this.all[name];
    if (!channel) {
      return;
    }
    const releaseErr = channel.getReleaseErr();
    if (releaseErr) {
      throw releaseErr;
    }
    delete this.all[name];
  }
};
var baserealtime_default = BaseRealtime;

// src/platform/web/lib/util/hmac-sha256.ts
var uint8Array = Uint8Array;
var uint32Array = Uint32Array;
var pow = Math.pow;
var DEFAULT_STATE = new uint32Array(8);
var ROUND_CONSTANTS = [];
var M = new uint32Array(64);
function getFractionalBits(n2) {
  return (n2 - (n2 | 0)) * pow(2, 32) | 0;
}
var n = 2;
var nPrime = 0;
while (nPrime < 64) {
  isPrime = true;
  for (factor = 2; factor <= n / 2; factor++) {
    if (n % factor === 0) {
      isPrime = false;
    }
  }
  if (isPrime) {
    if (nPrime < 8) {
      DEFAULT_STATE[nPrime] = getFractionalBits(pow(n, 1 / 2));
    }
    ROUND_CONSTANTS[nPrime] = getFractionalBits(pow(n, 1 / 3));
    nPrime++;
  }
  n++;
}
var isPrime;
var factor;
var LittleEndian = !!new uint8Array(new uint32Array([1]).buffer)[0];
function convertEndian(word) {
  if (LittleEndian) {
    return (
      // byte 1 -> byte 4
      word >>> 24 | // byte 2 -> byte 3
      (word >>> 16 & 255) << 8 | // byte 3 -> byte 2
      (word & 65280) << 8 | // byte 4 -> byte 1
      word << 24
    );
  } else {
    return word;
  }
}
function rightRotate(word, bits) {
  return word >>> bits | word << 32 - bits;
}
function sha256(data) {
  var STATE = DEFAULT_STATE.slice();
  var legth = data.length;
  var bitLength = legth * 8;
  var newBitLength = 512 - (bitLength + 64) % 512 - 1 + bitLength + 65;
  var bytes = new uint8Array(newBitLength / 8);
  var words = new uint32Array(bytes.buffer);
  bytes.set(data, 0);
  bytes[legth] = 128;
  words[words.length - 1] = convertEndian(bitLength);
  var round;
  for (var block = 0; block < newBitLength / 32; block += 16) {
    var workingState = STATE.slice();
    for (round = 0; round < 64; round++) {
      var MRound;
      if (round < 16) {
        MRound = convertEndian(words[block + round]);
      } else {
        var gamma0x = M[round - 15];
        var gamma1x = M[round - 2];
        MRound = M[round - 7] + M[round - 16] + (rightRotate(gamma0x, 7) ^ rightRotate(gamma0x, 18) ^ gamma0x >>> 3) + (rightRotate(gamma1x, 17) ^ rightRotate(gamma1x, 19) ^ gamma1x >>> 10);
      }
      M[round] = MRound |= 0;
      var t1 = (rightRotate(workingState[4], 6) ^ rightRotate(workingState[4], 11) ^ rightRotate(workingState[4], 25)) + (workingState[4] & workingState[5] ^ ~workingState[4] & workingState[6]) + workingState[7] + MRound + ROUND_CONSTANTS[round];
      var t2 = (rightRotate(workingState[0], 2) ^ rightRotate(workingState[0], 13) ^ rightRotate(workingState[0], 22)) + (workingState[0] & workingState[1] ^ workingState[2] & (workingState[0] ^ workingState[1]));
      for (var i = 7; i > 0; i--) {
        workingState[i] = workingState[i - 1];
      }
      workingState[0] = t1 + t2 | 0;
      workingState[4] = workingState[4] + t1 | 0;
    }
    for (round = 0; round < 8; round++) {
      STATE[round] = STATE[round] + workingState[round] | 0;
    }
  }
  return new uint8Array(
    new uint32Array(
      STATE.map(function(val) {
        return convertEndian(val);
      })
    ).buffer
  );
}
function hmac2(key, data) {
  if (key.length > 64)
    key = sha256(key);
  if (key.length < 64) {
    const tmp = new Uint8Array(64);
    tmp.set(key, 0);
    key = tmp;
  }
  var innerKey = new Uint8Array(64);
  var outerKey = new Uint8Array(64);
  for (var i = 0; i < 64; i++) {
    innerKey[i] = 54 ^ key[i];
    outerKey[i] = 92 ^ key[i];
  }
  var msg = new Uint8Array(data.length + 64);
  msg.set(innerKey, 0);
  msg.set(data, 64);
  var result = new Uint8Array(64 + 32);
  result.set(outerKey, 0);
  result.set(sha256(msg), 64);
  return sha256(result);
}

// src/platform/web/lib/util/bufferutils.ts
var BufferUtils = class {
  constructor() {
    this.base64CharSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    this.hexCharSet = "0123456789abcdef";
  }
  // // https://gist.githubusercontent.com/jonleighton/958841/raw/f200e30dfe95212c0165ccf1ae000ca51e9de803/gistfile1.js
  uint8ViewToBase64(bytes) {
    let base64 = "";
    const encodings = this.base64CharSet;
    const byteLength = bytes.byteLength;
    const byteRemainder = byteLength % 3;
    const mainLength = byteLength - byteRemainder;
    let a, b, c, d;
    let chunk;
    for (let i = 0; i < mainLength; i = i + 3) {
      chunk = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
      a = (chunk & 16515072) >> 18;
      b = (chunk & 258048) >> 12;
      c = (chunk & 4032) >> 6;
      d = chunk & 63;
      base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
    }
    if (byteRemainder == 1) {
      chunk = bytes[mainLength];
      a = (chunk & 252) >> 2;
      b = (chunk & 3) << 4;
      base64 += encodings[a] + encodings[b] + "==";
    } else if (byteRemainder == 2) {
      chunk = bytes[mainLength] << 8 | bytes[mainLength + 1];
      a = (chunk & 64512) >> 10;
      b = (chunk & 1008) >> 4;
      c = (chunk & 15) << 2;
      base64 += encodings[a] + encodings[b] + encodings[c] + "=";
    }
    return base64;
  }
  base64ToArrayBuffer(base64) {
    const binary_string = atob == null ? void 0 : atob(base64);
    const len = binary_string.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      const ascii = binary_string.charCodeAt(i);
      bytes[i] = ascii;
    }
    return bytes.buffer;
  }
  isBuffer(buffer) {
    return buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer);
  }
  /* In browsers, returns a Uint8Array */
  toBuffer(buffer) {
    if (!ArrayBuffer) {
      throw new Error("Can't convert to Buffer: browser does not support the necessary types");
    }
    if (buffer instanceof ArrayBuffer) {
      return new Uint8Array(buffer);
    }
    if (ArrayBuffer.isView(buffer)) {
      return new Uint8Array(buffer.buffer);
    }
    throw new Error("BufferUtils.toBuffer expected an ArrayBuffer or a view onto one");
  }
  toArrayBuffer(buffer) {
    if (buffer instanceof ArrayBuffer) {
      return buffer;
    }
    return this.toBuffer(buffer).buffer;
  }
  base64Encode(buffer) {
    return this.uint8ViewToBase64(this.toBuffer(buffer));
  }
  base64Decode(str) {
    if (ArrayBuffer && Platform.Config.atob) {
      return this.base64ToArrayBuffer(str);
    } else {
      throw new Error("Expected ArrayBuffer to exist and Platform.Config.atob to be configured");
    }
  }
  hexEncode(buffer) {
    const arrayBuffer = buffer instanceof ArrayBuffer ? buffer : buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
    const uint8Array2 = new Uint8Array(arrayBuffer);
    return uint8Array2.reduce((accum, byte) => accum + byte.toString(16).padStart(2, "0"), "");
  }
  hexDecode(hexEncodedBytes) {
    if (hexEncodedBytes.length % 2 !== 0) {
      throw new Error("Can't create a byte array from a hex string of odd length");
    }
    const uint8Array2 = new Uint8Array(hexEncodedBytes.length / 2);
    for (let i = 0; i < uint8Array2.length; i++) {
      uint8Array2[i] = parseInt(hexEncodedBytes.slice(2 * i, 2 * (i + 1)), 16);
    }
    return uint8Array2.buffer.slice(uint8Array2.byteOffset, uint8Array2.byteOffset + uint8Array2.byteLength);
  }
  utf8Encode(string) {
    if (Platform.Config.TextEncoder) {
      return new Platform.Config.TextEncoder().encode(string).buffer;
    } else {
      throw new Error("Expected TextEncoder to be configured");
    }
  }
  /* For utf8 decoding we apply slightly stricter input validation than to
   * hexEncode/base64Encode/etc: in those we accept anything that Buffer.from
   * can take (in particular allowing strings, which are just interpreted as
   * binary); here we ensure that the input is actually a buffer since trying
   * to utf8-decode a string to another string is almost certainly a mistake */
  utf8Decode(buffer) {
    if (!this.isBuffer(buffer)) {
      throw new Error("Expected input of utf8decode to be an arraybuffer or typed array");
    }
    if (TextDecoder) {
      return new TextDecoder().decode(buffer);
    } else {
      throw new Error("Expected TextDecoder to be configured");
    }
  }
  areBuffersEqual(buffer1, buffer2) {
    if (!buffer1 || !buffer2)
      return false;
    const arrayBuffer1 = this.toArrayBuffer(buffer1);
    const arrayBuffer2 = this.toArrayBuffer(buffer2);
    if (arrayBuffer1.byteLength != arrayBuffer2.byteLength)
      return false;
    const bytes1 = new Uint8Array(arrayBuffer1);
    const bytes2 = new Uint8Array(arrayBuffer2);
    for (var i = 0; i < bytes1.length; i++) {
      if (bytes1[i] != bytes2[i])
        return false;
    }
    return true;
  }
  byteLength(buffer) {
    if (buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer)) {
      return buffer.byteLength;
    }
    return -1;
  }
  /* Returns ArrayBuffer on browser and Buffer on Node.js */
  arrayBufferViewToBuffer(arrayBufferView) {
    return arrayBufferView.buffer;
  }
  hmacSha256(message, key) {
    return hmac2(this.toBuffer(key), this.toBuffer(message));
  }
};
var bufferutils_default = new BufferUtils();

// src/common/constants/XHRStates.ts
var XHRStates = /* @__PURE__ */ ((XHRStates2) => {
  XHRStates2[XHRStates2["REQ_SEND"] = 0] = "REQ_SEND";
  XHRStates2[XHRStates2["REQ_RECV"] = 1] = "REQ_RECV";
  XHRStates2[XHRStates2["REQ_RECV_POLL"] = 2] = "REQ_RECV_POLL";
  XHRStates2[XHRStates2["REQ_RECV_STREAM"] = 3] = "REQ_RECV_STREAM";
  return XHRStates2;
})(XHRStates || {});
var XHRStates_default = XHRStates;

// src/platform/web/lib/http/http.ts
function shouldFallback(errorInfo) {
  const statusCode = errorInfo.statusCode;
  return statusCode === 408 && !errorInfo.code || statusCode === 400 && !errorInfo.code || statusCode >= 500 && statusCode <= 504;
}
function getHosts2(client) {
  const connection = client.connection, connectionHost = connection && connection.connectionManager.host;
  if (connectionHost) {
    return [connectionHost].concat(defaults_default.getFallbackHosts(client.options));
  }
  return defaults_default.getHosts(client.options);
}
function createMissingImplementationError() {
  return new ErrorInfo(
    "No HTTP request module provided. Provide at least one of the FetchRequest or XHRRequest modules.",
    400,
    4e4
  );
}
var _a;
var Http = (_a = class {
  constructor(client) {
    this.checksInProgress = null;
    this.checkConnectivity = void 0;
    this.supportsAuthHeaders = false;
    this.supportsLinkHeaders = false;
    this._getHosts = getHosts2;
    var _a2;
    this.client = client != null ? client : null;
    const connectivityCheckUrl = (client == null ? void 0 : client.options.connectivityCheckUrl) || defaults_default.connectivityCheckUrl;
    const connectivityCheckParams = (_a2 = client == null ? void 0 : client.options.connectivityCheckParams) != null ? _a2 : null;
    const connectivityUrlIsDefault = !(client == null ? void 0 : client.options.connectivityCheckUrl);
    const requestImplementations = __spreadValues(__spreadValues({}, Http.bundledRequestImplementations), client == null ? void 0 : client._additionalHTTPRequestImplementations);
    const xhrRequestImplementation = requestImplementations.XHRRequest;
    const fetchRequestImplementation = requestImplementations.FetchRequest;
    const hasImplementation = !!(xhrRequestImplementation || fetchRequestImplementation);
    if (!hasImplementation) {
      throw createMissingImplementationError();
    }
    if (Platform.Config.xhrSupported && xhrRequestImplementation) {
      this.supportsAuthHeaders = true;
      this.Request = function(method, uri, headers, params, body, callback) {
        var _a3;
        const req = xhrRequestImplementation.createRequest(
          uri,
          headers,
          params,
          body,
          XHRStates_default.REQ_SEND,
          (_a3 = client && client.options.timeouts) != null ? _a3 : null,
          method
        );
        req.once("complete", callback);
        req.exec();
        return req;
      };
      if (client == null ? void 0 : client.options.disableConnectivityCheck) {
        this.checkConnectivity = function(callback) {
          callback(null, true);
        };
      } else {
        this.checkConnectivity = function(callback) {
          logger_default.logAction(
            logger_default.LOG_MICRO,
            "(XHRRequest)Http.checkConnectivity()",
            "Sending; " + connectivityCheckUrl
          );
          this.doUri(
            HttpMethods_default.Get,
            connectivityCheckUrl,
            null,
            null,
            connectivityCheckParams,
            function(err, responseText, headers, unpacked, statusCode) {
              let result = false;
              if (!connectivityUrlIsDefault) {
                result = !err && isSuccessCode(statusCode);
              } else {
                result = !err && (responseText == null ? void 0 : responseText.replace(/\n/, "")) == "yes";
              }
              logger_default.logAction(logger_default.LOG_MICRO, "(XHRRequest)Http.checkConnectivity()", "Result: " + result);
              callback(null, result);
            }
          );
        };
      }
    } else if (Platform.Config.fetchSupported && fetchRequestImplementation) {
      this.supportsAuthHeaders = true;
      this.Request = (method, uri, headers, params, body, callback) => {
        fetchRequestImplementation(method, client != null ? client : null, uri, headers, params, body, callback);
      };
      this.checkConnectivity = function(callback) {
        logger_default.logAction(logger_default.LOG_MICRO, "(Fetch)Http.checkConnectivity()", "Sending; " + connectivityCheckUrl);
        this.doUri(HttpMethods_default.Get, connectivityCheckUrl, null, null, null, function(err, responseText) {
          const result = !err && (responseText == null ? void 0 : responseText.replace(/\n/, "")) == "yes";
          logger_default.logAction(logger_default.LOG_MICRO, "(Fetch)Http.checkConnectivity()", "Result: " + result);
          callback(null, result);
        });
      };
    } else {
      this.Request = (method, uri, headers, params, body, callback) => {
        const error = hasImplementation ? new PartialErrorInfo("no supported HTTP transports available", null, 400) : createMissingImplementationError();
        callback(error, null);
      };
    }
  }
  /* Unlike for doUri, the 'client' param here is mandatory, as it's used to generate the hosts */
  do(method, path, headers, body, params, callback) {
    const client = this.client;
    if (!client) {
      throw new Error("http.do called without client");
    }
    const uriFromHost = typeof path == "function" ? path : function(host) {
      return client.baseUri(host) + path;
    };
    const currentFallback = client._currentFallback;
    if (currentFallback) {
      if (currentFallback.validUntil > now()) {
        if (!this.Request) {
          callback == null ? void 0 : callback(new PartialErrorInfo("Request invoked before assigned to", null, 500));
          return;
        }
        this.Request(method, uriFromHost(currentFallback.host), headers, params, body, (err, ...args) => {
          if (err && shouldFallback(err)) {
            client._currentFallback = null;
            this.do(method, path, headers, body, params, callback);
            return;
          }
          callback == null ? void 0 : callback(err, ...args);
        });
        return;
      } else {
        client._currentFallback = null;
      }
    }
    const hosts = getHosts2(client);
    if (hosts.length === 1) {
      this.doUri(method, uriFromHost(hosts[0]), headers, body, params, callback);
      return;
    }
    const tryAHost = (candidateHosts, persistOnSuccess) => {
      const host = candidateHosts.shift();
      this.doUri(method, uriFromHost(host), headers, body, params, function(err, ...args) {
        if (err && shouldFallback(err) && candidateHosts.length) {
          tryAHost(candidateHosts, true);
          return;
        }
        if (persistOnSuccess) {
          client._currentFallback = {
            host,
            validUntil: now() + client.options.timeouts.fallbackRetryTimeout
          };
        }
        callback == null ? void 0 : callback(err, ...args);
      });
    };
    tryAHost(hosts);
  }
  doUri(method, uri, headers, body, params, callback) {
    if (!this.Request) {
      callback(new PartialErrorInfo("Request invoked before assigned to", null, 500));
      return;
    }
    this.Request(method, uri, headers, params, body, callback);
  }
}, _a.methods = [HttpMethods_default.Get, HttpMethods_default.Delete, HttpMethods_default.Post, HttpMethods_default.Put, HttpMethods_default.Patch], _a.methodsWithoutBody = [HttpMethods_default.Get, HttpMethods_default.Delete], _a.methodsWithBody = [HttpMethods_default.Post, HttpMethods_default.Put, HttpMethods_default.Patch], _a);
var http_default = Http;

// src/platform/web/config.ts
var globalObject3 = getGlobalObject();
if (typeof Window === "undefined" && typeof WorkerGlobalScope === "undefined") {
  console.log(
    "Warning: this distribution of Ably is intended for browsers. On nodejs, please use the 'ably' package on npm"
  );
}
function allowComet() {
  const loc = globalObject3.location;
  return !globalObject3.WebSocket || !loc || !loc.origin || loc.origin.indexOf("http") > -1;
}
function isWebWorkerContext() {
  if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) {
    return true;
  } else {
    return false;
  }
}
var userAgent = globalObject3.navigator && globalObject3.navigator.userAgent.toString();
var currentUrl = globalObject3.location && globalObject3.location.href;
var Config = {
  agent: "browser",
  logTimestamps: true,
  userAgent,
  currentUrl,
  noUpgrade: userAgent && !!userAgent.match(/MSIE\s8\.0/),
  binaryType: "arraybuffer",
  WebSocket: globalObject3.WebSocket,
  fetchSupported: !!globalObject3.fetch,
  xhrSupported: globalObject3.XMLHttpRequest && "withCredentials" in new XMLHttpRequest(),
  allowComet: allowComet(),
  streamingSupported: true,
  useProtocolHeartbeats: true,
  supportsBinary: !!globalObject3.TextDecoder,
  preferBinary: false,
  ArrayBuffer: globalObject3.ArrayBuffer,
  atob: globalObject3.atob,
  nextTick: typeof globalObject3.setImmediate !== "undefined" ? globalObject3.setImmediate.bind(globalObject3) : function(f) {
    setTimeout(f, 0);
  },
  addEventListener: globalObject3.addEventListener,
  inspect: JSON.stringify,
  stringByteSize: function(str) {
    return globalObject3.TextDecoder && new globalObject3.TextEncoder().encode(str).length || str.length;
  },
  TextEncoder: globalObject3.TextEncoder,
  TextDecoder: globalObject3.TextDecoder,
  getRandomValues: function(crypto2) {
    if (crypto2 === void 0) {
      return void 0;
    }
    return function(arr, callback) {
      crypto2.getRandomValues(arr);
      if (callback) {
        callback(null);
      }
    };
  }(globalObject3.crypto || msCrypto),
  isWebworker: isWebWorkerContext()
};
var config_default = Config;

// src/common/lib/transport/comettransport.ts
function shouldBeErrorAction(err) {
  const UNRESOLVABLE_ERROR_CODES = [80015, 80017, 80030];
  if (err.code) {
    if (auth_default.isTokenErr(err))
      return false;
    if (arrIn(UNRESOLVABLE_ERROR_CODES, err.code))
      return true;
    return err.code >= 4e4 && err.code < 5e4;
  } else {
    return false;
  }
}
function protocolMessageFromRawError(err) {
  if (shouldBeErrorAction(err)) {
    return [fromValues3({ action: actions2.ERROR, error: err })];
  } else {
    return [fromValues3({ action: actions2.DISCONNECTED, error: err })];
  }
}
var CometTransport = class extends transport_default {
  constructor(connectionManager, auth, params) {
    super(
      connectionManager,
      auth,
      params,
      /* binary not supported for comet so force JSON protocol */
      true
    );
    /* Historical comment, back from when we supported JSONP:
     *
     * > For comet, we could do the auth update by aborting the current recv and
     * > starting a new one with the new token, that'd be sufficient for realtime.
     * > Problem is JSONP - you can't cancel truly abort a recv once started. So
     * > we need to send an AUTH for jsonp. In which case it's simpler to keep all
     * > comet transports the same and do it for all of them. So we send the AUTH
     * > instead, and don't need to abort the recv
     *
     * Now that we’ve dropped JSONP support, we may be able to revisit the above;
     * see https://github.com/ably/ably-js/issues/1214.
     */
    this.onAuthUpdated = (tokenDetails) => {
      this.authParams = { access_token: tokenDetails.token };
    };
    this.stream = "stream" in params ? params.stream : true;
    this.sendRequest = null;
    this.recvRequest = null;
    this.pendingCallback = null;
    this.pendingItems = null;
  }
  connect() {
    logger_default.logAction(logger_default.LOG_MINOR, "CometTransport.connect()", "starting");
    transport_default.prototype.connect.call(this);
    const params = this.params;
    const options = params.options;
    const host = defaults_default.getHost(options, params.host);
    const port = defaults_default.getPort(options);
    const cometScheme = options.tls ? "https://" : "http://";
    this.baseUri = cometScheme + host + ":" + port + "/comet/";
    const connectUri = this.baseUri + "connect";
    logger_default.logAction(logger_default.LOG_MINOR, "CometTransport.connect()", "uri: " + connectUri);
    this.auth.getAuthParams((err, authParams) => {
      if (err) {
        this.disconnect(err);
        return;
      }
      if (this.isDisposed) {
        return;
      }
      this.authParams = authParams;
      const connectParams = this.params.getConnectParams(authParams);
      if ("stream" in connectParams)
        this.stream = connectParams.stream;
      logger_default.logAction(
        logger_default.LOG_MINOR,
        "CometTransport.connect()",
        "connectParams:" + toQueryString(connectParams)
      );
      let preconnected = false;
      const connectRequest = this.recvRequest = this.createRequest(
        connectUri,
        null,
        connectParams,
        null,
        this.stream ? XHRStates_default.REQ_RECV_STREAM : XHRStates_default.REQ_RECV
      );
      connectRequest.on("data", (data) => {
        if (!this.recvRequest) {
          return;
        }
        if (!preconnected) {
          preconnected = true;
          this.emit("preconnect");
        }
        this.onData(data);
      });
      connectRequest.on("complete", (err2) => {
        if (!this.recvRequest) {
          err2 = err2 || new ErrorInfo("Request cancelled", 80003, 400);
        }
        this.recvRequest = null;
        if (!preconnected && !err2) {
          preconnected = true;
          this.emit("preconnect");
        }
        this.onActivity();
        if (err2) {
          if (err2.code) {
            this.onData(protocolMessageFromRawError(err2));
          } else {
            this.disconnect(err2);
          }
          return;
        }
        Platform.Config.nextTick(() => {
          this.recv();
        });
      });
      connectRequest.exec();
    });
  }
  requestClose() {
    logger_default.logAction(logger_default.LOG_MINOR, "CometTransport.requestClose()");
    this._requestCloseOrDisconnect(true);
  }
  requestDisconnect() {
    logger_default.logAction(logger_default.LOG_MINOR, "CometTransport.requestDisconnect()");
    this._requestCloseOrDisconnect(false);
  }
  _requestCloseOrDisconnect(closing) {
    const closeOrDisconnectUri = closing ? this.closeUri : this.disconnectUri;
    if (closeOrDisconnectUri) {
      const request = this.createRequest(closeOrDisconnectUri, null, this.authParams, null, XHRStates_default.REQ_SEND);
      request.on("complete", (err) => {
        if (err) {
          logger_default.logAction(
            logger_default.LOG_ERROR,
            "CometTransport.request" + (closing ? "Close()" : "Disconnect()"),
            "request returned err = " + inspectError(err)
          );
          this.finish("disconnected", err);
        }
      });
      request.exec();
    }
  }
  dispose() {
    logger_default.logAction(logger_default.LOG_MINOR, "CometTransport.dispose()", "");
    if (!this.isDisposed) {
      this.isDisposed = true;
      if (this.recvRequest) {
        logger_default.logAction(logger_default.LOG_MINOR, "CometTransport.dispose()", "aborting recv request");
        this.recvRequest.abort();
        this.recvRequest = null;
      }
      this.finish("disconnected", connectionerrors_default.disconnected());
      Platform.Config.nextTick(() => {
        this.emit("disposed");
      });
    }
  }
  onConnect(message) {
    var _a2;
    if (this.isDisposed) {
      return;
    }
    const connectionStr = (_a2 = message.connectionDetails) == null ? void 0 : _a2.connectionKey;
    transport_default.prototype.onConnect.call(this, message);
    const baseConnectionUri = this.baseUri + connectionStr;
    logger_default.logAction(logger_default.LOG_MICRO, "CometTransport.onConnect()", "baseUri = " + baseConnectionUri);
    this.sendUri = baseConnectionUri + "/send";
    this.recvUri = baseConnectionUri + "/recv";
    this.closeUri = baseConnectionUri + "/close";
    this.disconnectUri = baseConnectionUri + "/disconnect";
  }
  send(message) {
    if (this.sendRequest) {
      this.pendingItems = this.pendingItems || [];
      this.pendingItems.push(message);
      return;
    }
    const pendingItems = this.pendingItems || [];
    pendingItems.push(message);
    this.pendingItems = null;
    this.sendItems(pendingItems);
  }
  sendAnyPending() {
    const pendingItems = this.pendingItems;
    if (!pendingItems) {
      return;
    }
    this.pendingItems = null;
    this.sendItems(pendingItems);
  }
  sendItems(items) {
    const sendRequest = this.sendRequest = this.createRequest(
      this.sendUri,
      null,
      this.authParams,
      this.encodeRequest(items),
      XHRStates_default.REQ_SEND
    );
    sendRequest.on("complete", (err, data) => {
      if (err)
        logger_default.logAction(
          logger_default.LOG_ERROR,
          "CometTransport.sendItems()",
          "on complete: err = " + inspectError(err)
        );
      this.sendRequest = null;
      if (err) {
        if (err.code) {
          this.onData(protocolMessageFromRawError(err));
        } else {
          this.disconnect(err);
        }
        return;
      }
      if (data) {
        this.onData(data);
      }
      if (this.pendingItems) {
        Platform.Config.nextTick(() => {
          if (!this.sendRequest) {
            this.sendAnyPending();
          }
        });
      }
    });
    sendRequest.exec();
  }
  recv() {
    if (this.recvRequest)
      return;
    if (!this.isConnected)
      return;
    const recvRequest = this.recvRequest = this.createRequest(
      this.recvUri,
      null,
      this.authParams,
      null,
      this.stream ? XHRStates_default.REQ_RECV_STREAM : XHRStates_default.REQ_RECV_POLL
    );
    recvRequest.on("data", (data) => {
      this.onData(data);
    });
    recvRequest.on("complete", (err) => {
      this.recvRequest = null;
      this.onActivity();
      if (err) {
        if (err.code) {
          this.onData(protocolMessageFromRawError(err));
        } else {
          this.disconnect(err);
        }
        return;
      }
      Platform.Config.nextTick(() => {
        this.recv();
      });
    });
    recvRequest.exec();
  }
  onData(responseData) {
    try {
      const items = this.decodeResponse(responseData);
      if (items && items.length)
        for (let i = 0; i < items.length; i++)
          this.onProtocolMessage(
            fromDeserialized(items[i], this.connectionManager.realtime._RealtimePresence)
          );
    } catch (e) {
      logger_default.logAction(
        logger_default.LOG_ERROR,
        "CometTransport.onData()",
        "Unexpected exception handing channel event: " + e.stack
      );
    }
  }
  encodeRequest(requestItems) {
    return JSON.stringify(requestItems);
  }
  decodeResponse(responseData) {
    if (typeof responseData == "string")
      return JSON.parse(responseData);
    return responseData;
  }
};
var comettransport_default = CometTransport;

// src/platform/web/lib/http/request/xhrrequest.ts
function isAblyError(responseBody, headers) {
  return arrIn(allToLowerCase(keysArray(headers)), "x-ably-errorcode");
}
function getAblyError(responseBody, headers) {
  if (isAblyError(responseBody, headers)) {
    return responseBody.error && ErrorInfo.fromValues(responseBody.error);
  }
}
var noop6 = function() {
};
var idCounter = 0;
var pendingRequests = {};
var isIE = typeof global !== "undefined" && global.XDomainRequest;
function ieVersion() {
  const match = navigator.userAgent.toString().match(/MSIE\s([\d.]+)/);
  return match && Number(match[1]);
}
function needJsonEnvelope() {
  let version2;
  return isIE && (version2 = ieVersion()) && version2 === 10;
}
function getHeader(xhr, header) {
  return xhr.getResponseHeader && xhr.getResponseHeader(header);
}
function isEncodingChunked(xhr) {
  return xhr.getResponseHeader && (xhr.getResponseHeader("transfer-encoding") || !xhr.getResponseHeader("content-length"));
}
function getHeadersAsObject(xhr) {
  const headerPairs = trim(xhr.getAllResponseHeaders()).split("\r\n");
  const headers = {};
  for (let i = 0; i < headerPairs.length; i++) {
    const parts = headerPairs[i].split(":").map(trim);
    headers[parts[0].toLowerCase()] = parts[1];
  }
  return headers;
}
var XHRRequest = class _XHRRequest extends eventemitter_default {
  constructor(uri, headers, params, body, requestMode, timeouts, method) {
    super();
    params = params || {};
    params.rnd = cheapRandStr();
    if (needJsonEnvelope() && !params.envelope)
      params.envelope = "json";
    this.uri = uri + toQueryString(params);
    this.headers = headers || {};
    this.body = body;
    this.method = method ? method.toUpperCase() : isEmptyArg(body) ? "GET" : "POST";
    this.requestMode = requestMode;
    this.timeouts = timeouts;
    this.timedOut = false;
    this.requestComplete = false;
    this.id = String(++idCounter);
    pendingRequests[this.id] = this;
  }
  static createRequest(uri, headers, params, body, requestMode, timeouts, method) {
    const _timeouts = timeouts || defaults_default.TIMEOUTS;
    return new _XHRRequest(
      uri,
      headers,
      copy(params),
      body,
      requestMode,
      _timeouts,
      method
    );
  }
  complete(err, body, headers, unpacked, statusCode) {
    if (!this.requestComplete) {
      this.requestComplete = true;
      if (!err && body) {
        this.emit("data", body);
      }
      this.emit("complete", err, body, headers, unpacked, statusCode);
      this.dispose();
    }
  }
  abort() {
    this.dispose();
  }
  exec() {
    let headers = this.headers;
    const timeout = this.requestMode == XHRStates_default.REQ_SEND ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout, timer = this.timer = setTimeout(() => {
      this.timedOut = true;
      xhr.abort();
    }, timeout), method = this.method, xhr = this.xhr = new XMLHttpRequest(), accept = headers["accept"];
    let body = this.body;
    let responseType = "text";
    if (!accept) {
      headers["accept"] = "application/json";
    } else if (accept.indexOf("application/x-msgpack") === 0) {
      responseType = "arraybuffer";
    }
    if (body) {
      const contentType = headers["content-type"] || (headers["content-type"] = "application/json");
      if (contentType.indexOf("application/json") > -1 && typeof body != "string")
        body = JSON.stringify(body);
    }
    xhr.open(method, this.uri, true);
    xhr.responseType = responseType;
    if ("authorization" in headers) {
      xhr.withCredentials = true;
    }
    for (const h in headers)
      xhr.setRequestHeader(h, headers[h]);
    const errorHandler = (errorEvent, message, code, statusCode2) => {
      var _a2;
      let errorMessage = message + " (event type: " + errorEvent.type + ")";
      if ((_a2 = this == null ? void 0 : this.xhr) == null ? void 0 : _a2.statusText)
        errorMessage += ", current statusText is " + this.xhr.statusText;
      logger_default.logAction(logger_default.LOG_ERROR, "Request.on" + errorEvent.type + "()", errorMessage);
      this.complete(new PartialErrorInfo(errorMessage, code, statusCode2));
    };
    xhr.onerror = function(errorEvent) {
      errorHandler(errorEvent, "XHR error occurred", null, 400);
    };
    xhr.onabort = (errorEvent) => {
      if (this.timedOut) {
        errorHandler(errorEvent, "Request aborted due to request timeout expiring", null, 408);
      } else {
        errorHandler(errorEvent, "Request cancelled", null, 400);
      }
    };
    xhr.ontimeout = function(errorEvent) {
      errorHandler(errorEvent, "Request timed out", null, 408);
    };
    let streaming;
    let statusCode;
    let successResponse;
    let streamPos = 0;
    let unpacked = false;
    const onResponse = () => {
      clearTimeout(timer);
      successResponse = statusCode < 400;
      if (statusCode == 204) {
        this.complete(null, null, null, null, statusCode);
        return;
      }
      streaming = this.requestMode == XHRStates_default.REQ_RECV_STREAM && successResponse && isEncodingChunked(xhr);
    };
    const onEnd = () => {
      let parsedResponse;
      try {
        const contentType = getHeader(xhr, "content-type");
        const json = contentType ? contentType.indexOf("application/json") >= 0 : xhr.responseType == "text";
        if (json) {
          const jsonResponseBody = xhr.responseType === "arraybuffer" ? Platform.BufferUtils.utf8Decode(xhr.response) : String(xhr.responseText);
          if (jsonResponseBody.length) {
            parsedResponse = JSON.parse(jsonResponseBody);
          } else {
            parsedResponse = jsonResponseBody;
          }
          unpacked = true;
        } else {
          parsedResponse = xhr.response;
        }
        if (parsedResponse.response !== void 0) {
          statusCode = parsedResponse.statusCode;
          successResponse = statusCode < 400;
          headers = parsedResponse.headers;
          parsedResponse = parsedResponse.response;
        } else {
          headers = getHeadersAsObject(xhr);
        }
      } catch (e) {
        this.complete(new PartialErrorInfo("Malformed response body from server: " + e.message, null, 400));
        return;
      }
      if (successResponse || isArray(parsedResponse)) {
        this.complete(null, parsedResponse, headers, unpacked, statusCode);
        return;
      }
      let err = getAblyError(parsedResponse, headers);
      if (!err) {
        err = new PartialErrorInfo(
          "Error response received from server: " + statusCode + " body was: " + Platform.Config.inspect(parsedResponse),
          null,
          statusCode
        );
      }
      this.complete(err, parsedResponse, headers, unpacked, statusCode);
    };
    function onProgress() {
      const responseText = xhr.responseText;
      const bodyEnd = responseText.length - 1;
      let idx, chunk;
      while (streamPos < bodyEnd && (idx = responseText.indexOf("\n", streamPos)) > -1) {
        chunk = responseText.slice(streamPos, idx);
        streamPos = idx + 1;
        onChunk(chunk);
      }
    }
    const onChunk = (chunk) => {
      try {
        chunk = JSON.parse(chunk);
      } catch (e) {
        this.complete(new PartialErrorInfo("Malformed response body from server: " + e.message, null, 400));
        return;
      }
      this.emit("data", chunk);
    };
    const onStreamEnd = () => {
      onProgress();
      this.streamComplete = true;
      Platform.Config.nextTick(() => {
        this.complete();
      });
    };
    xhr.onreadystatechange = function() {
      const readyState = xhr.readyState;
      if (readyState < 3)
        return;
      if (xhr.status !== 0) {
        if (statusCode === void 0) {
          statusCode = xhr.status;
          if (statusCode === 1223)
            statusCode = 204;
          onResponse();
        }
        if (readyState == 3 && streaming) {
          onProgress();
        } else if (readyState == 4) {
          if (streaming)
            onStreamEnd();
          else
            onEnd();
        }
      }
    };
    xhr.send(body);
  }
  dispose() {
    const xhr = this.xhr;
    if (xhr) {
      xhr.onreadystatechange = xhr.onerror = xhr.onabort = xhr.ontimeout = noop6;
      this.xhr = null;
      const timer = this.timer;
      if (timer) {
        clearTimeout(timer);
        this.timer = null;
      }
      if (!this.requestComplete)
        xhr.abort();
    }
    delete pendingRequests[this.id];
  }
};
var xhrrequest_default = XHRRequest;

// src/platform/web/lib/transport/xhrpollingtransport.ts
var shortName = TransportNames.XhrPolling;
var XHRPollingTransport = class extends comettransport_default {
  constructor(connectionManager, auth, params) {
    super(connectionManager, auth, params);
    this.shortName = shortName;
    params.stream = false;
    this.shortName = shortName;
  }
  static isAvailable() {
    return Platform.Config.xhrSupported && Platform.Config.allowComet;
  }
  toString() {
    return "XHRPollingTransport; uri=" + this.baseUri + "; isConnected=" + this.isConnected;
  }
  createRequest(uri, headers, params, body, requestMode) {
    return xhrrequest_default.createRequest(uri, headers, params, body, requestMode, this.timeouts);
  }
};
function initialiseTransport(transportStorage) {
  if (XHRPollingTransport.isAvailable())
    transportStorage.supportedTransports[shortName] = XHRPollingTransport;
  return XHRPollingTransport;
}
var xhrpollingtransport_default = initialiseTransport;

// src/platform/web/lib/transport/xhrstreamingtransport.ts
var shortName2 = TransportNames.XhrStreaming;
var XHRStreamingTransport = class extends comettransport_default {
  constructor(connectionManager, auth, params) {
    super(connectionManager, auth, params);
    this.shortName = shortName2;
  }
  static isAvailable() {
    return Platform.Config.xhrSupported && Platform.Config.streamingSupported && Platform.Config.allowComet;
  }
  toString() {
    return "XHRStreamingTransport; uri=" + this.baseUri + "; isConnected=" + this.isConnected;
  }
  createRequest(uri, headers, params, body, requestMode) {
    return xhrrequest_default.createRequest(uri, headers, params, body, requestMode, this.timeouts);
  }
};
function initialiseTransport2(transportStorage) {
  if (XHRStreamingTransport.isAvailable())
    transportStorage.supportedTransports[shortName2] = XHRStreamingTransport;
  return XHRStreamingTransport;
}
var xhrstreamingtransport_default = initialiseTransport2;

// src/common/lib/transport/websockettransport.ts
var shortName3 = TransportNames.WebSocket;
function isNodeWebSocket(ws) {
  return !!ws.on;
}
var WebSocketTransport = class extends transport_default {
  constructor(connectionManager, auth, params) {
    super(connectionManager, auth, params);
    this.shortName = shortName3;
    params.heartbeats = Platform.Config.useProtocolHeartbeats;
    this.wsHost = defaults_default.getHost(params.options, params.host, true);
  }
  static isAvailable() {
    return !!Platform.Config.WebSocket;
  }
  createWebSocket(uri, connectParams) {
    this.uri = uri + toQueryString(connectParams);
    return new Platform.Config.WebSocket(this.uri);
  }
  toString() {
    return "WebSocketTransport; uri=" + this.uri;
  }
  connect() {
    logger_default.logAction(logger_default.LOG_MINOR, "WebSocketTransport.connect()", "starting");
    transport_default.prototype.connect.call(this);
    const self2 = this, params = this.params, options = params.options;
    const wsScheme = options.tls ? "wss://" : "ws://";
    const wsUri = wsScheme + this.wsHost + ":" + defaults_default.getPort(options) + "/";
    logger_default.logAction(logger_default.LOG_MINOR, "WebSocketTransport.connect()", "uri: " + wsUri);
    this.auth.getAuthParams(function(err, authParams) {
      if (self2.isDisposed) {
        return;
      }
      let paramStr = "";
      for (const param in authParams)
        paramStr += " " + param + ": " + authParams[param] + ";";
      logger_default.logAction(logger_default.LOG_MINOR, "WebSocketTransport.connect()", "authParams:" + paramStr + " err: " + err);
      if (err) {
        self2.disconnect(err);
        return;
      }
      const connectParams = params.getConnectParams(authParams);
      try {
        const wsConnection = self2.wsConnection = self2.createWebSocket(wsUri, connectParams);
        wsConnection.binaryType = Platform.Config.binaryType;
        wsConnection.onopen = function() {
          self2.onWsOpen();
        };
        wsConnection.onclose = function(ev) {
          self2.onWsClose(ev);
        };
        wsConnection.onmessage = function(ev) {
          self2.onWsData(ev.data);
        };
        wsConnection.onerror = function(ev) {
          self2.onWsError(ev);
        };
        if (isNodeWebSocket(wsConnection)) {
          wsConnection.on("ping", function() {
            self2.onActivity();
          });
        }
      } catch (e) {
        logger_default.logAction(
          logger_default.LOG_ERROR,
          "WebSocketTransport.connect()",
          "Unexpected exception creating websocket: err = " + (e.stack || e.message)
        );
        self2.disconnect(e);
      }
    });
  }
  send(message) {
    const wsConnection = this.wsConnection;
    if (!wsConnection) {
      logger_default.logAction(logger_default.LOG_ERROR, "WebSocketTransport.send()", "No socket connection");
      return;
    }
    try {
      wsConnection.send(
        serialize2(message, this.connectionManager.realtime._MsgPack, this.params.format)
      );
    } catch (e) {
      const msg = "Exception from ws connection when trying to send: " + inspectError(e);
      logger_default.logAction(logger_default.LOG_ERROR, "WebSocketTransport.send()", msg);
      this.finish("disconnected", new ErrorInfo(msg, 5e4, 500));
    }
  }
  onWsData(data) {
    logger_default.logAction(
      logger_default.LOG_MICRO,
      "WebSocketTransport.onWsData()",
      "data received; length = " + data.length + "; type = " + typeof data
    );
    try {
      this.onProtocolMessage(
        deserialize(
          data,
          this.connectionManager.realtime._MsgPack,
          this.connectionManager.realtime._RealtimePresence,
          this.format
        )
      );
    } catch (e) {
      logger_default.logAction(
        logger_default.LOG_ERROR,
        "WebSocketTransport.onWsData()",
        "Unexpected exception handing channel message: " + e.stack
      );
    }
  }
  onWsOpen() {
    logger_default.logAction(logger_default.LOG_MINOR, "WebSocketTransport.onWsOpen()", "opened WebSocket");
    this.emit("preconnect");
  }
  onWsClose(ev) {
    let wasClean, code;
    if (typeof ev == "object") {
      code = ev.code;
      wasClean = ev.wasClean || code === 1e3;
    } else {
      code = ev;
      wasClean = code == 1e3;
    }
    delete this.wsConnection;
    if (wasClean) {
      logger_default.logAction(logger_default.LOG_MINOR, "WebSocketTransport.onWsClose()", "Cleanly closed WebSocket");
      const err = new ErrorInfo("Websocket closed", 80003, 400);
      this.finish("disconnected", err);
    } else {
      const msg = "Unclean disconnection of WebSocket ; code = " + code, err = new ErrorInfo(msg, 80003, 400);
      logger_default.logAction(logger_default.LOG_MINOR, "WebSocketTransport.onWsClose()", msg);
      this.finish("disconnected", err);
    }
    this.emit("disposed");
  }
  onWsError(err) {
    logger_default.logAction(logger_default.LOG_MINOR, "WebSocketTransport.onError()", "Error from WebSocket: " + err.message);
    Platform.Config.nextTick(() => {
      this.disconnect(Error(err.message));
    });
  }
  dispose() {
    logger_default.logAction(logger_default.LOG_MINOR, "WebSocketTransport.dispose()", "");
    this.isDisposed = true;
    const wsConnection = this.wsConnection;
    if (wsConnection) {
      wsConnection.onmessage = function() {
      };
      delete this.wsConnection;
      Platform.Config.nextTick(function() {
        logger_default.logAction(logger_default.LOG_MICRO, "WebSocketTransport.dispose()", "closing websocket");
        if (!wsConnection) {
          throw new Error("WebSocketTransport.dispose(): wsConnection is not defined");
        }
        wsConnection.close();
      });
    }
  }
};
function initialiseTransport3(transportStorage) {
  if (WebSocketTransport.isAvailable())
    transportStorage.supportedTransports[shortName3] = WebSocketTransport;
  return WebSocketTransport;
}
var websockettransport_default = initialiseTransport3;

// src/platform/web/lib/transport/index.ts
var order = ["xhr_polling", "xhr_streaming"];
var ModulesTransports = {
  order,
  bundledImplementations: {}
};

// src/platform/web/lib/util/webstorage.ts
var test = "ablyjs-storage-test";
var globalObject4 = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : self;
var Webstorage = class {
  constructor() {
    try {
      globalObject4.sessionStorage.setItem(test, test);
      globalObject4.sessionStorage.removeItem(test);
      this.sessionSupported = true;
    } catch (e) {
      this.sessionSupported = false;
    }
    try {
      globalObject4.localStorage.setItem(test, test);
      globalObject4.localStorage.removeItem(test);
      this.localSupported = true;
    } catch (e) {
      this.localSupported = false;
    }
  }
  get(name) {
    return this._get(name, false);
  }
  getSession(name) {
    return this._get(name, true);
  }
  remove(name) {
    return this._remove(name, false);
  }
  removeSession(name) {
    return this._remove(name, true);
  }
  set(name, value, ttl) {
    return this._set(name, value, ttl, false);
  }
  setSession(name, value, ttl) {
    return this._set(name, value, ttl, true);
  }
  _set(name, value, ttl, session) {
    const wrappedValue = { value };
    if (ttl) {
      wrappedValue.expires = now() + ttl;
    }
    return this.storageInterface(session).setItem(name, JSON.stringify(wrappedValue));
  }
  _get(name, session) {
    if (session && !this.sessionSupported)
      throw new Error("Session Storage not supported");
    if (!session && !this.localSupported)
      throw new Error("Local Storage not supported");
    const rawItem = this.storageInterface(session).getItem(name);
    if (!rawItem)
      return null;
    const wrappedValue = JSON.parse(rawItem);
    if (wrappedValue.expires && wrappedValue.expires < now()) {
      this.storageInterface(session).removeItem(name);
      return null;
    }
    return wrappedValue.value;
  }
  _remove(name, session) {
    return this.storageInterface(session).removeItem(name);
  }
  storageInterface(session) {
    return session ? globalObject4.sessionStorage : globalObject4.localStorage;
  }
};
var webstorage_default = new Webstorage();

// src/platform/web/lib/util/defaults.ts
var Defaults2 = {
  connectivityCheckUrl: "https://internet-up.ably-realtime.com/is-the-internet-up.txt",
  /* Order matters here: the base transport is the leftmost one in the
   * intersection of baseTransportOrder and the transports clientOption that's
   * supported. */
  defaultTransports: [TransportNames.XhrPolling, TransportNames.XhrStreaming, TransportNames.WebSocket],
  baseTransportOrder: [TransportNames.XhrPolling, TransportNames.XhrStreaming, TransportNames.WebSocket],
  transportPreferenceOrder: [TransportNames.XhrPolling, TransportNames.XhrStreaming, TransportNames.WebSocket],
  upgradeTransports: [TransportNames.XhrStreaming, TransportNames.WebSocket]
};
var defaults_default2 = Defaults2;

// src/platform/web/lib/http/request/fetchrequest.ts
function isAblyError2(responseBody, headers) {
  return !!headers.get("x-ably-errorcode");
}
function getAblyError2(responseBody, headers) {
  if (isAblyError2(responseBody, headers)) {
    return responseBody.error && ErrorInfo.fromValues(responseBody.error);
  }
}
function convertHeaders(headers) {
  const result = {};
  headers.forEach((value, key) => {
    result[key] = value;
  });
  return result;
}
function fetchRequest(method, client, uri, headers, params, body, callback) {
  const fetchHeaders = new Headers(headers || {});
  const _method = method ? method.toUpperCase() : isEmptyArg(body) ? "GET" : "POST";
  const controller = new AbortController();
  const timeout = setTimeout(
    () => {
      controller.abort();
      callback(new PartialErrorInfo("Request timed out", null, 408));
    },
    client ? client.options.timeouts.httpRequestTimeout : defaults_default.TIMEOUTS.httpRequestTimeout
  );
  const requestInit = {
    method: _method,
    headers: fetchHeaders,
    body
  };
  if (!Platform.Config.isWebworker) {
    requestInit.credentials = fetchHeaders.has("authorization") ? "include" : "same-origin";
  }
  getGlobalObject().fetch(uri + "?" + new URLSearchParams(params || {}), requestInit).then((res) => {
    clearTimeout(timeout);
    const contentType = res.headers.get("Content-Type");
    let prom;
    if (contentType && contentType.indexOf("application/x-msgpack") > -1) {
      prom = res.arrayBuffer();
    } else if (contentType && contentType.indexOf("application/json") > -1) {
      prom = res.json();
    } else {
      prom = res.text();
    }
    prom.then((body2) => {
      const unpacked = !!contentType && contentType.indexOf("application/x-msgpack") === -1;
      const headers2 = convertHeaders(res.headers);
      if (!res.ok) {
        const err = getAblyError2(body2, res.headers) || new PartialErrorInfo(
          "Error response received from server: " + res.status + " body was: " + Platform.Config.inspect(body2),
          null,
          res.status
        );
        callback(err, body2, headers2, unpacked, res.status);
      } else {
        callback(null, body2, headers2, unpacked, res.status);
      }
    });
  }).catch((err) => {
    clearTimeout(timeout);
    callback(err);
  });
}

// src/platform/web/lib/http/request/index.ts
var modulesBundledRequestImplementations = {};

// src/platform/web/lib/util/crypto.ts
var createCryptoClass = function(config, bufferUtils) {
  var DEFAULT_ALGORITHM = "aes";
  var DEFAULT_KEYLENGTH = 256;
  var DEFAULT_MODE = "cbc";
  var DEFAULT_BLOCKLENGTH = 16;
  var DEFAULT_BLOCKLENGTH_WORDS = 4;
  var UINT32_SUP = 4294967296;
  var generateRandom;
  if (config.getRandomArrayBuffer) {
    generateRandom = config.getRandomArrayBuffer;
  } else if (typeof Uint32Array !== "undefined" && config.getRandomValues) {
    var blockRandomArray = new Uint32Array(DEFAULT_BLOCKLENGTH_WORDS);
    generateRandom = function(bytes, callback) {
      var words = bytes / 4, nativeArray = words == DEFAULT_BLOCKLENGTH_WORDS ? blockRandomArray : new Uint32Array(words);
      config.getRandomValues(nativeArray, function(err) {
        if (typeof callback !== "undefined") {
          callback(err, bufferUtils.toArrayBuffer(nativeArray));
        }
      });
    };
  } else {
    generateRandom = function(bytes, callback) {
      logger_default.logAction(
        logger_default.LOG_MAJOR,
        "Ably.Crypto.generateRandom()",
        "Warning: the browser you are using does not support secure cryptographically secure randomness generation; falling back to insecure Math.random()"
      );
      var words = bytes / 4, array = new Uint32Array(words);
      for (var i = 0; i < words; i++) {
        array[i] = Math.floor(Math.random() * UINT32_SUP);
      }
      callback(null, bufferUtils.toArrayBuffer(array));
    };
  }
  function validateCipherParams(params) {
    if (params.algorithm === "aes" && params.mode === "cbc") {
      if (params.keyLength === 128 || params.keyLength === 256) {
        return;
      }
      throw new Error(
        "Unsupported key length " + params.keyLength + " for aes-cbc encryption. Encryption key must be 128 or 256 bits (16 or 32 ASCII characters)"
      );
    }
  }
  function normaliseBase64(string) {
    return string.replace("_", "/").replace("-", "+");
  }
  function isCipherParams(params) {
    return params instanceof CipherParams;
  }
  class CipherParams {
    constructor(algorithm, keyLength, mode, key) {
      this.algorithm = algorithm;
      this.keyLength = keyLength;
      this.mode = mode;
      this.key = key;
    }
  }
  class Crypto2 {
    /**
     * Obtain a complete CipherParams instance from the provided params, filling
     * in any not provided with default values, calculating a keyLength from
     * the supplied key, and validating the result.
     * @param params an object containing at a minimum a `key` key with value the
     * key, as either a binary or a base64-encoded string.
     * May optionally also contain: algorithm (defaults to AES),
     * mode (defaults to 'cbc')
     */
    static getDefaultParams(params) {
      var key;
      if (!params.key) {
        throw new Error("Crypto.getDefaultParams: a key is required");
      }
      if (typeof params.key === "string") {
        key = bufferUtils.toArrayBuffer(bufferUtils.base64Decode(normaliseBase64(params.key)));
      } else if (params.key instanceof ArrayBuffer) {
        key = params.key;
      } else {
        key = bufferUtils.toArrayBuffer(params.key);
      }
      var algorithm = params.algorithm || DEFAULT_ALGORITHM;
      var keyLength = key.byteLength * 8;
      var mode = params.mode || DEFAULT_MODE;
      var cipherParams = new CipherParams(algorithm, keyLength, mode, key);
      if (params.keyLength && params.keyLength !== cipherParams.keyLength) {
        throw new Error(
          "Crypto.getDefaultParams: a keyLength of " + params.keyLength + " was specified, but the key actually has length " + cipherParams.keyLength
        );
      }
      validateCipherParams(cipherParams);
      return cipherParams;
    }
    /**
     * Generate a random encryption key from the supplied keylength (or the
     * default keyLength if none supplied) as an ArrayBuffer
     * @param keyLength (optional) the required keyLength in bits
     */
    static generateRandomKey(keyLength) {
      return __async(this, null, function* () {
        return new Promise((resolve, reject) => {
          generateRandom((keyLength || DEFAULT_KEYLENGTH) / 8, function(err, buf) {
            if (err) {
              const errorInfo = new ErrorInfo("Failed to generate random key: " + err.message, 400, 5e4, err);
              reject(errorInfo);
            } else {
              resolve(buf);
            }
          });
        });
      });
    }
    /**
     * Internal; get a ChannelCipher instance based on the given cipherParams
     * @param params either a CipherParams instance or some subset of its
     * fields that includes a key
     */
    static getCipher(params) {
      var _a2;
      var cipherParams = isCipherParams(params) ? params : this.getDefaultParams(params);
      return {
        cipherParams,
        cipher: new CBCCipher(cipherParams, (_a2 = params.iv) != null ? _a2 : null)
      };
    }
  }
  Crypto2.CipherParams = CipherParams;
  Crypto2;
  class CBCCipher {
    constructor(params, iv) {
      if (!crypto.subtle) {
        if (isSecureContext) {
          throw new Error(
            "Crypto operations are not possible since the browser\u2019s SubtleCrypto class is unavailable (reason unknown)."
          );
        } else {
          throw new Error(
            "Crypto operations are is not possible since the current environment is a non-secure context and hence the browser\u2019s SubtleCrypto class is not available."
          );
        }
      }
      this.algorithm = params.algorithm + "-" + String(params.keyLength) + "-" + params.mode;
      this.webCryptoAlgorithm = params.algorithm + "-" + params.mode;
      this.key = bufferUtils.toArrayBuffer(params.key);
      this.iv = iv ? bufferUtils.toArrayBuffer(iv) : null;
    }
    concat(buffer1, buffer2) {
      const output = new ArrayBuffer(buffer1.byteLength + buffer2.byteLength);
      const outputView = new DataView(output);
      const buffer1View = new DataView(bufferUtils.toArrayBuffer(buffer1));
      for (let i = 0; i < buffer1View.byteLength; i++) {
        outputView.setInt8(i, buffer1View.getInt8(i));
      }
      const buffer2View = new DataView(bufferUtils.toArrayBuffer(buffer2));
      for (let i = 0; i < buffer2View.byteLength; i++) {
        outputView.setInt8(buffer1View.byteLength + i, buffer2View.getInt8(i));
      }
      return output;
    }
    encrypt(plaintext, callback) {
      logger_default.logAction(logger_default.LOG_MICRO, "CBCCipher.encrypt()", "");
      const encryptAsync = () => __async(this, null, function* () {
        const iv = yield new Promise((resolve, reject) => {
          this.getIv((error, iv2) => {
            if (error) {
              reject(error);
            } else {
              resolve(iv2);
            }
          });
        });
        const cryptoKey = yield crypto.subtle.importKey("raw", this.key, this.webCryptoAlgorithm, false, ["encrypt"]);
        const ciphertext = yield crypto.subtle.encrypt({ name: this.webCryptoAlgorithm, iv }, cryptoKey, plaintext);
        return this.concat(iv, ciphertext);
      });
      encryptAsync().then((ciphertext) => {
        callback(null, ciphertext);
      }).catch((error) => {
        callback(error, null);
      });
    }
    decrypt(ciphertext) {
      return __async(this, null, function* () {
        logger_default.logAction(logger_default.LOG_MICRO, "CBCCipher.decrypt()", "");
        const ciphertextArrayBuffer = bufferUtils.toArrayBuffer(ciphertext);
        const iv = ciphertextArrayBuffer.slice(0, DEFAULT_BLOCKLENGTH);
        const ciphertextBody = ciphertextArrayBuffer.slice(DEFAULT_BLOCKLENGTH);
        const cryptoKey = yield crypto.subtle.importKey("raw", this.key, this.webCryptoAlgorithm, false, ["decrypt"]);
        return crypto.subtle.decrypt({ name: this.webCryptoAlgorithm, iv }, cryptoKey, ciphertextBody);
      });
    }
    getIv(callback) {
      if (this.iv) {
        var iv = this.iv;
        this.iv = null;
        callback(null, iv);
        return;
      }
      generateRandom(DEFAULT_BLOCKLENGTH, function(err, randomBlock) {
        if (err) {
          callback(err, null);
          return;
        }
        callback(null, bufferUtils.toArrayBuffer(randomBlock));
      });
    }
  }
  return Crypto2;
};

// src/platform/web/modules/crypto.ts
var Crypto = /* @__PURE__ */ createCryptoClass(config_default, bufferutils_default);
var generateRandomKey = (keyLength) => {
  return Crypto.generateRandomKey(keyLength);
};
var getDefaultCryptoParams = (params) => {
  return Crypto.getDefaultParams(params);
};

// src/platform/web/modules/message.ts
var decodeMessage = (obj, options) => {
  return fromEncoded(null, obj, options);
};
var decodeEncryptedMessage = (obj, options) => {
  return fromEncoded(Crypto, obj, options);
};
var decodeMessages = (obj, options) => {
  return fromEncodedArray(null, obj, options);
};
var decodeEncryptedMessages = (obj, options) => {
  return fromEncodedArray(Crypto, obj, options);
};

// src/platform/web/modules/presencemessage.ts
var decodePresenceMessage = fromEncoded2;
var decodePresenceMessages = fromEncodedArray2;
var constructPresenceMessage = fromValues2;

// src/platform/web/lib/util/msgpack.ts
function inspect(buffer) {
  if (buffer === void 0)
    return "undefined";
  let view;
  let type;
  if (buffer instanceof ArrayBuffer) {
    type = "ArrayBuffer";
    view = new DataView(buffer);
  } else if (buffer instanceof DataView) {
    type = "DataView";
    view = buffer;
  }
  if (!view)
    return JSON.stringify(buffer);
  const bytes = [];
  for (let i = 0; i < buffer.byteLength; i++) {
    if (i > 20) {
      bytes.push("...");
      break;
    }
    let byte_ = view.getUint8(i).toString(16);
    if (byte_.length === 1)
      byte_ = "0" + byte_;
    bytes.push(byte_);
  }
  return "<" + type + " " + bytes.join(" ") + ">";
}
function utf8Write(view, offset, string) {
  for (let i = 0, l = string.length; i < l; i++) {
    const codePoint = string.charCodeAt(i);
    if (codePoint < 128) {
      view.setUint8(offset++, codePoint >>> 0 & 127 | 0);
      continue;
    }
    if (codePoint < 2048) {
      view.setUint8(offset++, codePoint >>> 6 & 31 | 192);
      view.setUint8(offset++, codePoint >>> 0 & 63 | 128);
      continue;
    }
    if (codePoint < 65536) {
      view.setUint8(offset++, codePoint >>> 12 & 15 | 224);
      view.setUint8(offset++, codePoint >>> 6 & 63 | 128);
      view.setUint8(offset++, codePoint >>> 0 & 63 | 128);
      continue;
    }
    if (codePoint < 1114112) {
      view.setUint8(offset++, codePoint >>> 18 & 7 | 240);
      view.setUint8(offset++, codePoint >>> 12 & 63 | 128);
      view.setUint8(offset++, codePoint >>> 6 & 63 | 128);
      view.setUint8(offset++, codePoint >>> 0 & 63 | 128);
      continue;
    }
    throw new Error("bad codepoint " + codePoint);
  }
}
function utf8Read(view, offset, length) {
  let string = "";
  for (let i = offset, end = offset + length; i < end; i++) {
    const byte_ = view.getUint8(i);
    if ((byte_ & 128) === 0) {
      string += String.fromCharCode(byte_);
      continue;
    }
    if ((byte_ & 224) === 192) {
      string += String.fromCharCode((byte_ & 15) << 6 | view.getUint8(++i) & 63);
      continue;
    }
    if ((byte_ & 240) === 224) {
      string += String.fromCharCode(
        (byte_ & 15) << 12 | (view.getUint8(++i) & 63) << 6 | (view.getUint8(++i) & 63) << 0
      );
      continue;
    }
    if ((byte_ & 248) === 240) {
      string += String.fromCharCode(
        (byte_ & 7) << 18 | (view.getUint8(++i) & 63) << 12 | (view.getUint8(++i) & 63) << 6 | (view.getUint8(++i) & 63) << 0
      );
      continue;
    }
    throw new Error("Invalid byte " + byte_.toString(16));
  }
  return string;
}
function utf8ByteCount(string) {
  let count = 0;
  for (let i = 0, l = string.length; i < l; i++) {
    const codePoint = string.charCodeAt(i);
    if (codePoint < 128) {
      count += 1;
      continue;
    }
    if (codePoint < 2048) {
      count += 2;
      continue;
    }
    if (codePoint < 65536) {
      count += 3;
      continue;
    }
    if (codePoint < 1114112) {
      count += 4;
      continue;
    }
    throw new Error("bad codepoint " + codePoint);
  }
  return count;
}
function encode2(value, sparse) {
  const size = sizeof(value, sparse);
  if (size === 0)
    return void 0;
  const buffer = new ArrayBuffer(size);
  const view = new DataView(buffer);
  _encode(value, view, 0, sparse);
  return buffer;
}
var SH_L_32 = (1 << 16) * (1 << 16);
var SH_R_32 = 1 / SH_L_32;
function getInt64(view, offset) {
  offset = offset || 0;
  return view.getInt32(offset) * SH_L_32 + view.getUint32(offset + 4);
}
function getUint64(view, offset) {
  offset = offset || 0;
  return view.getUint32(offset) * SH_L_32 + view.getUint32(offset + 4);
}
function setInt64(view, offset, val) {
  if (val < 9223372036854776e3) {
    view.setInt32(offset, Math.floor(val * SH_R_32));
    view.setInt32(offset + 4, val & -1);
  } else {
    view.setUint32(offset, 2147483647);
    view.setUint32(offset + 4, 2147483647);
  }
}
function setUint64(view, offset, val) {
  if (val < 18446744073709552e3) {
    view.setUint32(offset, Math.floor(val * SH_R_32));
    view.setInt32(offset + 4, val & -1);
  } else {
    view.setUint32(offset, 4294967295);
    view.setUint32(offset + 4, 4294967295);
  }
}
var Decoder = class {
  constructor(view, offset) {
    this.map = (length) => {
      const value = {};
      for (let i = 0; i < length; i++) {
        const key = this.parse();
        value[key] = this.parse();
      }
      return value;
    };
    this.bin = (length) => {
      const value = new ArrayBuffer(length);
      new Uint8Array(value).set(new Uint8Array(this.view.buffer, this.offset, length), 0);
      this.offset += length;
      return value;
    };
    this.buf = this.bin;
    this.str = (length) => {
      const value = utf8Read(this.view, this.offset, length);
      this.offset += length;
      return value;
    };
    this.array = (length) => {
      const value = new Array(length);
      for (let i = 0; i < length; i++) {
        value[i] = this.parse();
      }
      return value;
    };
    this.ext = (length) => {
      this.offset += length;
      return {
        type: this.view.getInt8(this.offset),
        data: this.buf(length)
      };
    };
    this.parse = () => {
      const type = this.view.getUint8(this.offset);
      let value, length;
      if ((type & 128) === 0) {
        this.offset++;
        return type;
      }
      if ((type & 240) === 128) {
        length = type & 15;
        this.offset++;
        return this.map(length);
      }
      if ((type & 240) === 144) {
        length = type & 15;
        this.offset++;
        return this.array(length);
      }
      if ((type & 224) === 160) {
        length = type & 31;
        this.offset++;
        return this.str(length);
      }
      if ((type & 224) === 224) {
        value = this.view.getInt8(this.offset);
        this.offset++;
        return value;
      }
      switch (type) {
        case 192:
          this.offset++;
          return null;
        case 193:
          this.offset++;
          return void 0;
        case 194:
          this.offset++;
          return false;
        case 195:
          this.offset++;
          return true;
        case 196:
          length = this.view.getUint8(this.offset + 1);
          this.offset += 2;
          return this.bin(length);
        case 197:
          length = this.view.getUint16(this.offset + 1);
          this.offset += 3;
          return this.bin(length);
        case 198:
          length = this.view.getUint32(this.offset + 1);
          this.offset += 5;
          return this.bin(length);
        case 199:
          length = this.view.getUint8(this.offset + 1);
          this.offset += 2;
          return this.ext(length);
        case 200:
          length = this.view.getUint16(this.offset + 1);
          this.offset += 3;
          return this.ext(length);
        case 201:
          length = this.view.getUint32(this.offset + 1);
          this.offset += 5;
          return this.ext(length);
        case 202:
          value = this.view.getFloat32(this.offset + 1);
          this.offset += 5;
          return value;
        case 203:
          value = this.view.getFloat64(this.offset + 1);
          this.offset += 9;
          return value;
        case 204:
          value = this.view.getUint8(this.offset + 1);
          this.offset += 2;
          return value;
        case 205:
          value = this.view.getUint16(this.offset + 1);
          this.offset += 3;
          return value;
        case 206:
          value = this.view.getUint32(this.offset + 1);
          this.offset += 5;
          return value;
        case 207:
          value = getUint64(this.view, this.offset + 1);
          this.offset += 9;
          return value;
        case 208:
          value = this.view.getInt8(this.offset + 1);
          this.offset += 2;
          return value;
        case 209:
          value = this.view.getInt16(this.offset + 1);
          this.offset += 3;
          return value;
        case 210:
          value = this.view.getInt32(this.offset + 1);
          this.offset += 5;
          return value;
        case 211:
          value = getInt64(this.view, this.offset + 1);
          this.offset += 9;
          return value;
        case 212:
          length = 1;
          this.offset++;
          return this.ext(length);
        case 213:
          length = 2;
          this.offset++;
          return this.ext(length);
        case 214:
          length = 4;
          this.offset++;
          return this.ext(length);
        case 215:
          length = 8;
          this.offset++;
          return this.ext(length);
        case 216:
          length = 16;
          this.offset++;
          return this.ext(length);
        case 217:
          length = this.view.getUint8(this.offset + 1);
          this.offset += 2;
          return this.str(length);
        case 218:
          length = this.view.getUint16(this.offset + 1);
          this.offset += 3;
          return this.str(length);
        case 219:
          length = this.view.getUint32(this.offset + 1);
          this.offset += 5;
          return this.str(length);
        case 220:
          length = this.view.getUint16(this.offset + 1);
          this.offset += 3;
          return this.array(length);
        case 221:
          length = this.view.getUint32(this.offset + 1);
          this.offset += 5;
          return this.array(length);
        case 222:
          length = this.view.getUint16(this.offset + 1);
          this.offset += 3;
          return this.map(length);
        case 223:
          length = this.view.getUint32(this.offset + 1);
          this.offset += 5;
          return this.map(length);
      }
      throw new Error("Unknown type 0x" + type.toString(16));
    };
    this.offset = offset || 0;
    this.view = view;
  }
};
function decode3(buffer) {
  const view = new DataView(buffer);
  const decoder = new Decoder(view);
  const value = decoder.parse();
  if (decoder.offset !== buffer.byteLength)
    throw new Error(buffer.byteLength - decoder.offset + " trailing bytes");
  return value;
}
function encodeableKeys(value, sparse) {
  return Object.keys(value).filter(function(e) {
    const val = value[e], type = typeof val;
    return (!sparse || val !== void 0 && val !== null) && ("function" !== type || !!val.toJSON);
  });
}
function _encode(value, view, offset, sparse) {
  const type = typeof value;
  if (typeof value === "string") {
    const length = utf8ByteCount(value);
    if (length < 32) {
      view.setUint8(offset, length | 160);
      utf8Write(view, offset + 1, value);
      return 1 + length;
    }
    if (length < 256) {
      view.setUint8(offset, 217);
      view.setUint8(offset + 1, length);
      utf8Write(view, offset + 2, value);
      return 2 + length;
    }
    if (length < 65536) {
      view.setUint8(offset, 218);
      view.setUint16(offset + 1, length);
      utf8Write(view, offset + 3, value);
      return 3 + length;
    }
    if (length < 4294967296) {
      view.setUint8(offset, 219);
      view.setUint32(offset + 1, length);
      utf8Write(view, offset + 5, value);
      return 5 + length;
    }
  }
  if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {
    value = value.buffer;
  }
  if (value instanceof ArrayBuffer) {
    const length = value.byteLength;
    if (length < 256) {
      view.setUint8(offset, 196);
      view.setUint8(offset + 1, length);
      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 2);
      return 2 + length;
    }
    if (length < 65536) {
      view.setUint8(offset, 197);
      view.setUint16(offset + 1, length);
      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 3);
      return 3 + length;
    }
    if (length < 4294967296) {
      view.setUint8(offset, 198);
      view.setUint32(offset + 1, length);
      new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 5);
      return 5 + length;
    }
  }
  if (typeof value === "number") {
    if (Math.floor(value) !== value) {
      view.setUint8(offset, 203);
      view.setFloat64(offset + 1, value);
      return 9;
    }
    if (value >= 0) {
      if (value < 128) {
        view.setUint8(offset, value);
        return 1;
      }
      if (value < 256) {
        view.setUint8(offset, 204);
        view.setUint8(offset + 1, value);
        return 2;
      }
      if (value < 65536) {
        view.setUint8(offset, 205);
        view.setUint16(offset + 1, value);
        return 3;
      }
      if (value < 4294967296) {
        view.setUint8(offset, 206);
        view.setUint32(offset + 1, value);
        return 5;
      }
      if (value < 18446744073709552e3) {
        view.setUint8(offset, 207);
        setUint64(view, offset + 1, value);
        return 9;
      }
      throw new Error("Number too big 0x" + value.toString(16));
    }
    if (value >= -32) {
      view.setInt8(offset, value);
      return 1;
    }
    if (value >= -128) {
      view.setUint8(offset, 208);
      view.setInt8(offset + 1, value);
      return 2;
    }
    if (value >= -32768) {
      view.setUint8(offset, 209);
      view.setInt16(offset + 1, value);
      return 3;
    }
    if (value >= -2147483648) {
      view.setUint8(offset, 210);
      view.setInt32(offset + 1, value);
      return 5;
    }
    if (value >= -9223372036854776e3) {
      view.setUint8(offset, 211);
      setInt64(view, offset + 1, value);
      return 9;
    }
    throw new Error("Number too small -0x" + (-value).toString(16).substr(1));
  }
  if (type === "undefined") {
    if (sparse)
      return 0;
    view.setUint8(offset, 212);
    view.setUint8(offset + 1, 0);
    view.setUint8(offset + 2, 0);
    return 3;
  }
  if (value === null) {
    if (sparse)
      return 0;
    view.setUint8(offset, 192);
    return 1;
  }
  if (type === "boolean") {
    view.setUint8(offset, value ? 195 : 194);
    return 1;
  }
  if ("function" === typeof value.toJSON)
    return _encode(value.toJSON(), view, offset, sparse);
  if (type === "object") {
    let length, size = 0;
    let keys;
    const isArray2 = Array.isArray(value);
    if (isArray2) {
      length = value.length;
    } else {
      keys = encodeableKeys(value, sparse);
      length = keys.length;
    }
    if (length < 16) {
      view.setUint8(offset, length | (isArray2 ? 144 : 128));
      size = 1;
    } else if (length < 65536) {
      view.setUint8(offset, isArray2 ? 220 : 222);
      view.setUint16(offset + 1, length);
      size = 3;
    } else if (length < 4294967296) {
      view.setUint8(offset, isArray2 ? 221 : 223);
      view.setUint32(offset + 1, length);
      size = 5;
    }
    if (isArray2) {
      for (let i = 0; i < length; i++) {
        size += _encode(value[i], view, offset + size, sparse);
      }
    } else if (keys) {
      for (let i = 0; i < length; i++) {
        const key = keys[i];
        size += _encode(key, view, offset + size);
        size += _encode(value[key], view, offset + size, sparse);
      }
    }
    return size;
  }
  if (type === "function")
    return 0;
  throw new Error("Unknown type " + type);
}
function sizeof(value, sparse) {
  const type = typeof value;
  if (type === "string") {
    const length = utf8ByteCount(value);
    if (length < 32) {
      return 1 + length;
    }
    if (length < 256) {
      return 2 + length;
    }
    if (length < 65536) {
      return 3 + length;
    }
    if (length < 4294967296) {
      return 5 + length;
    }
  }
  if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {
    value = value.buffer;
  }
  if (value instanceof ArrayBuffer) {
    const length = value.byteLength;
    if (length < 256) {
      return 2 + length;
    }
    if (length < 65536) {
      return 3 + length;
    }
    if (length < 4294967296) {
      return 5 + length;
    }
  }
  if (typeof value === "number") {
    if (Math.floor(value) !== value)
      return 9;
    if (value >= 0) {
      if (value < 128)
        return 1;
      if (value < 256)
        return 2;
      if (value < 65536)
        return 3;
      if (value < 4294967296)
        return 5;
      if (value < 18446744073709552e3)
        return 9;
      throw new Error("Number too big 0x" + value.toString(16));
    }
    if (value >= -32)
      return 1;
    if (value >= -128)
      return 2;
    if (value >= -32768)
      return 3;
    if (value >= -2147483648)
      return 5;
    if (value >= -9223372036854776e3)
      return 9;
    throw new Error("Number too small -0x" + value.toString(16).substr(1));
  }
  if (type === "boolean")
    return 1;
  if (value === null)
    return sparse ? 0 : 1;
  if (value === void 0)
    return sparse ? 0 : 3;
  if ("function" === typeof value.toJSON)
    return sizeof(value.toJSON(), sparse);
  if (type === "object") {
    let length, size = 0;
    if (Array.isArray(value)) {
      length = value.length;
      for (let i = 0; i < length; i++) {
        size += sizeof(value[i], sparse);
      }
    } else {
      const keys = encodeableKeys(value, sparse);
      length = keys.length;
      for (let i = 0; i < length; i++) {
        const key = keys[i];
        size += sizeof(key) + sizeof(value[key], sparse);
      }
    }
    if (length < 16) {
      return 1 + size;
    }
    if (length < 65536) {
      return 3 + size;
    }
    if (length < 4294967296) {
      return 5 + size;
    }
    throw new Error("Array or object too long 0x" + length.toString(16));
  }
  if (type === "function")
    return 0;
  throw new Error("Unknown type " + type);
}
var msgpack_default = {
  encode: encode2,
  decode: decode3,
  inspect,
  utf8Write,
  utf8Read,
  utf8ByteCount
};

// src/common/lib/client/realtimepresence.ts
function getClientId(realtimePresence) {
  return realtimePresence.channel.client.auth.clientId;
}
function isAnonymousOrWildcard(realtimePresence) {
  const realtime = realtimePresence.channel.client;
  const clientId = realtime.auth.clientId;
  return (!clientId || clientId === "*") && realtime.connection.state === "connected";
}
function waitAttached(channel, callback, action) {
  switch (channel.state) {
    case "attached":
    case "suspended":
      action();
      break;
    case "initialized":
    case "detached":
    case "detaching":
    case "attaching":
      channel.attach(function(err) {
        if (err)
          callback(err);
        else
          action();
      });
      break;
    default:
      callback(ErrorInfo.fromValues(channel.invalidStateError()));
  }
}
function newerThan(item, existing) {
  if (item.isSynthesized() || existing.isSynthesized()) {
    return item.timestamp >= existing.timestamp;
  }
  const itemOrderings = item.parseId(), existingOrderings = existing.parseId();
  if (itemOrderings.msgSerial === existingOrderings.msgSerial) {
    return itemOrderings.index > existingOrderings.index;
  } else {
    return itemOrderings.msgSerial > existingOrderings.msgSerial;
  }
}
var RealtimePresence = class extends eventemitter_default {
  constructor(channel) {
    super();
    this.channel = channel;
    this.syncComplete = false;
    this.members = new PresenceMap(this, (item) => item.clientId + ":" + item.connectionId);
    this._myMembers = new PresenceMap(this, (item) => item.clientId);
    this.subscriptions = new eventemitter_default();
    this.pendingPresence = [];
  }
  enter(data, callback) {
    if (isAnonymousOrWildcard(this)) {
      throw new ErrorInfo("clientId must be specified to enter a presence channel", 40012, 400);
    }
    return this._enterOrUpdateClient(void 0, void 0, data, "enter", callback);
  }
  update(data, callback) {
    if (isAnonymousOrWildcard(this)) {
      throw new ErrorInfo("clientId must be specified to update presence data", 40012, 400);
    }
    return this._enterOrUpdateClient(void 0, void 0, data, "update", callback);
  }
  enterClient(clientId, data, callback) {
    return this._enterOrUpdateClient(void 0, clientId, data, "enter", callback);
  }
  updateClient(clientId, data, callback) {
    return this._enterOrUpdateClient(void 0, clientId, data, "update", callback);
  }
  _enterOrUpdateClient(id, clientId, data, action, callback) {
    if (!callback) {
      if (typeof data === "function") {
        callback = data;
        data = null;
      } else {
        return promisify(this, "_enterOrUpdateClient", [id, clientId, data, action]);
      }
    }
    const channel = this.channel;
    if (!channel.connectionManager.activeState()) {
      callback(channel.connectionManager.getError());
      return;
    }
    logger_default.logAction(
      logger_default.LOG_MICRO,
      "RealtimePresence." + action + "Client()",
      "channel = " + channel.name + ", id = " + id + ", client = " + (clientId || "(implicit) " + getClientId(this))
    );
    const presence = fromData(data);
    presence.action = action;
    if (id) {
      presence.id = id;
    }
    if (clientId) {
      presence.clientId = clientId;
    }
    encode(presence, channel.channelOptions, (err) => {
      if (err) {
        callback(err);
        return;
      }
      switch (channel.state) {
        case "attached":
          channel.sendPresence(presence, callback);
          break;
        case "initialized":
        case "detached":
          channel.attach();
        case "attaching":
          this.pendingPresence.push({
            presence,
            callback
          });
          break;
        default:
          err = new PartialErrorInfo(
            "Unable to " + action + " presence channel while in " + channel.state + " state",
            90001
          );
          err.code = 90001;
          callback(err);
      }
    });
  }
  leave(data, callback) {
    if (isAnonymousOrWildcard(this)) {
      throw new ErrorInfo("clientId must have been specified to enter or leave a presence channel", 40012, 400);
    }
    return this.leaveClient(void 0, data, callback);
  }
  leaveClient(clientId, data, callback) {
    if (!callback) {
      if (typeof data === "function") {
        callback = data;
        data = null;
      } else {
        return promisify(this, "leaveClient", [clientId, data]);
      }
    }
    const channel = this.channel;
    if (!channel.connectionManager.activeState()) {
      callback == null ? void 0 : callback(channel.connectionManager.getError());
      return;
    }
    logger_default.logAction(
      logger_default.LOG_MICRO,
      "RealtimePresence.leaveClient()",
      "leaving; channel = " + this.channel.name + ", client = " + clientId
    );
    const presence = fromData(data);
    presence.action = "leave";
    if (clientId) {
      presence.clientId = clientId;
    }
    switch (channel.state) {
      case "attached":
        channel.sendPresence(presence, callback);
        break;
      case "attaching":
        this.pendingPresence.push({
          presence,
          callback
        });
        break;
      case "initialized":
      case "failed": {
        const err = new PartialErrorInfo("Unable to leave presence channel (incompatible state)", 90001);
        callback == null ? void 0 : callback(err);
        break;
      }
      default:
        callback == null ? void 0 : callback(channel.invalidStateError());
    }
  }
  get(params, callback) {
    const args = Array.prototype.slice.call(arguments);
    if (args.length == 1 && typeof args[0] == "function")
      args.unshift(null);
    params = args[0];
    callback = args[1];
    const waitForSync = !params || ("waitForSync" in params ? params.waitForSync : true);
    if (!callback) {
      return promisify(this, "get", args);
    }
    function returnMembers(members) {
      callback(null, params ? members.list(params) : members.values());
    }
    if (this.channel.state === "suspended") {
      if (waitForSync) {
        callback(
          ErrorInfo.fromValues({
            statusCode: 400,
            code: 91005,
            message: "Presence state is out of sync due to channel being in the SUSPENDED state"
          })
        );
      } else {
        returnMembers(this.members);
      }
      return;
    }
    waitAttached(this.channel, callback, () => {
      const members = this.members;
      if (waitForSync) {
        members.waitSync(function() {
          returnMembers(members);
        });
      } else {
        returnMembers(members);
      }
    });
  }
  history(params, callback) {
    logger_default.logAction(logger_default.LOG_MICRO, "RealtimePresence.history()", "channel = " + this.name);
    if (callback === void 0) {
      if (typeof params == "function") {
        callback = params;
        params = null;
      } else {
        return promisify(this, "history", arguments);
      }
    }
    const restMixin = this.channel.client.rest.presenceMixin;
    if (params && params.untilAttach) {
      if (this.channel.state === "attached") {
        delete params.untilAttach;
        params.from_serial = this.channel.properties.attachSerial;
      } else {
        callback(
          new ErrorInfo(
            "option untilAttach requires the channel to be attached, was: " + this.channel.state,
            4e4,
            400
          )
        );
      }
    }
    return restMixin.history(this, params, callback);
  }
  setPresence(presenceSet, isSync, syncChannelSerial) {
    logger_default.logAction(
      logger_default.LOG_MICRO,
      "RealtimePresence.setPresence()",
      "received presence for " + presenceSet.length + " participants; syncChannelSerial = " + syncChannelSerial
    );
    let syncCursor, match;
    const members = this.members, myMembers = this._myMembers, broadcastMessages = [], connId = this.channel.connectionManager.connectionId;
    if (isSync) {
      this.members.startSync();
      if (syncChannelSerial && (match = syncChannelSerial.match(/^[\w-]+:(.*)$/))) {
        syncCursor = match[1];
      }
    }
    for (let i = 0; i < presenceSet.length; i++) {
      const presence = fromValues2(presenceSet[i]);
      switch (presence.action) {
        case "leave":
          if (members.remove(presence)) {
            broadcastMessages.push(presence);
          }
          if (presence.connectionId === connId && !presence.isSynthesized()) {
            myMembers.remove(presence);
          }
          break;
        case "enter":
        case "present":
        case "update":
          if (members.put(presence)) {
            broadcastMessages.push(presence);
          }
          if (presence.connectionId === connId) {
            myMembers.put(presence);
          }
          break;
      }
    }
    if (isSync && !syncCursor) {
      members.endSync();
      this.channel.syncChannelSerial = null;
    }
    for (let i = 0; i < broadcastMessages.length; i++) {
      const presence = broadcastMessages[i];
      this.subscriptions.emit(presence.action, presence);
    }
  }
  onAttached(hasPresence) {
    logger_default.logAction(
      logger_default.LOG_MINOR,
      "RealtimePresence.onAttached()",
      "channel = " + this.channel.name + ", hasPresence = " + hasPresence
    );
    if (hasPresence) {
      this.members.startSync();
    } else {
      this._synthesizeLeaves(this.members.values());
      this.members.clear();
    }
    this._ensureMyMembersPresent();
    const pendingPresence = this.pendingPresence, pendingPresCount = pendingPresence.length;
    if (pendingPresCount) {
      this.pendingPresence = [];
      const presenceArray = [];
      const multicaster = multicaster_default.create();
      logger_default.logAction(
        logger_default.LOG_MICRO,
        "RealtimePresence.onAttached",
        "sending " + pendingPresCount + " queued presence messages"
      );
      for (let i = 0; i < pendingPresCount; i++) {
        const event = pendingPresence[i];
        presenceArray.push(event.presence);
        multicaster.push(event.callback);
      }
      this.channel.sendPresence(presenceArray, multicaster);
    }
  }
  actOnChannelState(state, hasPresence, err) {
    switch (state) {
      case "attached":
        this.onAttached(hasPresence);
        break;
      case "detached":
      case "failed":
        this._clearMyMembers();
        this.members.clear();
      case "suspended":
        this.failPendingPresence(err);
        break;
    }
  }
  failPendingPresence(err) {
    if (this.pendingPresence.length) {
      logger_default.logAction(
        logger_default.LOG_MINOR,
        "RealtimeChannel.failPendingPresence",
        "channel; name = " + this.channel.name + ", err = " + inspectError(err)
      );
      for (let i = 0; i < this.pendingPresence.length; i++)
        try {
          this.pendingPresence[i].callback(err);
        } catch (e) {
        }
      this.pendingPresence = [];
    }
  }
  _clearMyMembers() {
    this._myMembers.clear();
  }
  _ensureMyMembersPresent() {
    const myMembers = this._myMembers, reenterCb = (err) => {
      if (err) {
        const msg = "Presence auto-re-enter failed: " + err.toString();
        const wrappedErr = new ErrorInfo(msg, 91004, 400);
        logger_default.logAction(logger_default.LOG_ERROR, "RealtimePresence._ensureMyMembersPresent()", msg);
        const change = new channelstatechange_default(this.channel.state, this.channel.state, true, false, wrappedErr);
        this.channel.emit("update", change);
      }
    };
    for (const memberKey in myMembers.map) {
      const entry = myMembers.map[memberKey];
      logger_default.logAction(
        logger_default.LOG_MICRO,
        "RealtimePresence._ensureMyMembersPresent()",
        'Auto-reentering clientId "' + entry.clientId + '" into the presence set'
      );
      this._enterOrUpdateClient(entry.id, entry.clientId, entry.data, "enter", reenterCb);
    }
  }
  _synthesizeLeaves(items) {
    const subscriptions = this.subscriptions;
    arrForEach(items, function(item) {
      const presence = fromValues2({
        action: "leave",
        connectionId: item.connectionId,
        clientId: item.clientId,
        data: item.data,
        encoding: item.encoding,
        timestamp: now()
      });
      subscriptions.emit("leave", presence);
    });
  }
  subscribe(..._args) {
    const args = realtimechannel_default.processListenerArgs(_args);
    const event = args[0];
    const listener = args[1];
    let callback = args[2];
    const channel = this.channel;
    if (!callback) {
      return promisify(this, "subscribe", [event, listener]);
    }
    if (channel.state === "failed") {
      callback(ErrorInfo.fromValues(channel.invalidStateError()));
      return;
    }
    this.subscriptions.on(event, listener);
    channel.attach(callback);
  }
  unsubscribe(..._args) {
    const args = realtimechannel_default.processListenerArgs(_args);
    const event = args[0];
    const listener = args[1];
    this.subscriptions.off(event, listener);
  }
};
var PresenceMap = class extends eventemitter_default {
  constructor(presence, memberKey) {
    super();
    this.presence = presence;
    this.map = /* @__PURE__ */ Object.create(null);
    this.syncInProgress = false;
    this.residualMembers = null;
    this.memberKey = memberKey;
  }
  get(key) {
    return this.map[key];
  }
  getClient(clientId) {
    const map = this.map, result = [];
    for (const key in map) {
      const item = map[key];
      if (item.clientId == clientId && item.action != "absent")
        result.push(item);
    }
    return result;
  }
  list(params) {
    const map = this.map, clientId = params && params.clientId, connectionId = params && params.connectionId, result = [];
    for (const key in map) {
      const item = map[key];
      if (item.action === "absent")
        continue;
      if (clientId && clientId != item.clientId)
        continue;
      if (connectionId && connectionId != item.connectionId)
        continue;
      result.push(item);
    }
    return result;
  }
  put(item) {
    if (item.action === "enter" || item.action === "update") {
      item = fromValues2(item);
      item.action = "present";
    }
    const map = this.map, key = this.memberKey(item);
    if (this.residualMembers)
      delete this.residualMembers[key];
    const existingItem = map[key];
    if (existingItem && !newerThan(item, existingItem)) {
      return false;
    }
    map[key] = item;
    return true;
  }
  values() {
    const map = this.map, result = [];
    for (const key in map) {
      const item = map[key];
      if (item.action != "absent")
        result.push(item);
    }
    return result;
  }
  remove(item) {
    const map = this.map, key = this.memberKey(item);
    const existingItem = map[key];
    if (existingItem && !newerThan(item, existingItem)) {
      return false;
    }
    if (this.syncInProgress) {
      item = fromValues2(item);
      item.action = "absent";
      map[key] = item;
    } else {
      delete map[key];
    }
    return true;
  }
  startSync() {
    const map = this.map, syncInProgress = this.syncInProgress;
    logger_default.logAction(
      logger_default.LOG_MINOR,
      "PresenceMap.startSync()",
      "channel = " + this.presence.channel.name + "; syncInProgress = " + syncInProgress
    );
    if (!this.syncInProgress) {
      this.residualMembers = copy(map);
      this.setInProgress(true);
    }
  }
  endSync() {
    const map = this.map, syncInProgress = this.syncInProgress;
    logger_default.logAction(
      logger_default.LOG_MINOR,
      "PresenceMap.endSync()",
      "channel = " + this.presence.channel.name + "; syncInProgress = " + syncInProgress
    );
    if (syncInProgress) {
      for (const memberKey in map) {
        const entry = map[memberKey];
        if (entry.action === "absent") {
          delete map[memberKey];
        }
      }
      this.presence._synthesizeLeaves(valuesArray(this.residualMembers));
      for (const memberKey in this.residualMembers) {
        delete map[memberKey];
      }
      this.residualMembers = null;
      this.setInProgress(false);
    }
    this.emit("sync");
  }
  waitSync(callback) {
    const syncInProgress = this.syncInProgress;
    logger_default.logAction(
      logger_default.LOG_MINOR,
      "PresenceMap.waitSync()",
      "channel = " + this.presence.channel.name + "; syncInProgress = " + syncInProgress
    );
    if (!syncInProgress) {
      callback();
      return;
    }
    this.once("sync", callback);
  }
  clear() {
    this.map = {};
    this.setInProgress(false);
    this.residualMembers = null;
  }
  setInProgress(inProgress) {
    logger_default.logAction(logger_default.LOG_MICRO, "PresenceMap.setInProgress()", "inProgress = " + inProgress);
    this.syncInProgress = inProgress;
    this.presence.syncComplete = !inProgress;
  }
};
var realtimepresence_default = RealtimePresence;

// src/platform/web/modules/realtimepresence.ts
var RealtimePresence2 = {
  RealtimePresence: realtimepresence_default,
  presenceMessageFromValues: fromValues2,
  presenceMessagesFromValuesArray: fromValuesArray2
};

// node_modules/@ably/vcdiff-decoder/lib/errors.js
function CustomErrors(names) {
  let errors = {};
  names.forEach((name) => {
    let CustomError = function CustomError2(message) {
      var temp = Error.apply(this, arguments);
      temp.name = this.name = name;
      this.stack = temp.stack;
      this.message = temp.message;
      this.name = name;
      this.message = message;
    };
    CustomError.prototype = Object.create(Error.prototype, {
      constructor: {
        value: CustomError,
        writable: true,
        configurable: true
      }
    });
    errors[name] = CustomError;
  });
  return errors;
}
var errors_default = /* @__PURE__ */ CustomErrors(["NotImplemented", "InvalidDelta"]);

// node_modules/@ably/vcdiff-decoder/lib/typed_array_util.js
var TypedArrayList = class {
  constructor() {
    this.typedArrays = [];
    this.startIndexes = [];
    this.length = 0;
  }
  add(typedArray) {
    let typedArrayTypes = [
      Int8Array,
      Uint8Array,
      Uint8ClampedArray,
      Int16Array,
      Uint16Array,
      Int32Array,
      Uint32Array,
      Float32Array,
      Float64Array
    ];
    let matchingTypedArrayTypes = typedArrayTypes.filter((typedArrayType) => typedArray instanceof typedArrayType);
    if (matchingTypedArrayTypes.length < 1) {
      throw Error("Given " + typeof typedArray + " when expected a TypedArray");
    }
    let startIndex;
    if (this.typedArrays.length === 0) {
      startIndex = 0;
    } else {
      let lastIndex = this.startIndexes.length - 1;
      let lastStartIndex = this.startIndexes[lastIndex];
      let lastLength = this.typedArrays[lastIndex].length;
      startIndex = lastStartIndex + lastLength;
    }
    this.startIndexes.push(startIndex);
    this.typedArrays.push(typedArray);
    this.length += startIndex + typedArray.length;
  }
  get(index) {
    let listIndex = getIndex(this.startIndexes, index);
    let typedArray = index - this.startIndexes[listIndex];
    return this.typedArrays[listIndex][typedArray];
  }
  set(index, value) {
    if (typeof index !== "number" || isNaN(index)) {
      throw new Error("Given non-number index: " + index);
    }
    let listIndex = getIndex(this.startIndexes, index);
    let typedArrayIndex = index - this.startIndexes[listIndex];
    this.typedArrays[listIndex][typedArrayIndex] = value;
  }
};
function getIndex(arr, element) {
  if (arr.length === 2) {
    return element < arr[1] ? 0 : 1;
  }
  let low = 0;
  let high = arr.length - 1;
  while (low < high) {
    let mid = Math.floor((low + high) / 2);
    if (arr[mid] === element) {
      return mid;
    } else if (arr[mid] < element) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  if (arr[high] > element) {
    return high - 1;
  } else {
    return high;
  }
}

// node_modules/@ably/vcdiff-decoder/lib/deserialize/integer.js
function integer(buffer, position) {
  const result = { position, value: 0 };
  do {
    result.value = result.value << 7 | buffer[result.position] & 127;
    if (result.value < 0) {
      throw new Error("RFC 3284 Integer conversion: Buffer overflow");
    }
  } while (buffer[result.position++] & 128);
  return result;
}

// node_modules/@ably/vcdiff-decoder/lib/instructions.js
var ADD = class {
  constructor(size) {
    __publicField(this, "name", "ADD");
    this.size = size;
  }
  execute(delta2) {
    for (let i = 0; i < this.size; i++) {
      delta2.U.set(delta2.UTargetPosition + i, delta2.data[delta2.dataPosition + i]);
    }
    delta2.dataPosition += this.size;
    delta2.UTargetPosition += this.size;
  }
};
var COPY = class {
  constructor(size, mode) {
    __publicField(this, "name", "COPY");
    this.size = size;
    this.mode = mode;
  }
  execute(delta2) {
    let address, m, next, method;
    if (this.mode === 0) {
      address = delta2.getNextAddressInteger();
    } else if (this.mode === 1) {
      next = delta2.getNextAddressInteger();
      address = delta2.UTargetPosition - next;
    } else if ((m = this.mode - 2) >= 0 && m < delta2.nearCache.size) {
      next = delta2.getNextAddressInteger();
      address = delta2.nearCache.get(m, next);
      method = "near";
    } else {
      m = this.mode - (2 + delta2.nearCache.size);
      next = delta2.getNextAddressByte();
      address = delta2.sameCache.get(m, next);
      method = "same";
    }
    delta2.nearCache.update(address);
    delta2.sameCache.update(address);
    for (let i = 0; i < this.size; i++) {
      delta2.U.set(delta2.UTargetPosition + i, delta2.U.get(address + i));
    }
    delta2.UTargetPosition += this.size;
  }
};
var RUN = class {
  constructor(size) {
    __publicField(this, "name", "RUN");
    this.size = size;
  }
  execute(delta2) {
    for (let i = 0; i < this.size; i++) {
      delta2.U.set(delta2.UTargetPosition + i, delta2.data[delta2.dataPosition]);
    }
    delta2.dataPosition++;
    delta2.UTargetPosition += this.size;
  }
};
var instructions = {
  ADD,
  COPY,
  RUN
};
var instructions_default = instructions;

// node_modules/@ably/vcdiff-decoder/lib/tokenize_instructions.js
function tokenizeInstructions(instructionsBuffer) {
  let deserializedInstructions = [];
  let instructionsPosition = 0;
  while (instructionsPosition < instructionsBuffer.length) {
    let index = instructionsBuffer[instructionsPosition++];
    let addSize, copySize, size;
    if (index === 0) {
      ({ value: size, position: instructionsPosition } = integer(instructionsBuffer, instructionsPosition));
      deserializedInstructions.push(new instructions_default.RUN(size));
    } else if (index === 1) {
      ({ value: size, position: instructionsPosition } = integer(instructionsBuffer, instructionsPosition));
      deserializedInstructions.push(new instructions_default.ADD(size));
    } else if (index < 19) {
      deserializedInstructions.push(new instructions_default.ADD(index - 1));
    } else if (index === 19) {
      ({ value: size, position: instructionsPosition } = integer(instructionsBuffer, instructionsPosition));
      deserializedInstructions.push(new instructions_default.COPY(size, 0));
    } else if (index < 35) {
      deserializedInstructions.push(new instructions_default.COPY(index - 16, 0));
    } else if (index === 35) {
      ({ value: size, position: instructionsPosition } = integer(instructionsBuffer, instructionsPosition));
      deserializedInstructions.push(new instructions_default.COPY(size, 1));
    } else if (index < 51) {
      deserializedInstructions.push(new instructions_default.COPY(index - 32, 1));
    } else if (index === 51) {
      ({ value: size, position: instructionsPosition } = integer(instructionsBuffer, instructionsPosition));
      deserializedInstructions.push(new instructions_default.COPY(size, 2));
    } else if (index < 67) {
      deserializedInstructions.push(new instructions_default.COPY(index - 48, 2));
    } else if (index === 67) {
      ({ value: size, position: instructionsPosition } = integer(instructionsBuffer, instructionsPosition));
      deserializedInstructions.push(new instructions_default.COPY(size, 3));
    } else if (index < 83) {
      deserializedInstructions.push(new instructions_default.COPY(index - 64, 3));
    } else if (index === 83) {
      ({ value: size, position: instructionsPosition } = integer(instructionsBuffer, instructionsPosition));
      deserializedInstructions.push(new instructions_default.COPY(size, 4));
    } else if (index < 99) {
      deserializedInstructions.push(new instructions_default.COPY(index - 80, 4));
    } else if (index === 99) {
      ({ value: size, position: instructionsPosition } = integer(instructionsBuffer, instructionsPosition));
      deserializedInstructions.push(new instructions_default.COPY(size, 5));
    } else if (index < 115) {
      deserializedInstructions.push(new instructions_default.COPY(index - 96, 5));
    } else if (index === 115) {
      ({ value: size, position: instructionsPosition } = integer(instructionsBuffer, instructionsPosition));
      deserializedInstructions.push(new instructions_default.COPY(size, 6));
    } else if (index < 131) {
      deserializedInstructions.push(new instructions_default.COPY(index - 112, 6));
    } else if (index === 131) {
      ({ value: size, position: instructionsPosition } = integer(instructionsBuffer, instructionsPosition));
      deserializedInstructions.push(new instructions_default.COPY(size, 7));
    } else if (index < 147) {
      deserializedInstructions.push(new instructions_default.COPY(index - 128, 7));
    } else if (index === 147) {
      ({ value: size, position: instructionsPosition } = integer(instructionsBuffer, instructionsPosition));
      deserializedInstructions.push(new instructions_default.COPY(size, 8));
    } else if (index < 163) {
      deserializedInstructions.push(new instructions_default.COPY(index - 144, 8));
    } else if (index < 175) {
      ({ addSize, copySize } = ADD_COPY(index, 163));
      deserializedInstructions.push(new instructions_default.ADD(addSize));
      deserializedInstructions.push(new instructions_default.COPY(copySize, 0));
    } else if (index < 187) {
      ({ addSize, copySize } = ADD_COPY(index, 175));
      deserializedInstructions.push(new instructions_default.ADD(addSize));
      deserializedInstructions.push(new instructions_default.COPY(copySize, 1));
    } else if (index < 199) {
      ({ addSize, copySize } = ADD_COPY(index, 187));
      deserializedInstructions.push(new instructions_default.ADD(addSize));
      deserializedInstructions.push(new instructions_default.COPY(copySize, 2));
    } else if (index < 211) {
      ({ addSize, copySize } = ADD_COPY(index, 199));
      deserializedInstructions.push(new instructions_default.ADD(addSize));
      deserializedInstructions.push(new instructions_default.COPY(copySize, 3));
    } else if (index < 223) {
      ({ addSize, copySize } = ADD_COPY(index, 211));
      deserializedInstructions.push(new instructions_default.ADD(addSize));
      deserializedInstructions.push(new instructions_default.COPY(copySize, 4));
    } else if (index < 235) {
      ({ addSize, copySize } = ADD_COPY(index, 223));
      deserializedInstructions.push(new instructions_default.ADD(addSize));
      deserializedInstructions.push(new instructions_default.COPY(copySize, 5));
    } else if (index < 239) {
      deserializedInstructions.push(new instructions_default.ADD(index - 235 + 1));
      deserializedInstructions.push(new instructions_default.COPY(4, 6));
    } else if (index < 243) {
      deserializedInstructions.push(new instructions_default.ADD(index - 239 + 1));
      deserializedInstructions.push(new instructions_default.COPY(4, 7));
    } else if (index < 247) {
      deserializedInstructions.push(new instructions_default.ADD(index - 243 + 1));
      deserializedInstructions.push(new instructions_default.COPY(4, 8));
    } else if (index < 256) {
      deserializedInstructions.push(new instructions_default.COPY(4, index - 247));
      deserializedInstructions.push(new instructions_default.ADD(1));
    } else {
      throw new Error("Should not get here");
    }
  }
  return deserializedInstructions;
}
function ADD_COPY(index, baseIndex) {
  let zeroBased = index - baseIndex;
  let addSizeIndex = Math.floor(zeroBased / 3);
  let addSize = addSizeIndex + 1;
  let copySizeIndex = zeroBased % 3;
  let copySize = copySizeIndex + 4;
  return { addSize, copySize };
}

// node_modules/@ably/vcdiff-decoder/lib/deserialize/delta.js
function delta(delta2, position) {
  let targetWindowLength, dataLength, instructionsLength, addressesLength;
  ({ value: targetWindowLength, position } = integer(delta2, position));
  if (delta2[position] !== 0) {
    throw new errors_default.NotImplemented(
      "VCD_DECOMPRESS is not supported, Delta_Indicator must be zero at byte " + position + " and not " + delta2[position]
    );
  }
  position++;
  ({ value: dataLength, position } = integer(delta2, position));
  ({ value: instructionsLength, position } = integer(delta2, position));
  ({ value: addressesLength, position } = integer(delta2, position));
  let dataNextPosition = position + dataLength;
  let data = delta2.slice(position, dataNextPosition);
  let instructionsNextPosition = dataNextPosition + instructionsLength;
  let instructions2 = delta2.slice(dataNextPosition, instructionsNextPosition);
  let deserializedInstructions = tokenizeInstructions(instructions2);
  let addressesNextPosition = instructionsNextPosition + addressesLength;
  let addresses = delta2.slice(instructionsNextPosition, addressesNextPosition);
  position = addressesNextPosition;
  let window2 = {
    targetWindowLength,
    position,
    data,
    instructions: deserializedInstructions,
    addresses
  };
  return window2;
}

// node_modules/@ably/vcdiff-decoder/lib/address_caches/near.js
var NearCache = class {
  constructor(size) {
    this.size = size;
    this.near = new Array(this.size).fill(0);
    this.nextSlot = 0;
  }
  update(address) {
    if (this.near.length > 0) {
      this.near[this.nextSlot] = address;
      this.nextSlot = (this.nextSlot + 1) % this.near.length;
    }
  }
  get(m, offset) {
    let address = this.near[m] + offset;
    return address;
  }
};

// node_modules/@ably/vcdiff-decoder/lib/address_caches/same.js
var SameCache = class {
  constructor(size) {
    this.size = size;
    this.same = new Array(this.size * 256).fill(0);
  }
  update(address) {
    if (this.same.length > 0) {
      this.same[address % (this.size * 256)] = address;
    }
  }
  get(m, offset) {
    let address = this.same[m * 256 + offset];
    return address;
  }
};

// node_modules/@ably/vcdiff-decoder/lib/vcdiff.js
var VCDiff = class {
  constructor(delta2, source) {
    this.delta = delta2;
    this.position = 0;
    this.source = source;
    this.targetWindows = new TypedArrayList();
  }
  decode() {
    this._consumeHeader();
    while (this._consumeWindow()) {
    }
    let targetLength = this.targetWindows.typedArrays.reduce((sum, uint8Array2) => uint8Array2.length + sum, 0);
    let target = new Uint8Array(targetLength);
    let position = 0;
    for (let arrayNum = 0; arrayNum < this.targetWindows.typedArrays.length; arrayNum++) {
      let array = this.targetWindows.typedArrays[arrayNum];
      let length = array.length;
      target.set(array, position);
      position += length;
    }
    return target;
  }
  _consumeHeader() {
    let hasVCDiffHeader = this.delta[0] === 214 && // V
    this.delta[1] === 195 && // C
    this.delta[2] === 196 && // D
    this.delta[3] === 0;
    if (!hasVCDiffHeader) {
      throw new errors_default.InvalidDelta("first 3 bytes not VCD");
    }
    let hdrIndicator = this.delta[4];
    let vcdDecompress = 1 & hdrIndicator;
    let vcdCodetable = 1 & hdrIndicator >> 1;
    if (vcdDecompress || vcdCodetable) {
      throw new errors_default.NotImplemented(
        "non-zero Hdr_Indicator (VCD_DECOMPRESS or VCD_CODETABLE bit is set)"
      );
    }
    this.position += 5;
  }
  _consumeWindow() {
    let winIndicator = this.delta[this.position++];
    let vcdSource = 1 & winIndicator;
    let vcdTarget = 1 & winIndicator >> 1;
    if (vcdSource && vcdTarget) {
      throw new errors_default.InvalidDelta(
        "VCD_SOURCE and VCD_TARGET cannot both be set in Win_Indicator"
      );
    } else if (vcdSource) {
      let sourceSegmentLength, sourceSegmentPosition, deltaLength;
      ({ value: sourceSegmentLength, position: this.position } = integer(this.delta, this.position));
      ({ value: sourceSegmentPosition, position: this.position } = integer(this.delta, this.position));
      ({ value: deltaLength, position: this.position } = integer(this.delta, this.position));
      let sourceSegment = this.source.slice(sourceSegmentPosition, sourceSegmentPosition + sourceSegmentLength);
      this._buildTargetWindow(this.position, sourceSegment);
      this.position += deltaLength;
    } else if (vcdTarget) {
      throw new errors_default.NotImplemented(
        "non-zero VCD_TARGET in Win_Indicator"
      );
    } else {
      let deltaLength;
      ({ value: deltaLength, position: this.position } = integer(this.delta, this.position));
      this._buildTargetWindow(this.position);
      this.position += deltaLength;
    }
    return this.position < this.delta.length;
  }
  // first integer is target window length
  _buildTargetWindow(position, sourceSegment) {
    let window2 = delta(this.delta, position);
    let T = new Uint8Array(window2.targetWindowLength);
    let U = new TypedArrayList();
    let uTargetPosition = 0;
    if (sourceSegment) {
      U.add(sourceSegment);
      uTargetPosition = sourceSegment.length;
    }
    U.add(T);
    let targetPosition = this.source.length;
    let dataPosition = 0;
    let delta2 = new Delta(U, uTargetPosition, window2.data, window2.addresses);
    window2.instructions.forEach((instruction) => {
      instruction.execute(delta2);
    });
    this.targetWindows.add(T);
  }
};
var Delta = class {
  constructor(U, UTargetPosition, data, addresses) {
    this.U = U;
    this.UTargetPosition = UTargetPosition;
    this.data = data;
    this.dataPosition = 0;
    this.addresses = addresses;
    this.addressesPosition = 0;
    this.nearCache = new NearCache(4);
    this.sameCache = new SameCache(3);
  }
  getNextAddressInteger() {
    let value;
    ({ value, position: this.addressesPosition } = integer(this.addresses, this.addressesPosition));
    return value;
  }
  getNextAddressByte() {
    let value = this.addresses[this.addressesPosition++];
    return value;
  }
};

// node_modules/@ably/vcdiff-decoder/lib/vcdiff_decoder.js
function decode4(delta2, source) {
  let vcdiff = new VCDiff(delta2, source);
  return vcdiff.decode();
}

// src/common/lib/client/filteredsubscriptions.ts
var FilteredSubscriptions = class {
  static subscribeFilter(channel, filter, listener) {
    const filteredListener = (m) => {
      var _a2, _b, _c, _d, _e, _f;
      const mapping = {
        name: m.name,
        refTimeserial: (_b = (_a2 = m.extras) == null ? void 0 : _a2.ref) == null ? void 0 : _b.timeserial,
        refType: (_d = (_c = m.extras) == null ? void 0 : _c.ref) == null ? void 0 : _d.type,
        isRef: !!((_f = (_e = m.extras) == null ? void 0 : _e.ref) == null ? void 0 : _f.timeserial),
        clientId: m.clientId
      };
      if (Object.entries(filter).find(
        ([key, value]) => value !== void 0 ? mapping[key] !== value : false
      )) {
        return;
      }
      listener(m);
    };
    this.addFilteredSubscription(channel, filter, listener, filteredListener);
    channel.subscriptions.on(filteredListener);
  }
  // Adds a new filtered subscription
  static addFilteredSubscription(channel, filter, realListener, filteredListener) {
    var _a2;
    if (!channel.filteredSubscriptions) {
      channel.filteredSubscriptions = /* @__PURE__ */ new Map();
    }
    if (channel.filteredSubscriptions.has(realListener)) {
      const realListenerMap = channel.filteredSubscriptions.get(realListener);
      realListenerMap.set(filter, ((_a2 = realListenerMap == null ? void 0 : realListenerMap.get(filter)) == null ? void 0 : _a2.concat(filteredListener)) || [filteredListener]);
    } else {
      channel.filteredSubscriptions.set(
        realListener,
        /* @__PURE__ */ new Map([[filter, [filteredListener]]])
      );
    }
  }
  static getAndDeleteFilteredSubscriptions(channel, filter, realListener) {
    if (!channel.filteredSubscriptions) {
      return [];
    }
    if (!realListener && filter) {
      return Array.from(channel.filteredSubscriptions.entries()).map(([key, filterMaps]) => {
        var _a2;
        let listenerMaps = filterMaps.get(filter);
        filterMaps.delete(filter);
        if (filterMaps.size === 0) {
          (_a2 = channel.filteredSubscriptions) == null ? void 0 : _a2.delete(key);
        }
        return listenerMaps;
      }).reduce(
        (prev, cur) => cur ? prev.concat(...cur) : prev,
        []
      );
    }
    if (!realListener || !channel.filteredSubscriptions.has(realListener)) {
      return [];
    }
    const realListenerMap = channel.filteredSubscriptions.get(realListener);
    if (!filter) {
      const listeners2 = Array.from(realListenerMap.values()).reduce((prev, cur) => prev.concat(...cur), []);
      channel.filteredSubscriptions.delete(realListener);
      return listeners2;
    }
    let listeners = realListenerMap.get(filter);
    realListenerMap.delete(filter);
    return listeners || [];
  }
};

// src/platform/web/modules.ts
Platform.BufferUtils = bufferutils_default;
Platform.Http = http_default;
Platform.Config = config_default;
Platform.Transports = ModulesTransports;
Platform.WebStorage = webstorage_default;
Platform.Vcdiff = { supported: true, bundledDecode: null };
http_default.bundledRequestImplementations = modulesBundledRequestImplementations;
logger_default.initLogHandlers();
Platform.Defaults = getDefaults(defaults_default2);
if (Platform.Config.agent) {
  Platform.Defaults.agent += " " + Platform.Config.agent;
}
if (Platform.Config.noUpgrade) {
  Platform.Defaults.upgradeTransports = [];
}
export {
  baserealtime_default as BaseRealtime,
  BaseRest,
  Crypto,
  ErrorInfo,
  fetchRequest as FetchRequest,
  FilteredSubscriptions as MessageInteractions,
  msgpack_default as MsgPack,
  RealtimePresence2 as RealtimePresence,
  Rest,
  decode4 as Vcdiff,
  websockettransport_default as WebSocketTransport,
  xhrpollingtransport_default as XHRPolling,
  xhrrequest_default as XHRRequest,
  xhrstreamingtransport_default as XHRStreaming,
  constructPresenceMessage,
  decodeEncryptedMessage,
  decodeEncryptedMessages,
  decodeMessage,
  decodeMessages,
  decodePresenceMessage,
  decodePresenceMessages,
  generateRandomKey,
  getDefaultCryptoParams
};
//# sourceMappingURL=index.js.map
